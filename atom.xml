<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杨文昊的个人博客</title>
  
  <subtitle>愿你出走半生，归来仍是少年。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-28T11:28:17.893Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Alpha Yang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【吴恩达笔记】线性回归</title>
    <link href="http://yoursite.com/2020/06/27/%E3%80%90%E5%90%B4%E6%81%A9%E8%BE%BE%E7%AC%94%E8%AE%B0%E3%80%91%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    <id>http://yoursite.com/2020/06/27/%E3%80%90%E5%90%B4%E6%81%A9%E8%BE%BE%E7%AC%94%E8%AE%B0%E3%80%91%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</id>
    <published>2020-06-27T14:58:06.000Z</published>
    <updated>2020-06-28T11:28:17.893Z</updated>
    
    <content type="html"><![CDATA[<p>吴恩达老师的机器学习公开课应该算是目前我见过，最适合小白入门的公开课程了。即使内容对新人比较友好，但我想还是需要整理些许笔记的，因为涉及到机器学习的基础阶段，各个概念的掌握情况，我跳过了一些对我个人而言不重要的栏目，比如线性代数和matlab教程这些。之后也会补上上课的作业，Coursera申请助学金需要时间比较久。</p><h3 id="一元线性回归-单变量线性回归-Linear-Regression-with-one-variable"><a href="#一元线性回归-单变量线性回归-Linear-Regression-with-one-variable" class="headerlink" title="一元线性回归(单变量线性回归)  Linear Regression with one variable"></a>一元线性回归(单变量线性回归)  Linear Regression with one variable</h3><a id="more"></a><h4 id="1-模型描述"><a href="#1-模型描述" class="headerlink" title="1. 模型描述"></a>1. 模型描述</h4><p>首先明确线性回归的作用，在机器学习中，我们可以广义的把机器学习划分为两类学习，监督学习与无监督学习。简单而言，监督学习就是给出了准确答案，期望计算机能学习其中的原理，并对我们未知的事情做出一定的预测。无监督学习就是指，我们并不知道准确结果的事情，希望机器通过学习，能从中抽取有效信息，举个简单的例子，例如邮箱垃圾邮件分类，新闻栏目划分等等，这些我们都能通过无监督学习去解决。</p><p>好了下面再举一个关于监督学习的例子，吴老师上课的例子是房价预估，如下图所示。</p><p><img src="/../image/ml1.jpg" alt=""></p><p>给你一定数量的数据集，代表房屋尺寸与价格的散点图，现在你希望知道除这些数据集以外的Size所对应的Price，相当于我之前说的预测。比如Size为1250时，那Price可能为2200左右这样子。那这个过程，我们实际就是想从现已知的数据集中学习某些知识内容，从而达到预测的效果。而这个过程就是我们所说的，<strong>回归</strong>。</p><p>其实就是拟合函数曲线，从而达到其与数据集的最优拟合，然后预测所有的Size。由于这个房子的单价这个假设中只与Size有关，所以我们称它为单变量或是一元。</p><p>下图是关于机器学习的基本流程图，你可以认为几乎所有机器学习问题都是这个框架的东西。</p><p><img src="/../image/ml2.jpg" alt=""></p><p>而这其中的$h$，代表$hypothesis$，由流程图可以看出，它是由数据集与学习算法得来的，在数学模型中，它代表回归模型，在机器学习中，我们通常把它称作假设函数。</p><script type="math/tex; mode=display">how\quad to \quad represent \quad h \quad ?\\h_{\theta}(x)=\theta_0+\theta_1x</script><p>以上便是我们在一元线性回归模型中的假设函数了，可以看出，实际上我们是对数据集拟合了一个一次函数，所以我们才说是线性回归，那么实际的问题中，当然不是所有问题都是线性的关系，这个我们之后再去说。好了，目前为止，我已经解释了所有关于一元线性回归模型的意义了，下面我们来看点重要的。</p><h4 id="2-代价函数-cost-function"><a href="#2-代价函数-cost-function" class="headerlink" title="2. 代价函数 cost function"></a>2. 代价函数 cost function</h4><p><img src="/../image/ml3.jpg" alt=""></p><p>下面我们来看个更具体的例子，我们已经给出了数据集，要求求出Size和Price的内在关系，可以很明显的知道这是个一元回归问题，至于线性，这个我们不是我们现在需要考虑的，我们就当它拟合为线性一次函数。首先先解释数据集中几个变量符号的意义：</p><ul><li><strong>m：数据集的数量</strong></li><li><strong>x：特征/输入变量</strong>      $x^{(i)}$代表第i个特征$(i=1,2,…,m)$</li><li><strong>y：目标/输出变量</strong>      $y^{(i)}$代表第i个目标$(i=1,2,…,m)$</li></ul><p>当然不同的人有不同的表示方法，我相信这不是比较关键的东西，whatever。我们还是需要得到我们的假设函数$h_{\theta}(x)=\theta_0+\theta_1x$，如何选择$\theta_i$，即参数，才是我们需要关注的问题。ps：之后的$h_{\theta}(x)$全部简写为$h(x)$</p><p>我们的目的当然是，一次线性函数与原数据集有高度的拟合，即我们假设函数$h(x)$得到的结果与原目标$y$差距越小越好，于是我们得到了我们所谓的回归目标：</p><script type="math/tex; mode=display">min_{\theta_i}:\frac{1}{2m}\sum_{i=1}^m \left(h(x^{(i)})-y^{(i)}\right)^2</script><p>这其实是个方差公式的形式，我们添上了系数1/2。然后很明显地，我们完全可以用这个函数来判断我们的拟合程度，这个值越小就说明我们的拟合效果越好。于是，我们就规定了一个函数：</p><script type="math/tex; mode=display">J(\theta_i)=\frac{1}{2m}\sum_{i=1}^m \left(h(x^{(i)})-y^{(i)}\right)^2</script><p>然而这个函数就是<strong>代价函数(cost function)</strong>，表面意思就是为了拟合某个数据集，我们所需要付出的代价。在所有机器学习的问题中，我们都在研究如何使得代价函数最小，也就是我们上面所说的回归目标。</p><p><img src="/../image/ml4.jpg" alt=""></p><p>解决问题时，我们通常会有两张常见的可视化图片，第一张是$h(x)$的图，也就是Size和Price的数据集的图，第二张图是关于代价函数的，也有画三维图的，当然也有这种画等高线的。在接下来的问题中，我们会研究通过何种算法，让机器帮助我们找到最优目标的参数值。</p><h4 id="3-梯度下降算法-Gradient-Descent-Algorithm"><a href="#3-梯度下降算法-Gradient-Descent-Algorithm" class="headerlink" title="3. 梯度下降算法  Gradient Descent Algorithm"></a>3. 梯度下降算法  Gradient Descent Algorithm</h4><p>再次明确我们的模型函数，我们现在有$J(\theta_i)$,目标是让这个函数得到最小值。朴素的思想就是我们可以定起始的$\theta_i$，然后不断地改变他们，直到他们最后到达了最小值。很明显，这样的想法我们还需要更可靠的算法，毕竟全部遍历是不可能的。</p><p>所以这也就引入了梯度下降算法来解决这个问题，先给大家看某个代价函数，以及算法实现的某个过程。</p><p><img src="/../image/ml5.jpg" alt=""></p><p>想法不变，我们从某个$(\theta_0,\theta_1)$开始，不断改变他们的值，直到收敛到局部最优。而这个改变的过程我们称为梯度下降，为了方便理解，我直接给出参数改变的公式，也就是$\theta_i$不断更新的依据，假设仅有两个参数的时候。</p><script type="math/tex; mode=display">\theta_j:=\theta_j-\alpha \frac{\partial}{\partial \theta_j}J(\theta_0,\theta_1) \quad (j=0,1)</script><p>这便是梯度下降最关键的地方，其中有了偏导数符号，这个如果看不懂的话，还是要先学微积分的。仔细想想的话，这样确实能通过下降的方式，使得代价函数收敛到局部最优解。其中$\alpha$代表学习率，你可以理解为每次更新的步长，这个也很关键，但是之后我们也会提到。</p><p>还有需要强调的是，我们的$\theta_i$是同步更新(Simultaneous update)的，这个如果你学过计算方法这门课中求解微分方程的两种方法或许你应该深有体会。</p><p>下面这个例子是同步更新</p><script type="math/tex; mode=display">\begin{align}\\Correct&:Simultaneous \quad update\\temp0&:=\theta_0-\alpha \frac{\partial}{\partial \theta_0}J(\theta_0,\theta_1)\\temp1&:=\theta_1-\alpha \frac{\partial}{\partial \theta_1}J(\theta_0,\theta_1)\\\theta_0&:=temp0\\\theta_1&:=temp1\end{align}</script><p>然后这是不同步更新的例子</p><script type="math/tex; mode=display">Incorrect\\temp0:=\theta_0-\alpha \frac{\partial}{\partial \theta_0}J(\theta_0,\theta_1)\\\theta_0:=temp0\\temp1:=\theta_1-\alpha \frac{\partial}{\partial \theta_1}J(\theta_0,\theta_1)\\\theta_1:=temp1</script><p>在不同步更新的例子中我们发现，$\theta_0$更新后带入了$\theta_1$的更新公式中，这不是我们想要的。</p><p>理解清楚了这个后，我们就明白了梯度下降法的公式了，你可能会说选择不同的开始的起始值会导致不同的收敛点，确实是这样，比如下面这个图。</p><p><img src="/../image/ml6.jpg" alt=""></p><p>很显然因为选择了不同的$\theta_i$会导致两种不同的路线，通过梯度下降算法我们只能找到局部收敛点，而不是全局最优点。不过这也没关系，我们处理问题的时候都尽量会选择弓形函数，也就是<strong>凸函数(convex function)</strong>.这种函数我们保证它仅有一个收敛点，即全局最优解。</p><h3 id="多元线性回归-Linear-Regression-with-Multiple-Variables"><a href="#多元线性回归-Linear-Regression-with-Multiple-Variables" class="headerlink" title="多元线性回归  Linear Regression with Multiple Variables"></a>多元线性回归  Linear Regression with Multiple Variables</h3><h4 id="1-模型描述-多特征"><a href="#1-模型描述-多特征" class="headerlink" title="1. 模型描述 多特征"></a>1. 模型描述 多特征</h4><p>我们根据上面那个房价的例子，很显然在实际的生活中，房价Price绝不可能只与其Size有关系的，你的北京六环和二环的房子能比得起来吗？哦，我知道你没有。这里还是根据那个房价的例子，不过我们提出了更多的影响因素。</p><p><img src="/../image/ml7.jpg" alt=""></p><p>我们还是首先来规定下符号：</p><ul><li><strong>m：数据集的数量</strong></li><li><strong>n：特征的个数</strong>  例如此例n=4</li><li><strong>$x^{(i)}$：序号为i的数据集的特征向量</strong></li><li><strong>$x_j^{(i)}$：序号为i的数据集的第j个特征</strong>  比如40年我们如何表示？ $x_4^{(2)}$=40</li></ul><p>假设函数那当然也是多变量的了，我默认大家都学完了矩阵的东西，所以我就直接用矩阵的表示形式来列了。</p><script type="math/tex; mode=display">h(x)=\theta_0+\theta_1x_1+\theta_2x_2+...+\theta_nx_n\\define \quad x_0=1\\x=\begin{bmatrix} x_0\\x_1\\x_2\\\vdots\\x_n \end{bmatrix} \quad \theta=\begin{bmatrix} \theta_0\\\theta_1\\\theta_2\\\vdots\\\theta_n \end{bmatrix}\\h(x)=\theta^Tx</script><p>我们采用矩阵的表达方式，已经写出了假设函数的矩阵形式，很简单，那下面就来说说如何在这个假设函数中进行梯度下降。</p><h4 id="2-多变量梯度下降"><a href="#2-多变量梯度下降" class="headerlink" title="2. 多变量梯度下降"></a>2. 多变量梯度下降</h4><p>其实梯度下降的公式都是一样的，只不过原来一元的时候只需要更新两个$\theta$值，现在需要更新n个，仅此而已。</p><script type="math/tex; mode=display">\theta_j:=\theta_j-\alpha \frac{\partial}{\partial \theta_j}J(\theta) \quad (j=0,1,...,n)</script><p>但是我们需要注意的，可不是这些。</p><h5 id="1-特征缩放"><a href="#1-特征缩放" class="headerlink" title="(1) 特征缩放"></a>(1) 特征缩放</h5><p>线性回归的目的就是在于求出我们所需要的权重，即$\theta$值，而权重和每个特征量的大小相关。试想一下，如果一个房间的Size的范围是1000左右，而房子的楼层是3以内的数，那我们直接拟合出来的权重，肯定更偏向于Size啊，而这显然不符合实际情况。这就是多元回归区别于一元回归的事情，一元回归就一个变量，咱们不需要考虑其大小范围。但是多元我们必须考虑，我们最好能够将所有变量统一缩放到某个区间，比如$-1\leq x_i\leq 1$。当然这个区间不是必须的，这里只给个参考范围。而对于所有的变量，我们都需要先进行<strong>均值标准化(Mean Normalization)</strong> 的处理。</p><script type="math/tex; mode=display">Mean \quad Normalization\\x_j:=\frac{x_j-\mu_j}{\sigma_j}</script><p>我相信如果你学过概率论的话，这个式子应该经常出现，不管是在八大公式还是假设检验里面。还是需要解释一下，这其中$\mu_j$表示第j组特征向量的均值，而$\sigma_j$表示第j组数据的标准差。</p><h5 id="2-特征合并"><a href="#2-特征合并" class="headerlink" title="(2) 特征合并"></a>(2) 特征合并</h5><p>这个是很好理解，也算是多元线性回归里面的一点技巧。比如题目给出的因素中，Price与房子的frontage和depth有关，那我们就要想到$Size=Frontage\times Depth$。于是我们就能把这个两个特征当成一个来处理，其实实际问题中这样的例子还是挺常见的。</p><h5 id="3-学习率与假设函数选择"><a href="#3-学习率与假设函数选择" class="headerlink" title="(3) 学习率与假设函数选择"></a>(3) 学习率与假设函数选择</h5><p>关于学习率$\alpha$与假设函数次项的选择，我在这里就不明说了，因为我自己也不是很能给出一个具体的方案。以及这样的情况遇到的较少。</p><h3 id="正规方程求解参数-Normal-Equation"><a href="#正规方程求解参数-Normal-Equation" class="headerlink" title="正规方程求解参数  Normal Equation"></a>正规方程求解参数  Normal Equation</h3><p>事实上，我们除了梯度下降法，还有另一种方法求解我们所需要的参数以及权重$\theta$的方法，就是用普通的方程求解，剩下的交给MATLAB就好，以上面那个例子来说明。</p><p><img src="/../image/ml7.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;吴恩达老师的机器学习公开课应该算是目前我见过，最适合小白入门的公开课程了。即使内容对新人比较友好，但我想还是需要整理些许笔记的，因为涉及到机器学习的基础阶段，各个概念的掌握情况，我跳过了一些对我个人而言不重要的栏目，比如线性代数和matlab教程这些。之后也会补上上课的作业，Coursera申请助学金需要时间比较久。&lt;/p&gt;
&lt;h3 id=&quot;一元线性回归-单变量线性回归-Linear-Regression-with-one-variable&quot;&gt;&lt;a href=&quot;#一元线性回归-单变量线性回归-Linear-Regression-with-one-variable&quot; class=&quot;headerlink&quot; title=&quot;一元线性回归(单变量线性回归)  Linear Regression with one variable&quot;&gt;&lt;/a&gt;一元线性回归(单变量线性回归)  Linear Regression with one variable&lt;/h3&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="吴恩达课程笔记" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%90%B4%E6%81%A9%E8%BE%BE%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>【XDUACM暑培】二分法洛谷作业题解</title>
    <link href="http://yoursite.com/2020/06/25/%E3%80%90XDUACM%E6%9A%91%E5%9F%B9%E3%80%91%E4%BA%8C%E5%88%86%E6%B3%95%E6%B4%9B%E8%B0%B7%E4%BD%9C%E4%B8%9A%E9%A2%98%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/06/25/%E3%80%90XDUACM%E6%9A%91%E5%9F%B9%E3%80%91%E4%BA%8C%E5%88%86%E6%B3%95%E6%B4%9B%E8%B0%B7%E4%BD%9C%E4%B8%9A%E9%A2%98%E8%A7%A3/</id>
    <published>2020-06-24T18:13:49.000Z</published>
    <updated>2020-06-24T11:32:27.506Z</updated>
    
    <content type="html"><![CDATA[<p>二分法模板与思路可见我之前的<a href="[https://www.alpha-yang.cn/2020/06/25/%E3%80%90%E4%BA%8C%E5%88%86%E3%80%91%E6%80%9D%E8%B7%AF%E4%B8%8E%E6%A8%A1%E6%9D%BF/](https://www.alpha-yang.cn/2020/06/25/[二分]思路与模板/">二分博客</a>)或<a href="https://zhuanlan.zhihu.com/p/150570206" target="_blank" rel="noopener">知乎专栏</a>，这次作业的题目比较容易，相对于【图论与树】，所以我就先写题解了。</p><h4 id="P1024-一元三次方程求解"><a href="#P1024-一元三次方程求解" class="headerlink" title="P1024 一元三次方程求解"></a>P1024 一元三次方程求解</h4><p>题目地址：<a href="https://www.luogu.com.cn/problem/P1024" target="_blank" rel="noopener">P1024 一元三次方程求解</a></p><a id="more"></a><p>二分法，题目告诉你保证有三个根，且差的绝对值都大于1，那就是说明-100~100的区间，以1为间隔，每个小区间最多有一个根，那就好说了。先把这三个小区间给一个个揪出来，满足<code>f(i)*f(i+1)&lt;0</code>一定有一个实根在这个小区间里面，因为是精确到小数点后两位。为了继续能用整数二分法的模板，我们把所有数放大100倍，比如[15,16]的区间有根，那我们以1为步长遍历[1500,1600]出来除以100就行了(特别当心浮点数陷阱)。</p><p>再讲讲二分的部分，还是略微改动了下模板的。对于判断条件，我们分别左临界为<code>y</code>，右临界为<code>z</code>，中间点为<code>x</code>，如果<code>f(x)*f(y)&lt;=0</code>，那就说明我们需要让x作为新的右临界。</p><p>以此二分下去，直到剩下最小的区间，如[1559,1560]，只存在两个值了，分别是15.59和15.60。对于这两个数我们再选取计算离0近的返回作为我们的答案即可。</p><p>最后附上ac代码，对细节有注释。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> a,b,c,d;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span> <span class="comment">// 函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a*x*x*x+b*x*x+c*x+d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> p=x*<span class="number">1.00</span>/<span class="number">100</span>,q=y*<span class="number">1.00</span>/<span class="number">100</span>,r=z*<span class="number">1.00</span>/<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> (f(p)*f(q)&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left+<span class="number">1</span>&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        mid=(left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        (check(mid,left,right) ? left : right) =mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(f(left*<span class="number">1.00</span>/<span class="number">100</span>))&lt;=<span class="built_in">abs</span>(f(right*<span class="number">1.00</span>/<span class="number">100</span>))) <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">    <span class="keyword">int</span> i,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">-100</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (f(i*<span class="number">1.00</span>)*f((i+<span class="number">1</span>)*<span class="number">1.00</span>)&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            x=binary_search(i*<span class="number">100</span>,(i+<span class="number">1</span>)*<span class="number">100</span>)*<span class="number">1.00</span>/<span class="number">100</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%.2lf "</span>,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (f(i*<span class="number">1.00</span>)==<span class="number">0</span>) <span class="comment">// 如果区间上i正好等于0，单独判断，防止重判</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%.2lf "</span>,i*<span class="number">1.00</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans==<span class="number">3</span>) <span class="keyword">break</span>; <span class="comment">// 题目保证有且仅有三个解，所以三个解的时候退出，可以节省一点时间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P2678-跳石头"><a href="#P2678-跳石头" class="headerlink" title="P2678 跳石头"></a>P2678 跳石头</h4><p>题目地址：<a href="https://www.luogu.com.cn/problem/P2678" target="_blank" rel="noopener">P2678 跳石头</a></p><p>很经典的OI题目，也是道很经典的二分题，看到最值这些问题，先考虑二分的flag。用二分法做题首先我们得明确二分的对象，很显然不可能是石头序号，所以应该是二分距离。简单点，题目问你啥你二分啥，下面来说说具体的思路。</p><p>不能被移走的石头束缚住，这是个前提。移走的石头数不是重点，<strong>需不需要移走才是重点</strong>。好吧，这么讲还是有点不形象，这题要我们求最短跳跃距离的最大值。思考一下，我们的二分是往上分的，如果<code>mid</code>满足条件，那就让<code>left=mid</code>，继续向上二分查找，看看有没有更大的可能结果。</p><p>下面就是判断条件，即什么样的<code>mid</code>满足条件，也是本题的核心思路所在。之前说了不能被移走的石头数量给束缚住，让我们反过来思考，为了达到这个最短跳跃距离，需要移走多少块石头。我们将距离设为<code>d[i]</code>，即第i个石头到起点的距离，以下为核心代码，<code>check</code>函数部分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s=<span class="number">0</span>,i=<span class="number">0</span>,flag=<span class="number">0</span>; <span class="comment">// s代表当前移走的石头数，i代表当前走到的石头序号，flag代表离i最近没被移走的石头序号</span></span><br><span class="line">    <span class="keyword">while</span> (i&lt;n+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span> (d[i]-d[flag]&lt;x) s++;</span><br><span class="line">        <span class="keyword">else</span> flag=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s&lt;=m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置三个变量s，i，flag。如果我们发现<code>d[i]-d[flag]&lt;x</code>，那就说明这两块石头中间的石头必须挪走(中间肯定有石头，因为二分的初始值就是距离的一半)，反之则flag也前移。如果需要移走的石头数大于我们题目组委会移走的石头数，对不起，不符合条件。这时我们再向下二分查找，以此类推。</p><p>最后附上ac代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">5e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> d[maxn];</span><br><span class="line"><span class="keyword">int</span> l,m,n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s=<span class="number">0</span>,i=<span class="number">0</span>,flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;n+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span> (d[i]-d[flag]&lt;x) s++;</span><br><span class="line">        <span class="keyword">else</span> flag=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s&lt;=m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left+<span class="number">1</span>&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        mid=(left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        (check(mid) ? left : right) =mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> check(right) ? right : left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;l&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;d[i];</span><br><span class="line">    d[n+<span class="number">1</span>]=l;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;binary_search(<span class="number">1</span>,l)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P3853-TJOI2007-路标设置"><a href="#P3853-TJOI2007-路标设置" class="headerlink" title="P3853 [TJOI2007]路标设置"></a>P3853 [TJOI2007]路标设置</h4><p>题目地址：<a href="https://www.luogu.com.cn/problem/P3853" target="_blank" rel="noopener">P3853 [TJOI2007]路标设置</a></p><p>这个题目啊，几乎和P2678跳石头一模一样，甚至还要更简单一点。“空旷指数”就是距离，那此题我们就对距离进行二分。跳石头是移走石头，本题是加路标，思路几乎一模一样。</p><p>要我们求最小空旷指数，这就不一样了，这是向下二分，如果<code>mid</code>满足条件，那我们就得让<code>mid=right</code>，进行更小的可能值的查找了。</p><p>上面那点明确后，我们再来确定判断条件，也就是核心思想的部分。一样的本题加路牌，为了验证<code>mid</code>是否符合条件，我们算出两两路牌之间的距离，<code>a[i]</code>表示第i个路牌的距离，如果<code>a[i+1]-a[i]&gt;mid</code>，那就i和i+1中间得加路牌，那加几个呢？用距离除以mid即可，但一定小心一个整除的问题，例如<code>mid=5,a[i+1]-a[i]=10</code>时，虽然除的结果是2，但实际上距离为10的中间只需要差一块路牌即可。这是我们就需要对于整除的情况减一了，整数情况可以这样判断<code>(a[i+1]-a[i])/x*x==a[i+1]-a[i] ? 1 : 0</code>。附上核心代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>,i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;n+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span> (a[i+<span class="number">1</span>]-a[i]&gt;x) </span><br><span class="line">            ans+=(a[i+<span class="number">1</span>]-a[i])/x-((a[i+<span class="number">1</span>]-a[i])/x*x==a[i+<span class="number">1</span>]-a[i] ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans&lt;=k; <span class="comment">// 如果需要加的路牌小于等于规定加的路牌，则判断为真</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是<code>check</code>函数表示的永远是符合条件的判断，也就是说符合就是true，反之则是false。至于最大值最小值，那就是二分法里关于左右区间的判断了。</p><p>最后是完整ac代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l,n,k;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>,i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;n+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span> (a[i+<span class="number">1</span>]-a[i]&gt;x) </span><br><span class="line">            ans+=(a[i+<span class="number">1</span>]-a[i])/x-((a[i+<span class="number">1</span>]-a[i])/x*x==a[i+<span class="number">1</span>]-a[i] ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans&lt;=k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left+<span class="number">1</span>&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        mid=(left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        (check(mid) ? right : left)=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> check(left) ? left : right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;l&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    a[n+<span class="number">1</span>]=l;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;binary_search(<span class="number">0</span>,l)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二分法模板与思路可见我之前的&lt;a href=&quot;[https://www.alpha-yang.cn/2020/06/25/%E3%80%90%E4%BA%8C%E5%88%86%E3%80%91%E6%80%9D%E8%B7%AF%E4%B8%8E%E6%A8%A1%E6%9D%BF/](https://www.alpha-yang.cn/2020/06/25/[二分]思路与模板/&quot;&gt;二分博客&lt;/a&gt;)或&lt;a href=&quot;https://zhuanlan.zhihu.com/p/150570206&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;知乎专栏&lt;/a&gt;，这次作业的题目比较容易，相对于【图论与树】，所以我就先写题解了。&lt;/p&gt;
&lt;h4 id=&quot;P1024-一元三次方程求解&quot;&gt;&lt;a href=&quot;#P1024-一元三次方程求解&quot; class=&quot;headerlink&quot; title=&quot;P1024 一元三次方程求解&quot;&gt;&lt;/a&gt;P1024 一元三次方程求解&lt;/h4&gt;&lt;p&gt;题目地址：&lt;a href=&quot;https://www.luogu.com.cn/problem/P1024&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;P1024 一元三次方程求解&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="ACM算法" scheme="http://yoursite.com/categories/ACM%E7%AE%97%E6%B3%95/"/>
    
      <category term="洛谷试炼场" scheme="http://yoursite.com/categories/ACM%E7%AE%97%E6%B3%95/%E6%B4%9B%E8%B0%B7%E8%AF%95%E7%82%BC%E5%9C%BA/"/>
    
    
      <category term="二分" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>【二分】思路与模板</title>
    <link href="http://yoursite.com/2020/06/25/%E3%80%90%E4%BA%8C%E5%88%86%E3%80%91%E6%80%9D%E8%B7%AF%E4%B8%8E%E6%A8%A1%E6%9D%BF/"/>
    <id>http://yoursite.com/2020/06/25/%E3%80%90%E4%BA%8C%E5%88%86%E3%80%91%E6%80%9D%E8%B7%AF%E4%B8%8E%E6%A8%A1%E6%9D%BF/</id>
    <published>2020-06-24T16:10:30.000Z</published>
    <updated>2020-06-24T11:33:57.164Z</updated>
    
    <content type="html"><![CDATA[<p>西电ACM暑假培训二分法课程，感谢柴东辰大佬的讲课！</p><p>二分算法，就是为了在<strong>单调</strong>的序列中寻找某个值，而每次选取中间位置，合理减少问题的规模，从而快速得到答案。</p><p>二分法，我想大家肯定都知道，这里我也不再赘述了，不过二分法的模板网上到处都是，但是有问题的也很多，比如这题是mid+1，那题是mid-1，也就是边界条件难以处理，很讨厌对吧？所以我这里介绍一种通用模板并分析思路。</p><a id="more"></a><p>哦对了，想给个标准的情景，1~n，查找x。就这么简单，暴力的话复杂度会达到O(n)，如果用二分法就是O(logn)了。废话不多说，直接上万用板(感谢柴大佬的模板)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> k)</span> <span class="comment">// 判断真假情况的，根据题目意思自己写不同的check函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> k&lt;=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left+<span class="number">1</span>&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        mid=(left+right)&gt;&gt;<span class="number">1</span>; <span class="comment">// 位运算加快速度</span></span><br><span class="line">        (check(mid) ? left : right) =mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> check(right) ? right : left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是个二分法模板，查找1~n的区间，可以查找的是任何东西。如果满足<code>left+1&lt;right</code>的条件，那就继续二分，反言之，如果<code>left+1&gt;=right</code>就不继续二分了。</p><p>二分求出左右区间的mid值，判断mid的条件，会根据题目改变而改变。此题的条件是，如果价格偏高返回false，此时让<code>right=mid</code>，如果价格偏低或者相等，返回true，此时让<code>left=mid</code>。知道区间仅剩下<code>left,right</code>两个数时，即条件<code>left+1&gt;=right</code>，此时我们需要查找的数一定在<code>left</code>和<code>right</code>之间了，这样很好理解了吧。</p><p>以上模板是稳定不易出错的写法，下面我们来尝试二分法的题目。</p><p>请移步我洛谷<a href="[https://www.alpha-yang.cn/2020/06/25/%E3%80%90XDUACM%E6%9A%91%E5%9F%B9%E3%80%91%E4%BA%8C%E5%88%86%E6%B3%95%E6%B4%9B%E8%B0%B7%E4%BD%9C%E4%B8%9A%E9%A2%98%E8%A7%A3/](https://www.alpha-yang.cn/2020/06/25/[XDUACM暑培]二分法洛谷作业题解/">二分博客</a>)或<a href="https://zhuanlan.zhihu.com/p/150570433" target="_blank" rel="noopener">知乎专栏</a>的题解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;西电ACM暑假培训二分法课程，感谢柴东辰大佬的讲课！&lt;/p&gt;
&lt;p&gt;二分算法，就是为了在&lt;strong&gt;单调&lt;/strong&gt;的序列中寻找某个值，而每次选取中间位置，合理减少问题的规模，从而快速得到答案。&lt;/p&gt;
&lt;p&gt;二分法，我想大家肯定都知道，这里我也不再赘述了，不过二分法的模板网上到处都是，但是有问题的也很多，比如这题是mid+1，那题是mid-1，也就是边界条件难以处理，很讨厌对吧？所以我这里介绍一种通用模板并分析思路。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ACM算法" scheme="http://yoursite.com/categories/ACM%E7%AE%97%E6%B3%95/"/>
    
      <category term="西电培训笔记" scheme="http://yoursite.com/categories/ACM%E7%AE%97%E6%B3%95/%E8%A5%BF%E7%94%B5%E5%9F%B9%E8%AE%AD%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="二分" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>【图论与树】最短路径Dijkstra与Floyd算法</title>
    <link href="http://yoursite.com/2020/06/23/%E3%80%90%E5%9B%BE%E8%AE%BA%E4%B8%8E%E6%A0%91%E3%80%91%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84Dijkstra%E4%B8%8EFloyd%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/06/23/%E3%80%90%E5%9B%BE%E8%AE%BA%E4%B8%8E%E6%A0%91%E3%80%91%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84Dijkstra%E4%B8%8EFloyd%E7%AE%97%E6%B3%95/</id>
    <published>2020-06-23T10:05:20.000Z</published>
    <updated>2020-06-24T11:08:43.850Z</updated>
    
    <content type="html"><![CDATA[<p>在图论中有一个非常常见的问题，就是最短路径的问题。常见的最短路径算法有三种：dijkstra，floyd和SPFA。本文将带你了解前两种最短路算法，他们分别适用于不同场景下的问题。</p><p>以下笔记乃是参考西电ACM暑假培训张帆大佬的讲课以及<a href="https://www.cnblogs.com/xzxl/p/7266404.html" target="_blank" rel="noopener">优先队列博客</a></p><a id="more"></a><h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><p>首先我们必须了解这个算法的两个局限之处，才能做题</p><ul><li>不能适用于负权图</li><li>只适用于单源最短路问题</li></ul><p>如果权重是负数，那就直接pass这个算法，在这里原因不表。</p><p><strong>单源最短路径</strong>就是指只有一个出发点，到其他点的最短路径问题，以下问题也在这个前提下展开。</p><p>下面我们就来说说算法流程：</p><ul><li>S1. 设置dis数组，<code>dis[i]</code>表示起点start到i的距离。</li><li>S2. 从点集V中弹出一个dis值最小且未以该点为起点进行松弛操作的点。</li><li>S3. 从该点松弛与其领接的各个点更新dis数组，返回S2，循环进行。</li><li>通过优先队列的操作可以优化S2，之后详细说明。</li></ul><p><img src="https://i.loli.net/2020/06/23/T7m3JYt2evIwKLP.png" alt=""></p><p>如果这样说，有点抽象。那就举个例子。这个例子也是洛谷的单源最短路径的模板题，请求出1到各点的最短路？</p><p>很显然你用肉眼看，1到本身是0,1到2、3、4的最短路分别为2,4,3。那dijkstra的操作流程是什么呢？</p><p>首先我们先开一个dis数组，让数组的值足够大，<code>dis[i]=0x7fffffff</code>,从1开始出发，令<code>dis[1]=0</code>，发现与1相连的有三个点234，那我们一个个进行松弛操作，比较<code>if (dis[1]+w[i]&lt;dis[i])</code>,w表示各边的权重，如果小于，那就让其覆盖本身的dis值，即<code>dis[i]=dis[1]+w[i]</code>，这一波更新完后，234的值分别为2,5,4。</p><p>然后，我们需要让234全部入队，并选取dis值最小的数即2继续进行松弛操作，发现连接的是3和4，继续更新，这波结束，234的值分别为2,4,3。</p><p>接着，是上一轮dis值次小的点4，进行操作，但是4没有出的边，所以不进行操作。</p><p>最后就是剩下的一个3了，3和4还有一条权边，但是4最小的dis值依旧是3。</p><p>下面我们发现算法到这就截止了，为什么呢，因为S2的一句话，未进行松弛的点，早在第一轮234就已经全部进入过队列并且已经弹出过了，所以之后他们也不会再进入队列，我们可以设置一个bool类型的<code>vis[i]</code>数组代表第i个点是否被访问过了，如果访问过了就结束此循环，或者直接不push进入队列。</p><p>这就是整个dijkstra的算法，其实很好理解，证明我们就先略过了。</p><h4 id="优先队列priority-queue"><a href="#优先队列priority-queue" class="headerlink" title="优先队列priority_queue"></a>优先队列priority_queue</h4><p>上面那个算法有个问题，就是怎样才能保证每次弹出的都是dis最小的数呢？如果用普通队列，不能解决这个问题，如果每次都遍历一遍来找，那复杂度直接O(VE)，百分百会被T掉。</p><p>所以我们这里采用优先队列priority_queue对S2进行堆优化，就变成O((V+E)logV)了，所以做题的时候堆优化+dijkstra都是一起出现的，模板也是一起写的。</p><p><strong>优先队列</strong>：按照一定次序的队列结构，升序或降序，从小到大排列，push和pop都遵循其规律。</p><p>优先队列的详细用法请参照这篇<a href="https://www.cnblogs.com/xzxl/p/7266404.html" target="_blank" rel="noopener">博客</a>，本文仅描述dijkstra模板下的用法。</p><p>首先对于图论中的<strong>每条点</strong>，我们都需建立一个<code>node</code>结构体，包含两个内容<code>num</code>和<code>dis</code>。分别表示该点的序号以及dis值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num,dis;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue &lt;node&gt; q;</span><br></pre></td></tr></table></figure><p>然而这样建立优先队列是会报错的，因为优先队列无法对结构体进行优先级比较。所以我们就想办法告诉程序，我们的队列是对结构体的哪儿个值进行排序，其实做法有很多，我习惯的方式是采取重载的形式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num,dis;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;x)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.dis &lt; dis; <span class="comment">// dis小的结构体在队列中的优先级高</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue &lt;node&gt; q;</span><br></pre></td></tr></table></figure><p>请重载&lt;号，别重载&gt;会报错的。这里如果不理解的就死记硬背把，讲重载的话又要涉及很多知识。</p><h4 id="【模板】Dijkstra算法实现"><a href="#【模板】Dijkstra算法实现" class="headerlink" title="【模板】Dijkstra算法实现"></a>【模板】Dijkstra算法实现</h4><p>以洛谷模板题为例，<a href="https://www.luogu.com.cn/problem/P4779" target="_blank" rel="noopener">P4779 【模板】单源最短路径（标准版）</a></p><p>这道题目的样例就是我上面所举的例子。上面我们解决了算法思路，以及用优先队列的方式对步骤2弹出dis最小的点进行了堆优化，下面我们还需要解决程序细节的问题。</p><p>先是存边的问题，这道题不存在重边等为难我们的限制，所以直接构造结构体<code>edge</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,cost; <span class="comment">// to代表下一个点，cost代表该边的权重</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span> &lt;edge&gt; e[maxn];</span><br></pre></td></tr></table></figure><p>之后就是存边，然后进行Dijkstra算法，我直接上代码了，我的代码还是新手向的，不会设计复杂的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,cost;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num,dis;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;x)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.dis &lt; dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; e[maxm];</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn]; <span class="comment">// 布尔型vis数组</span></span><br><span class="line"><span class="keyword">int</span> n,m,s,cnt=<span class="number">0</span>;</span><br><span class="line">priority_queue &lt;node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> <span class="comment">// 存边</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[u].push_back((edge)&#123;v,w&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    q.push((node)&#123;s,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        node tmp=q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">int</span> x=tmp.num;</span><br><span class="line">        <span class="keyword">if</span> (vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[x]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (edge k:e[x]) <span class="comment">// 遍历边信息，请注意洛谷请选用c++11，否则编译错误</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[x] + k.cost &lt; dis[k.to])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[k.to]=dis[x]+k.cost;</span><br><span class="line">                <span class="keyword">if</span> (!vis[k.to]) q.push((node)&#123;k.to,dis[k.to]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) dis[i]=<span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        add_edge(u,v,w);</span><br><span class="line">    &#125;</span><br><span class="line">    dijkstra();</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cout</span>&lt;&lt;dis[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1608-路径统计"><a href="#P1608-路径统计" class="headerlink" title="P1608 路径统计"></a>P1608 路径统计</h4><p>题目地址：<a href="https://www.luogu.com.cn/problem/P1608" target="_blank" rel="noopener">P1608 路径统计</a></p><p>这题基本也是个Dijkstra的模板题，大方向都没有任何变化。我们首先先考虑一个比较简单的问题，就是题目中的重边该怎么去除，重边我们当然选择最短的那条边，其实也不复杂。我采取的方法是邻接矩阵的办法，再把邻接矩阵转为边信息，考虑到N最大值为2000，二维矩阵肯定不会炸。（忽略奇怪的缩进</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> p,q,c,tmp;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;p&gt;&gt;q&gt;&gt;c;</span><br><span class="line">        <span class="keyword">if</span> (cmp[i][j]==<span class="number">0</span> || c&lt;cmp[i][j]) cmp[i][j]=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span> (cmp[i][j]) e[i].push_back((edge)&#123;j,cmp[i][j]&#125;);</span><br></pre></td></tr></table></figure><p>这样就把重边给处理了，菜鸡的我也没想到其他方法了。。。</p><p>然后就是来处理本题的问题，最短路径非常简单，但是统计个数，还是需要思索一下的。我的办法是准备一个<code>ans</code>数组，<code>ans[i]</code>表示第i个点的最短路径的条数，好家伙！这样层层递推，就能推到第N个点了。</p><p>这样其实没啥问题，但是有可能统计第k个点，我统计了两条最短路径，突然来了一条更短的，这是我们的<code>ans[k]</code>从2又变回了1，好说！让k点的值等于最短路径上一个点的ans值就可以了。</p><p>所以核心代码如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dis[k.to]==dis[x]+k.w) ans[k.to]+=ans[x];</span><br><span class="line"><span class="keyword">if</span> (dis[k.to]&gt;dis[x]+k.w)</span><br><span class="line">&#123;</span><br><span class="line">    dis[k.to]=dis[x]+k.w;</span><br><span class="line">    ans[k.to]=ans[x];</span><br><span class="line">    q.push((node)&#123;dis[k.to],k.to&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是这样如果有相等的路径就相加，有小于的路径就让其ans值回去。如果最后的<code>dis[n]=0x7fffffff</code>，那说明根本没路径能到达它，无解。</p><p>最后附上ac代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=maxn*(maxn<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> dis,num;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;x)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.dis&lt;dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt;edge&gt; e[maxm];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">int</span> ans[maxn];</span><br><span class="line"><span class="keyword">int</span> cmp[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line">priority_queue &lt;node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    ans[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    q.push((node)&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        node tmp=q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">int</span> x=tmp.num;</span><br><span class="line">        <span class="keyword">if</span> (vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[x]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (edge k : e[x])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[k.to]==dis[x]+k.w) ans[k.to]+=ans[x];</span><br><span class="line">            <span class="keyword">if</span> (dis[k.to]&gt;dis[x]+k.w)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[k.to]=dis[x]+k.w;</span><br><span class="line">                ans[k.to]=ans[x];</span><br><span class="line">                q.push((node)&#123;dis[k.to],k.to&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) dis[i]=<span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> p,q,c,tmp;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;p&gt;&gt;q&gt;&gt;c;</span><br><span class="line">        <span class="keyword">if</span> (cmp[i][j]==<span class="number">0</span> || c&lt;cmp[i][j]) cmp[i][j]=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span> (cmp[i][j]) e[i].push_back((edge)&#123;j,cmp[i][j]&#125;);</span><br><span class="line">    dijkstra();</span><br><span class="line">    <span class="keyword">if</span> (dis[n]!=<span class="number">0x7fffffff</span>) <span class="built_in">cout</span>&lt;&lt;dis[n]&lt;&lt;<span class="string">" "</span>&lt;&lt;ans[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"No answer"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h3><p>著名的Floyd算法，算法的核心代码非常短，时间复杂度$O(V^3)$。采用邻接矩阵<code>arr[i][j]</code>的方式存图，三层循环不可调换。具体原理可以用dp来解释，在此不表。直接上核心代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=N;k++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N;j++)</span><br><span class="line">            arr[i][j]=<span class="built_in">min</span>(arr[i][j],arr[i][k]+arr[k][j]);</span><br></pre></td></tr></table></figure><p>Floyd算法还需要看看练习题：<a href="https://www.luogu.com.cn/problem/P1119" target="_blank" rel="noopener">P1119 灾后重建</a></p><p>也可以看看我关与此题的题解，见<a href="[https://www.alpha-yang.cn/2020/06/23/%E3%80%90%E5%9B%BE%E8%AE%BA%E4%B8%8E%E6%A0%91%E3%80%91XDUACM%E6%9A%91%E5%9F%B9%E6%B4%9B%E8%B0%B7%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/](https://www.alpha-yang.cn/2020/06/23/[图论与树]XDUACM暑培洛谷算法题解/">个人博客</a>)或<a href="https://zhuanlan.zhihu.com/p/150134695" target="_blank" rel="noopener">知乎专栏</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在图论中有一个非常常见的问题，就是最短路径的问题。常见的最短路径算法有三种：dijkstra，floyd和SPFA。本文将带你了解前两种最短路算法，他们分别适用于不同场景下的问题。&lt;/p&gt;
&lt;p&gt;以下笔记乃是参考西电ACM暑假培训张帆大佬的讲课以及&lt;a href=&quot;https://www.cnblogs.com/xzxl/p/7266404.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;优先队列博客&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="ACM算法" scheme="http://yoursite.com/categories/ACM%E7%AE%97%E6%B3%95/"/>
    
      <category term="西电培训笔记" scheme="http://yoursite.com/categories/ACM%E7%AE%97%E6%B3%95/%E8%A5%BF%E7%94%B5%E5%9F%B9%E8%AE%AD%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>【图论与树】XDUACM暑培洛谷算法题解</title>
    <link href="http://yoursite.com/2020/06/23/%E3%80%90%E5%9B%BE%E8%AE%BA%E4%B8%8E%E6%A0%91%E3%80%91XDUACM%E6%9A%91%E5%9F%B9%E6%B4%9B%E8%B0%B7%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/06/23/%E3%80%90%E5%9B%BE%E8%AE%BA%E4%B8%8E%E6%A0%91%E3%80%91XDUACM%E6%9A%91%E5%9F%B9%E6%B4%9B%E8%B0%B7%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/</id>
    <published>2020-06-23T00:14:11.000Z</published>
    <updated>2020-06-24T11:23:08.098Z</updated>
    
    <content type="html"><![CDATA[<p>该博客所有题目均是西电ACM暑假培训洛谷团队的题目，目前共16题，之前一直在写题，本博客持续更新。</p><p>感谢校队张帆大佬的讲课(ID：孤月)。</p><p>由于本人太菜，本文将持续更新</p><a id="more"></a><h4 id="P3367-【模板】并查集"><a href="#P3367-【模板】并查集" class="headerlink" title="P3367 【模板】并查集"></a>P3367 【模板】并查集</h4><p>题目地址：<a href="https://www.luogu.com.cn/problem/P3367" target="_blank" rel="noopener">P3367 【模板】并查集</a></p><p>这道题目就是一道练习并查集模板的题目，关于并查集的概念不懂的，可以看我之前的<a href="[https://www.alpha-yang.cn/2020/06/23/%E3%80%90%E5%9B%BE%E8%AE%BA%E3%80%91%E5%B9%B6%E6%9F%A5%E9%9B%86/](https://www.alpha-yang.cn/2020/06/23/[图论]并查集/">博客</a>)或者<a href="https://zhuanlan.zhihu.com/p/150133028" target="_blank" rel="noopener">知乎专栏文章</a>。这题目判断是否在同一个集合的核心代码就是<code>if (find(x)==find(y))</code>，所以就直接上代码吧。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10005</span></span><br><span class="line"><span class="keyword">int</span> n,m,z,x,y;</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[k]==k) <span class="keyword">return</span> k;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> f[k]=<span class="built_in">find</span>(f[k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i]=i;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;z&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="keyword">if</span> (z==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            f[<span class="built_in">find</span>(x)]=<span class="built_in">find</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(x)==<span class="built_in">find</span>(y))</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">'Y'</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">'N'</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于初始化的问题，我们首先假设所有的老大都是自己，即<code>f[i]=i</code>。之后再进行集合的合并等操作，就是道练习模板的题目。</p><h4 id="P1525-关押罪犯"><a href="#P1525-关押罪犯" class="headerlink" title="P1525 关押罪犯"></a>P1525 关押罪犯</h4><p>题目地址：<a href="https://www.luogu.com.cn/problem/P1525" target="_blank" rel="noopener">P1525 关押罪犯</a></p><p>这道题目是一道淳朴的并查集的题目，相比于并查集模板不同的是，加入对思维的考验，也就是说，我怎样分配才能使冲突事件的等级最小。</p><p>并查集不知道是啥的，可以看我之前的<a href="[https://www.alpha-yang.cn/2020/06/23/%E3%80%90%E5%9B%BE%E8%AE%BA%E3%80%91%E5%B9%B6%E6%9F%A5%E9%9B%86/](https://www.alpha-yang.cn/2020/06/23/[图论]并查集/">博客</a>)或者<a href="https://zhuanlan.zhihu.com/p/150133028" target="_blank" rel="noopener">知乎专栏文章</a>。</p><p><strong>思考</strong>：我们绝不能让冲突矛盾最大的两个人在一个监狱，好那就先把他们拿出来，放到两个不同的监狱去。然后矛盾次大的两人也不能在一个监狱，放到两个不同监狱去。这就出现了一个问题，假设现在有四名罪犯_abcd_，其中ab的冲突最大，cd的冲突次大，很显然ab和cd不能在同一个监狱，那我们的组合是ac和bd还是ad和bc呢？</p><p>这时需要我们引入一个另外的概念，就是敌人的敌人就是朋友，其实也不一定是朋友，但是冲突会更小一点。讲具体点就是，我们现在用数组<code>re</code>来存放所有人冲突最大的敌人，比如<code>re[i]</code>表示第i个罪犯冲突最大的敌人，按照上面abcd的例子，即<code>re[a]=b,re[b]=a,re[c]=d,re[d]=c</code>，说到这里如果你还没理解我的做法，那我就引入更多的罪犯，假设他们与abcd都有或大或小的冲突，接下来来了个e，他与a有冲突，且冲突值仅次于cd的冲突值，这时e肯定不能和a一个监狱了，所以我们让b和e一个监狱，这就是上面所说的，<strong>敌人的敌人就是“朋友”</strong>。按照冲突值由大到小的顺序，那直到什么时候为止呢？</p><p><code>if (find(x)==find(y))</code>,直到发现冲突值为某个数的两名罪犯x和y他们已经在一个集合中了，他们的冲突已经不能避免了，后面的罪犯已经不用再考虑了，因为后面的罪犯不管怎么排，冲突值都不会大过x和y的冲突值了，题目只要求最大值。</p><p>总结一下这其实是个贪心的思想，但是比贪心容易得多，我们把冲突值从大到小排序，让冲突值最大的两名罪犯分开，并互相标记为敌人，以此类推，后面如果有罪犯e发现它的敌人a已经有敌人b了，那就让e和b在一个监狱，不管b和e有没有冲突，直到发现有冲突的两名罪犯已经在一个监狱的时候，直接输出他们的冲突值即可。</p><p>如果找到最后两名罪犯都发现他们不在一个监狱，那就说明可以完全避免冲突，输出<code>0</code>。</p><p>以下是代码，个人认为我的代码还是非常易于理解，且对新手友善的（大家轻喷</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> f[maxn],re[maxn],n,m; <span class="comment">// 数组f存放并查集，数组re表示敌人</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">&#125;v[maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span> <span class="comment">// 定义结构体的sort排序，根据c进行降序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.c&gt;y.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> k)</span> <span class="comment">// 并查集，找老大的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[k]==k) <span class="keyword">return</span> k;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> f[k]=<span class="built_in">find</span>(f[k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> <span class="comment">// 对两数进行合并操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[<span class="built_in">find</span>(x)]=<span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> <span class="comment">// 判断两数是否在同一个集合中</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(x)==<span class="built_in">find</span>(y); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">cin</span>&gt;&gt;v[i].a&gt;&gt;v[i].b&gt;&gt;v[i].c;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) f[i]=i;</span><br><span class="line">    sort(v+<span class="number">1</span>,v+m,cmp); <span class="comment">// 按照c即冲突值从大到小排序</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (check(v[i].a,v[i].b)) <span class="comment">// 如果发现a和b已经在一个监狱了，说明冲突无法避免，直接输出c</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;v[i].c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            getchar();getchar();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 后面的罪犯不用考虑，只求最大的冲突</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (re[v[i].a]) merge(re[v[i].a],v[i].b);<span class="comment">//发现a已经有敌人了，所以我们合并敌人的敌人</span></span><br><span class="line">            <span class="keyword">else</span> re[v[i].a]=v[i].b; <span class="comment">// 标记a和敌人是b</span></span><br><span class="line">            <span class="keyword">if</span> (re[v[i].b]) merge(re[v[i].b],v[i].a);</span><br><span class="line">            <span class="keyword">else</span> re[v[i].b]=v[i].a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P4779-【模板】单源最短路径（标准版）"><a href="#P4779-【模板】单源最短路径（标准版）" class="headerlink" title="P4779 【模板】单源最短路径（标准版）"></a>P4779 【模板】单源最短路径（标准版）</h4><p>题目地址：<a href="https://www.luogu.com.cn/problem/P4779" target="_blank" rel="noopener">P4779 【模板】单源最短路径（标准版）</a></p><p>Dijkstra模板题，可以详见我之前的<a href="http://link.zhihu.com/?target=https%3A//www.alpha-yang.cn/2020/06/23/%E3%80%90%E5%9B%BE%E8%AE%BA%E3%80%91%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84Dijkstra%E4%B8%8EFloyd%E7%AE%97%E6%B3%95/%23more">博客</a>或<a href="https://zhuanlan.zhihu.com/p/150434472" target="_blank" rel="noopener">知乎专栏</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,cost;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num,dis;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;x)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.dis &lt; dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; e[maxm];</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn]; <span class="comment">// 布尔型vis数组</span></span><br><span class="line"><span class="keyword">int</span> n,m,s,cnt=<span class="number">0</span>;</span><br><span class="line">priority_queue &lt;node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> <span class="comment">// 存边</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[u].push_back((edge)&#123;v,w&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    q.push((node)&#123;s,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        node tmp=q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">int</span> x=tmp.num;</span><br><span class="line">        <span class="keyword">if</span> (vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[x]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (edge k:e[x]) <span class="comment">// 遍历边信息，请注意洛谷请选用c++11，否则编译错误</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[x] + k.cost &lt; dis[k.to])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[k.to]=dis[x]+k.cost;</span><br><span class="line">                <span class="keyword">if</span> (!vis[k.to]) q.push((node)&#123;k.to,dis[k.to]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) dis[i]=<span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        add_edge(u,v,w);</span><br><span class="line">    &#125;</span><br><span class="line">    dijkstra();</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cout</span>&lt;&lt;dis[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1608-路径统计"><a href="#P1608-路径统计" class="headerlink" title="P1608 路径统计"></a>P1608 路径统计</h4><p>题目地址：<a href="https://www.luogu.com.cn/problem/P1608" target="_blank" rel="noopener">P1608 路径统计</a></p><p>这题基本也是个Dijkstra的模板题，大方向都没有任何变化。我们首先先考虑一个比较简单的问题，就是题目中的重边该怎么去除，重边我们当然选择最短的那条边，其实也不复杂。我采取的方法是邻接矩阵的办法，再把邻接矩阵转为边信息，考虑到N最大值为2000，二维矩阵肯定不会炸。（忽略奇怪的缩进</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> p,q,c,tmp;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;p&gt;&gt;q&gt;&gt;c;</span><br><span class="line">        <span class="keyword">if</span> (cmp[i][j]==<span class="number">0</span> || c&lt;cmp[i][j]) cmp[i][j]=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span> (cmp[i][j]) e[i].push_back((edge)&#123;j,cmp[i][j]&#125;);</span><br></pre></td></tr></table></figure><p>这样就把重边给处理了，菜鸡的我也没想到其他方法了。。。</p><p>然后就是来处理本题的问题，最短路径非常简单，但是统计个数，还是需要思索一下的。我的办法是准备一个<code>ans</code>数组，<code>ans[i]</code>表示第i个点的最短路径的条数，好家伙！这样层层递推，就能推到第N个点了。</p><p>这样其实没啥问题，但是有可能统计第k个点，我统计了两条最短路径，突然来了一条更短的，这是我们的<code>ans[k]</code>从2又变回了1，好说！让k点的值等于最短路径上一个点的ans值就可以了。</p><p>所以核心代码如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dis[k.to]==dis[x]+k.w) ans[k.to]+=ans[x];</span><br><span class="line"><span class="keyword">if</span> (dis[k.to]&gt;dis[x]+k.w)</span><br><span class="line">&#123;</span><br><span class="line">    dis[k.to]=dis[x]+k.w;</span><br><span class="line">    ans[k.to]=ans[x];</span><br><span class="line">    q.push((node)&#123;dis[k.to],k.to&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是这样如果有相等的路径就相加，有小于的路径就让其ans值回去。如果最后的<code>dis[n]=0x7fffffff</code>，那说明根本没路径能到达它，无解。</p><p>最后附上ac代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=maxn*(maxn<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> dis,num;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;x)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.dis&lt;dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt;edge&gt; e[maxm];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">int</span> ans[maxn];</span><br><span class="line"><span class="keyword">int</span> cmp[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line">priority_queue &lt;node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    ans[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    q.push((node)&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        node tmp=q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">int</span> x=tmp.num;</span><br><span class="line">        <span class="keyword">if</span> (vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[x]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (edge k : e[x])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[k.to]==dis[x]+k.w) ans[k.to]+=ans[x];</span><br><span class="line">            <span class="keyword">if</span> (dis[k.to]&gt;dis[x]+k.w)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[k.to]=dis[x]+k.w;</span><br><span class="line">                ans[k.to]=ans[x];</span><br><span class="line">                q.push((node)&#123;dis[k.to],k.to&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) dis[i]=<span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> p,q,c,tmp;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;p&gt;&gt;q&gt;&gt;c;</span><br><span class="line">        <span class="keyword">if</span> (cmp[i][j]==<span class="number">0</span> || c&lt;cmp[i][j]) cmp[i][j]=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span> (cmp[i][j]) e[i].push_back((edge)&#123;j,cmp[i][j]&#125;);</span><br><span class="line">    dijkstra();</span><br><span class="line">    <span class="keyword">if</span> (dis[n]!=<span class="number">0x7fffffff</span>) <span class="built_in">cout</span>&lt;&lt;dis[n]&lt;&lt;<span class="string">" "</span>&lt;&lt;ans[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"No answer"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1119-灾后重建"><a href="#P1119-灾后重建" class="headerlink" title="P1119 灾后重建"></a>P1119 灾后重建</h4><p>题目地址：<a href="https://www.luogu.com.cn/problem/P1119" target="_blank" rel="noopener">P1119 灾后重建</a></p><p>很好的一道Floyd算法的练习题，首先Floyd算法的核心是不变的。其余思路真的很简单，非常淳朴的图，我们使用邻接矩阵来存图。邻接矩阵剩下的地方我们标记为一个很大的数，例如<code>1e9</code>这种，保证两个数相加不会爆int上限即可。由于是无向图，记得反存，另外这个题目村庄是从0开始的，我一般喜欢设为1开始，但是这个题目别忘了要改回来。</p><p>关于查询的部分，由于题目明确保证查询时间依次增大，所以我们随着天数更新Floyd图就行，看看在询问的天数内能更新多少村庄修复，以此类推，直到最后输出结果。</p><p>最后附上ac代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 1e9</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">205</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,q,x,y,qt;</span><br><span class="line"><span class="keyword">int</span> t[maxn],arr[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            arr[i][j]=arr[j][i]=<span class="built_in">min</span>(arr[i][j],arr[i][k]+arr[k][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">int</span> i,j,w,k;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">cin</span>&gt;&gt;t[i];</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            <span class="keyword">if</span> (i!=j) arr[i][j]=inf;</span><br><span class="line">    <span class="keyword">for</span> (k=<span class="number">0</span>;k&lt;m;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;i&gt;&gt;j&gt;&gt;w;</span><br><span class="line">        arr[i][j]=arr[j][i]=w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;q;<span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;qt;</span><br><span class="line">        <span class="keyword">while</span> (t[flag]&lt;=qt &amp;&amp; flag&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            floyd(flag);</span><br><span class="line">            flag++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t[x]&gt;qt || t[y]&gt;qt) <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[x][y]==inf) <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;arr[x][y]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;该博客所有题目均是西电ACM暑假培训洛谷团队的题目，目前共16题，之前一直在写题，本博客持续更新。&lt;/p&gt;
&lt;p&gt;感谢校队张帆大佬的讲课(ID：孤月)。&lt;/p&gt;
&lt;p&gt;由于本人太菜，本文将持续更新&lt;/p&gt;
    
    </summary>
    
    
      <category term="ACM算法" scheme="http://yoursite.com/categories/ACM%E7%AE%97%E6%B3%95/"/>
    
      <category term="洛谷试炼场" scheme="http://yoursite.com/categories/ACM%E7%AE%97%E6%B3%95/%E6%B4%9B%E8%B0%B7%E8%AF%95%E7%82%BC%E5%9C%BA/"/>
    
    
      <category term="图论与树" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA%E4%B8%8E%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【图论与树】并查集</title>
    <link href="http://yoursite.com/2020/06/23/%E3%80%90%E5%9B%BE%E8%AE%BA%E4%B8%8E%E6%A0%91%E3%80%91%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://yoursite.com/2020/06/23/%E3%80%90%E5%9B%BE%E8%AE%BA%E4%B8%8E%E6%A0%91%E3%80%91%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
    <published>2020-06-22T23:06:12.000Z</published>
    <updated>2020-06-24T08:14:46.988Z</updated>
    
    <content type="html"><![CDATA[<p>最近一段时间一直忙着刷题，没时间来写博客了。今天，我来写一个基础的问题，就是图论中常见的并查集的问题。首先明确并查集是什么？<a id="more"></a></p><p>_并查集，在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。这一类问题近几年来反复出现在信息学的国际国内赛题中，其特点是看似并不复杂，但数据量极大，若用正常的数据结构来描述的话，往往在空间上过大，计算机无法承受;即使在空间上勉强通过，运行的时间复杂度也极高，根本就不可能在比赛规定的运行时间(1~3秒)内计算出试题需要的结果，只能用并查集来描述。_(摘自百度)</p><p>并查集和路径压缩应该怎么形象地理解呢，这里我们可以做一下这样的假设。</p><p>我们现在假定一个数组f，其中<code>f[i]</code>表示第i个人的老大是谁（当然网上还有其他解释，爸爸什么的，反正先这样理解）</p><p>现在我们假设有5个人，给他们分别编号1~5，好了现在我们要进行一些操作，也就是集合合并。</p><p>假设现在让2做1的老大，于是我们令<code>f[1]=2</code>，就是这个意思。</p><p>然后再让1做3的老大，于是有<code>f[3]=1</code>，好了现在按照道理而言123三个人应该在一个集合中，但是其实3不知道2是1的老大，也就是3不知道2是他老大的老大。但是我们有办法让他知道。</p><p>定义一个<code>find</code>函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[k]==k) <span class="keyword">return</span> k;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> f[k]=<span class="built_in">find</span>(f[k]);</span><br><span class="line">    <span class="comment">// return f[k]=find(f[k]); 是简写，等价于f[k]=find[f[k]];return f[k];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们尝试运行下<code>f[3]=find(1)</code>，不难想象，此时，我们遍历了所有3的老大们(包括老大的老大)，顺便在遍历的过程中，让他们有了相同的老大，这时他们就到一个集合中去了，简直太巧妙了。</p><p>于是，我们要判断x和y在一个集合，他们只需要满足<code>find(x)==find(y)</code>的条件即可。</p><p>下面我们以两道洛谷的题目为例。</p><h4 id="P3367-【模板】并查集"><a href="#P3367-【模板】并查集" class="headerlink" title="P3367 【模板】并查集"></a>P3367 【模板】并查集</h4><p>第一道模板题：<a href="https://www.luogu.com.cn/problem/P3367" target="_blank" rel="noopener">P3367 【模板】并查集</a></p><p>这道题目就是一道练习并查集模板的题目，关于并查集的概念上面也描述了，这题目判断是否在同一个集合的核心代码就是<code>if (find(x)==find(y))</code>，所以就直接上代码吧。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10005</span></span><br><span class="line"><span class="keyword">int</span> n,m,z,x,y;</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[k]==k) <span class="keyword">return</span> k;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> f[k]=<span class="built_in">find</span>(f[k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i]=i;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;z&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="keyword">if</span> (z==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            f[<span class="built_in">find</span>(x)]=<span class="built_in">find</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(x)==<span class="built_in">find</span>(y))</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">'Y'</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">'N'</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于初始化的问题，我们首先假设所有的老大都是自己，即<code>f[i]=i</code>。之后再进行集合的合并等操作，就是道练习模板的题目。</p><h4 id="P1525-关押罪犯"><a href="#P1525-关押罪犯" class="headerlink" title="P1525 关押罪犯"></a>P1525 关押罪犯</h4><p>第二道并查集题目：<a href="https://www.luogu.com.cn/problem/P1525" target="_blank" rel="noopener">P1525 关押罪犯</a></p><p>这道题目也是一道淳朴的并查集的题目，不同的是，加入对思维的考验，也就是说，我怎样分配才能使冲突事件的等级最小。</p><p><strong>思考</strong>：我们绝不能让冲突矛盾最大的两个人在一个监狱，好那就先把他们拿出来，放到两个不同的监狱去。然后矛盾次大的两人也不能在一个监狱，放到两个不同监狱去。这就出现了一个问题，假设现在有四名罪犯_abcd_，其中ab的冲突最大，cd的冲突次大，很显然ab和cd不能在同一个监狱，那我们的组合是ac和bd还是ad和bc呢？</p><p>这时需要我们引入一个另外的概念，就是敌人的敌人就是朋友，其实也不一定是朋友，但是冲突会更小一点。讲具体点就是，我们现在用数组<code>re</code>来存放所有人冲突最大的敌人，比如<code>re[i]</code>表示第i个罪犯冲突最大的敌人，按照上面abcd的例子，即<code>re[a]=b,re[b]=a,re[c]=d,re[d]=c</code>，说到这里如果你还没理解我的做法，那我就引入更多的罪犯，假设他们与abcd都有或大或小的冲突，接下来来了个e，他与a有冲突，且冲突值仅次于cd的冲突值，这时e肯定不能和a一个监狱了，所以我们让b和e一个监狱，这就是上面所说的，<strong>敌人的敌人就是“朋友”</strong>。按照冲突值由大到小的顺序，那直到什么时候为止呢？</p><p><code>if (find(x)==find(y))</code>,直到发现冲突值为某个数的两名罪犯x和y他们已经在一个集合中了，他们的冲突已经不能避免了，后面的罪犯已经不用再考虑了，因为后面的罪犯不管怎么排，冲突值都不会大过x和y的冲突值了，题目只要求最大值。</p><p>总结一下这其实是个贪心的思想，但是比贪心容易得多，我们把冲突值从大到小排序，让冲突值最大的两名罪犯分开，并互相标记为敌人，以此类推，后面如果有罪犯e发现它的敌人a已经有敌人b了，那就让e和b在一个监狱，不管b和e有没有冲突，直到发现有冲突的两名罪犯已经在一个监狱的时候，直接输出他们的冲突值即可。</p><p>如果找到最后两名罪犯都发现他们不在一个监狱，那就说明可以完全避免冲突，输出<code>0</code>。</p><p>以下是代码，个人认为我的代码还是非常易于理解，且对新手友善的（大家轻喷</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> f[maxn],re[maxn],n,m; <span class="comment">// 数组f存放并查集，数组re表示敌人</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">&#125;v[maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span> <span class="comment">// 定义结构体的sort排序，根据c进行降序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.c&gt;y.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> k)</span> <span class="comment">// 并查集，找老大的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[k]==k) <span class="keyword">return</span> k;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> f[k]=<span class="built_in">find</span>(f[k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> <span class="comment">// 对两数进行合并操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[<span class="built_in">find</span>(x)]=<span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> <span class="comment">// 判断两数是否在同一个集合中</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(x)==<span class="built_in">find</span>(y); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">cin</span>&gt;&gt;v[i].a&gt;&gt;v[i].b&gt;&gt;v[i].c;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) f[i]=i;</span><br><span class="line">    sort(v+<span class="number">1</span>,v+m,cmp); <span class="comment">// 按照c即冲突值从大到小排序</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (check(v[i].a,v[i].b)) <span class="comment">// 如果发现a和b已经在一个监狱了，说明冲突无法避免，直接输出c</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;v[i].c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            getchar();getchar();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 后面的罪犯不用考虑，只求最大的冲突</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (re[v[i].a]) merge(re[v[i].a],v[i].b);<span class="comment">//发现a已经有敌人了，所以我们合并敌人的敌人</span></span><br><span class="line">            <span class="keyword">else</span> re[v[i].a]=v[i].b; <span class="comment">// 标记a和敌人是b</span></span><br><span class="line">            <span class="keyword">if</span> (re[v[i].b]) merge(re[v[i].b],v[i].a);</span><br><span class="line">            <span class="keyword">else</span> re[v[i].b]=v[i].a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一段时间一直忙着刷题，没时间来写博客了。今天，我来写一个基础的问题，就是图论中常见的并查集的问题。首先明确并查集是什么？
    
    </summary>
    
    
      <category term="ACM算法" scheme="http://yoursite.com/categories/ACM%E7%AE%97%E6%B3%95/"/>
    
      <category term="西电培训笔记" scheme="http://yoursite.com/categories/ACM%E7%AE%97%E6%B3%95/%E8%A5%BF%E7%94%B5%E5%9F%B9%E8%AE%AD%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>第0次训练洛谷试炼场题解</title>
    <link href="http://yoursite.com/2020/06/16/%E7%AC%AC0%E6%AC%A1%E8%AE%AD%E7%BB%83%E6%B4%9B%E8%B0%B7%E8%AF%95%E7%82%BC%E5%9C%BA%E9%A2%98%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/06/16/%E7%AC%AC0%E6%AC%A1%E8%AE%AD%E7%BB%83%E6%B4%9B%E8%B0%B7%E8%AF%95%E7%82%BC%E5%9C%BA%E9%A2%98%E8%A7%A3/</id>
    <published>2020-06-16T15:58:06.000Z</published>
    <updated>2020-06-16T08:23:13.391Z</updated>
    
    <content type="html"><![CDATA[<p>第0次训练作业为自由训练，题目都比较简单，大概30min能搞定。布置了四道题目，这里总结归纳，写了一下题解。</p><blockquote><p>P1449 后缀表达式 </p><p>P3613【深基15.例2】寄包柜 </p><p>P1177【模板】快速排序 </p><p>P3370 【模板】字符串哈希 </p></blockquote><a id="more"></a><h4 id="P1449-后缀表达式"><a href="#P1449-后缀表达式" class="headerlink" title="P1449 后缀表达式"></a>P1449 后缀表达式</h4><p>题目地址：<a href="https://www.luogu.com.cn/problem/P1449" target="_blank" rel="noopener">P1449 后缀表达式</a></p><p>这个题目刚开始纠结于负数和减法的关系，不过后来经过提醒和验证，发现根本不用考虑这个影响。那这个题目就非常简单了，比严奶奶书上的例题更加容易。</p><p>申请一个栈，判断下每次进来的什么东西，然后依次弄出来计算即可。</p><p>直接上代码，没什么好说的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> num;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;num;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num[i]!=<span class="string">'@'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (num[i]!=<span class="string">'+'</span> &amp;&amp; num[i]!=<span class="string">'-'</span> &amp;&amp; num[i]!=<span class="string">'*'</span> &amp;&amp; num[i]!=<span class="string">'/'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (num[i]!=<span class="string">'.'</span>) a=a*<span class="number">10</span>+num[i]-<span class="string">'0'</span>,i++;</span><br><span class="line">            stk.push(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> b;</span><br><span class="line">            b=stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            <span class="keyword">switch</span> (num[i])</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                b=stk.top()+b;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                b=stk.top()-b;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                b=stk.top()*b;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                b=stk.top()/b;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.pop();</span><br><span class="line">            stk.push(b);</span><br><span class="line">        &#125;      </span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;stk.top()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P3613【深基15-例2】寄包柜"><a href="#P3613【深基15-例2】寄包柜" class="headerlink" title="P3613【深基15.例2】寄包柜"></a>P3613【深基15.例2】寄包柜</h4><p>题目地址：<a href="https://www.luogu.com.cn/problem/P3613" target="_blank" rel="noopener">P3613【深基15.例2】寄包柜</a></p><p>这个题目就是考查vector不定长数组的使用方法，因为直接开二维数组内存会炸，然而也没必要开那么多。不定长数组会简单的多。也没什么思路可言，就是直接上代码就行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">guizi</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; num,w;</span><br><span class="line">&#125;g[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,q;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x,i,j,k,l;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span> (x==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;i&gt;&gt;j&gt;&gt;k;</span><br><span class="line">            g[i].s++;</span><br><span class="line">            g[i].num.push_back(j);</span><br><span class="line">            g[i].w.push_back(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;i&gt;&gt;j; </span><br><span class="line">            <span class="keyword">for</span> (l=g[i].s<span class="number">-1</span>;l&gt;=<span class="number">0</span>;l--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[i].num[l]==j)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;g[i].w[l]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1177【模板】快速排序"><a href="#P1177【模板】快速排序" class="headerlink" title="P1177【模板】快速排序"></a>P1177【模板】快速排序</h4><p>题目地址：<a href="https://www.luogu.com.cn/problem/P1177" target="_blank" rel="noopener">P1177【模板】快速排序 </a></p><p>这个题目校队是想让我们简单熟悉一下sort的使用，虽然题目不让我们用，但我们用了也是一遍过。当然在以后的机试中，肯定直接sort(手动狗头)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,a[maxn],i;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    sort(a,a+n);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++) <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P3370-【模板】字符串哈希"><a href="#P3370-【模板】字符串哈希" class="headerlink" title="P3370 【模板】字符串哈希"></a>P3370 【模板】字符串哈希</h4><p>题目地址：<a href="https://www.luogu.com.cn/problem/P3370" target="_blank" rel="noopener">P3370 【模板】字符串哈希</a></p><p>这个题目依旧标明不希望我们用map函数，但是校队只是希望我们用map直接水过去，好吧，那先用map来做一遍。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">bool</span>&gt;ha;</span><br><span class="line">    <span class="keyword">int</span> n,i,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        ha[s]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">bool</span>&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span> (iter=ha.<span class="built_in">begin</span>();iter!=ha.<span class="built_in">end</span>();iter++) ans++;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到哈希我比较感兴趣(应该是和密码学相关的？)，所以我又用了字符串哈希做了一遍。如果你明白哈希的话，其实很简单。我这里是用单哈希做的，题解里面有更好的哈希方法，但貌似没人证明。</p><p>此题单哈希来做可以直接过，主要思想设置base和mod，然而我没有设置mod也过了。</p><script type="math/tex; mode=display">ans = (ans *base +value) \% mod;</script><p>主要就是这样的思想，value是每位上的数，这里我base取的是233。这样每个字符串都有自己对应的哈希值了。</p><p>然后上代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> base 233</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,i,j,ans=<span class="number">1</span>;</span><br><span class="line">    ll ha[maxn];</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        <span class="keyword">int</span> l=s.<span class="built_in">size</span>();</span><br><span class="line">        ll sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;l;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum=sum*base+s[j];</span><br><span class="line">        &#125;</span><br><span class="line">        ha[i]=sum;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ha,ha+n);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">        <span class="keyword">if</span> (ha[i]!=ha[i+<span class="number">1</span>]) ans++;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第0次训练作业为自由训练，题目都比较简单，大概30min能搞定。布置了四道题目，这里总结归纳，写了一下题解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;P1449 后缀表达式 &lt;/p&gt;
&lt;p&gt;P3613【深基15.例2】寄包柜 &lt;/p&gt;
&lt;p&gt;P1177【模板】快速排序 &lt;/p&gt;
&lt;p&gt;P3370 【模板】字符串哈希 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="ACM算法" scheme="http://yoursite.com/categories/ACM%E7%AE%97%E6%B3%95/"/>
    
      <category term="洛谷试炼场" scheme="http://yoursite.com/categories/ACM%E7%AE%97%E6%B3%95/%E6%B4%9B%E8%B0%B7%E8%AF%95%E7%82%BC%E5%9C%BA/"/>
    
    
      <category term="洛谷" scheme="http://yoursite.com/tags/%E6%B4%9B%E8%B0%B7/"/>
    
  </entry>
  
  <entry>
    <title>常用STL库总结</title>
    <link href="http://yoursite.com/2020/06/16/%E5%B8%B8%E7%94%A8STL%E5%BA%93%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/06/16/%E5%B8%B8%E7%94%A8STL%E5%BA%93%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-16T14:41:03.000Z</published>
    <updated>2020-06-16T07:52:50.437Z</updated>
    
    <content type="html"><![CDATA[<p>该博客内容是针对西安电子科技大学2020年ACM暑假培训，6月15日校队周益全大佬讲课内容的总结与整理。</p><h3 id="一、STL库的概念"><a href="#一、STL库的概念" class="headerlink" title="一、STL库的概念"></a>一、STL库的概念</h3><p>STL（Standard Template Library），即标准模板库，是一个具有工业强度的，高效的C++程序库。它被容纳于C++标准程序库（C++ Standard Library）中，是ANSI/ISO C++标准中最新的也是极具革命性的一部分。该库包含了诸多在计算机科学领域里所常用的基本数据结构和基本算法。为广大C++程序员们提供了一个可扩展的应用框架，高度体现了软件的可复用性。<a id="more"></a></p><h3 id="二、vector向量-不定长数组"><a href="#二、vector向量-不定长数组" class="headerlink" title="二、vector向量(不定长数组)"></a>二、vector向量(不定长数组)</h3><h4 id="1-头文件"><a href="#1-头文件" class="headerlink" title="1. 头文件"></a>1. 头文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt; // 头文件</span></span></span><br></pre></td></tr></table></figure><h4 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vec; <span class="comment">// 申请一个vector容器，这里int也可以是其他数据类型</span></span><br><span class="line">vec.push_back(num); <span class="comment">// 向容器最后插入一个数num</span></span><br><span class="line">vec.<span class="built_in">size</span>(); <span class="comment">// 查询目前容器的大小，常用于遍历</span></span><br></pre></td></tr></table></figure><h4 id="3-二维数组"><a href="#3-二维数组" class="headerlink" title="3. 二维数组"></a>3. 二维数组</h4><p>我们还可以一次性申请多个vector，这样就可以起到二维数组的作用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vec[<span class="number">100</span>]; <span class="comment">// 申请100个不定长容器</span></span><br></pre></td></tr></table></figure><h3 id="三、map关联式容器"><a href="#三、map关联式容器" class="headerlink" title="三、map关联式容器"></a>三、map关联式容器</h3><p>以前内容还有部分整理自其他博客 <a href="https://www.cnblogs.com/fnlingnzb-learner/p/5833051.html" target="_blank" rel="noopener">C++中的STL中map用法详解</a></p><h4 id="1-头文件-1"><a href="#1-头文件-1" class="headerlink" title="1. 头文件"></a>1. 头文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt; // 头文件</span></span></span><br></pre></td></tr></table></figure><h4 id="2-常用命令-1"><a href="#2-常用命令-1" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h4><p>这里举一个作业题目的例子，洛谷Hash模板题 <a href="https://www.luogu.com.cn/problem/P3370" target="_blank" rel="noopener">P3370 【模板】字符串哈希</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">bool</span>&gt;mp; <span class="comment">// 申请一个map，这个意思是申请一个名叫mp的map它可以将一个string类型的映射成bool类型。当然名字和类型都是可以换的</span></span><br><span class="line">mp[<span class="string">"abc"</span>] = <span class="number">1</span>; <span class="comment">// 之后输出mp["abc"]就会是1要是没有上一步输出就会是0</span></span><br><span class="line">mp.<span class="built_in">size</span>(); <span class="comment">// 容器的大小</span></span><br></pre></td></tr></table></figure><p>根据周大佬上课所说的，map的库轮子是用红黑树写的，所以效率会很高。</p><h4 id="3-容器遍历"><a href="#3-容器遍历" class="headerlink" title="3. 容器遍历"></a>3. 容器遍历</h4><p>这里上课没有提到，在这里补充一下关于map容器遍历问题，博客上有两种遍历方式，我这里说的是应用前向迭代器的方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator iter;</span><br><span class="line"><span class="keyword">for</span>(iter = mp.<span class="built_in">begin</span>();iter != mp.<span class="built_in">end</span>();iter++)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">' '</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h4 id="4-pair的用法"><a href="#4-pair的用法" class="headerlink" title="4. pair的用法"></a>4. pair的用法</h4><p>将两个数放在一起，类似数据结构。比如直角坐标系(x,y)对应一个数value。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt;mapxy; <span class="comment">// 申请容器</span></span><br><span class="line">mapxy[make_pair(x,y)] = value; <span class="comment">// 赋值</span></span><br></pre></td></tr></table></figure><h3 id="四、set集合"><a href="#四、set集合" class="headerlink" title="四、set集合"></a>四、set集合</h3><p>这个比较容易，就简单写写了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt; // 头文件</span></span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;st; <span class="comment">// 申请一个集合st</span></span><br><span class="line">st.<span class="built_in">begin</span>(); <span class="comment">// 返回set容器的第一个元素</span></span><br><span class="line">st.<span class="built_in">end</span>(); <span class="comment">// 返回set容器的最后一个元素</span></span><br><span class="line">st.<span class="built_in">clear</span>(); <span class="comment">// 删除set容器中的所有的元素</span></span><br><span class="line">st.empty(); <span class="comment">// 判断set容器是否为空</span></span><br><span class="line">st.max_size(); <span class="comment">// 返回set容器可能包含的元素最大个数</span></span><br><span class="line">st.<span class="built_in">size</span>(); <span class="comment">// 返回当前set容器中的元素个数</span></span><br><span class="line">st.insert(); <span class="comment">// 在集合中插入元素</span></span><br><span class="line">st.erase(); <span class="comment">// 删除集合中的某个元素</span></span><br></pre></td></tr></table></figure><h3 id="五、algorithm算法库"><a href="#五、algorithm算法库" class="headerlink" title="五、algorithm算法库"></a>五、algorithm算法库</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; // 头文件</span></span></span><br></pre></td></tr></table></figure><h4 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1. 二分查找"></a>1. 二分查找</h4><ul><li>lower_bound(起始地址，结束地址，要查找的数值)</li></ul><p>返回大于或等于val的第一个元素位置。如果所有元素都小于val，则返回last的位置。</p><p>注意：如果所有元素都小于val，则返回last的位置，且last的位置是越界的。</p><ul><li>upper_bound(起始地址，结束地址，要查找的数值)</li></ul><p>功能：函数upper_bound()返回的在前闭后开区间查找的关键字的上界，返回大于val的第一个元素位置。</p><p><strong>记得最后减去地址</strong></p><h4 id="2-sort排序"><a href="#2-sort排序" class="headerlink" title="2. sort排序"></a>2. sort排序</h4><p>太常用了。对有n个元素的数组a进行排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(a,a+n); <span class="comment">// 升序排序，起始地址和结束地址</span></span><br></pre></td></tr></table></figure><p>如果想要降序排序，简单写一个比较函数就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i &gt; j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(a,a+n,cmp); <span class="comment">// 降序排序</span></span><br></pre></td></tr></table></figure><p>如果想对结构体的某个value进行排序也是一样的，把cmp函数改掉就行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key,value;</span><br><span class="line">&#125;a[<span class="number">100</span>];</span><br><span class="line"><span class="comment">// 想对a直接进行升序排序是不可以的，因为对象不清楚</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node i,node j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i.value &lt; j.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(a,a+n,cmp); <span class="comment">// 这样就行了</span></span><br></pre></td></tr></table></figure><p>还有另一种写法，就是对大于号重载一下，重新定义其意义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key,value;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node&amp;x)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> value &lt; x.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">sort(a,a+n); <span class="comment">// 这样也行</span></span><br></pre></td></tr></table></figure><h3 id="六、数据结构"><a href="#六、数据结构" class="headerlink" title="六、数据结构"></a>六、数据结构</h3><h4 id="1-队列"><a href="#1-队列" class="headerlink" title="1. 队列"></a>1. 队列</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt; // 头文件</span></span></span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q; <span class="comment">// 申请队列</span></span><br><span class="line">q.push(value); <span class="comment">// 入队</span></span><br><span class="line">q.pop(); <span class="comment">// 出队</span></span><br><span class="line">q.top(); <span class="comment">// 返回队首元素</span></span><br><span class="line">q.empty(); <span class="comment">// 判断是否为空</span></span><br><span class="line">q.<span class="built_in">size</span>(); <span class="comment">// 返回队列个数</span></span><br></pre></td></tr></table></figure><h4 id="2-栈"><a href="#2-栈" class="headerlink" title="2. 栈"></a>2. 栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt; // 头文件</span></span></span><br><span class="line"><span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; stk; <span class="comment">// 申请栈</span></span><br><span class="line">stk.push(value); <span class="comment">// 入栈</span></span><br><span class="line">stk.pop(); <span class="comment">// 出栈</span></span><br><span class="line">stk.top(); <span class="comment">// 返回栈顶元素</span></span><br><span class="line">stk.empty(); <span class="comment">// 判断是否为空栈</span></span><br></pre></td></tr></table></figure><p>其余数据结构之后还会细讲。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;该博客内容是针对西安电子科技大学2020年ACM暑假培训，6月15日校队周益全大佬讲课内容的总结与整理。&lt;/p&gt;
&lt;h3 id=&quot;一、STL库的概念&quot;&gt;&lt;a href=&quot;#一、STL库的概念&quot; class=&quot;headerlink&quot; title=&quot;一、STL库的概念&quot;&gt;&lt;/a&gt;一、STL库的概念&lt;/h3&gt;&lt;p&gt;STL（Standard Template Library），即标准模板库，是一个具有工业强度的，高效的C++程序库。它被容纳于C++标准程序库（C++ Standard Library）中，是ANSI/ISO C++标准中最新的也是极具革命性的一部分。该库包含了诸多在计算机科学领域里所常用的基本数据结构和基本算法。为广大C++程序员们提供了一个可扩展的应用框架，高度体现了软件的可复用性。
    
    </summary>
    
    
      <category term="ACM算法" scheme="http://yoursite.com/categories/ACM%E7%AE%97%E6%B3%95/"/>
    
      <category term="西电培训笔记" scheme="http://yoursite.com/categories/ACM%E7%AE%97%E6%B3%95/%E8%A5%BF%E7%94%B5%E5%9F%B9%E8%AE%AD%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>数模竞赛备赛常用模型与算法</title>
    <link href="http://yoursite.com/2020/06/13/%E6%95%B0%E6%A8%A1%E7%AB%9E%E8%B5%9B%E5%A4%87%E8%B5%9B%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/06/13/%E6%95%B0%E6%A8%A1%E7%AB%9E%E8%B5%9B%E5%A4%87%E8%B5%9B%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%AE%97%E6%B3%95/</id>
    <published>2020-06-12T16:46:23.000Z</published>
    <updated>2020-06-16T07:52:40.673Z</updated>
    
    <content type="html"><![CDATA[<p>所有的模型与算法是不可能学完的，大家根据自己的实际情况来学习，不必过于焦虑。<a id="more"></a></p><h4 id="1-数学模型的分类"><a href="#1-数学模型的分类" class="headerlink" title="1. 数学模型的分类"></a>1. 数学模型的分类</h4><ul><li><p><strong>按数学方法分类：</strong> 几何模型、图论模型、微分方程模型、概率模型、最优控制模型、规划论模型、马氏链模型等。</p></li><li><p><strong>按特征分类：</strong> 静态模型和动态模型，确定性模型和随机模型，<strong>离散模型和连续性模型</strong>，线性模型和非线性模型等。</p></li><li><p><strong>按应用领域分类：</strong> 人口模型、交通模型、经济模型、生态模型、资源模型、环境模型等。</p></li><li><p><strong>按建模目的分类：</strong> 预测模型、优化模型、决策模型、控制模型等。</p></li><li><p><strong>按比赛命题方向分类：</strong> 国赛一般是离散模型和连续模型各一个，2019增加了一个人文社科背景题目，</p><p>美赛六个题目（离散、连续、大数据、运筹学/复杂网络、环境科学、政策）。</p></li></ul><h4 id="2-备赛：常用的模型与算法"><a href="#2-备赛：常用的模型与算法" class="headerlink" title="2. 备赛：常用的模型与算法"></a>2. 备赛：常用的模型与算法</h4><ul><li><strong>评价模型：</strong> 层次分析、Topsis(优劣解距离法)、数据包络分析(DEA)、模糊综合评价、秩和比综合评价、主成分分析、灰色关联分析法</li><li><strong>预测分析模型：</strong> 微分方程模型、差分方程模型、回归分析、时间序列、马尔可夫、神经网络、插值拟合、混沌序列预测、小波分析预测、灰色预测模型</li><li><strong>优化模型：</strong> 数学规划模型（多目标、单目标、0-1整数规划等）、复杂网络优化、排队论与计算机仿真、图论、博弈论</li><li><strong>数理统计模型：</strong> 多元分析（主成分分析、聚类分析、因子分析、判别分析、典型相关性分析等）、相关回归分析、假设检验、方差检验、贝叶斯统计</li><li><strong>分类与判别算法：</strong> 距离聚类(系统聚类)、关联性聚类，层次聚类、贝叶斯分类与判别、SVM支持向量机、决策树、极限学习机</li><li><strong>重要的算法：</strong> 蒙特卡罗算法、数据处理算法(数据拟合、参数估计、插值等)、规划算法(线性规划、整数规划、多元规划、二次规划等)、图论算法、计算机经典算法(动态规划、回溯搜索、分治算法、分支定界等)、最优化理论的三大非经典算法(模拟退火法、神经网络、遗传算法)、网格算法和穷举法、元胞自动机</li></ul><h4 id="3-备赛：针对性训练"><a href="#3-备赛：针对性训练" class="headerlink" title="3. 备赛：针对性训练"></a>3. 备赛：针对性训练</h4><ul><li>无论是国赛还是美赛，比赛前要确定大概的选题范围。比如这次美赛，我们赛前训练了2道D题，1道A题，1道C题，当然我们学校最擅长的也是D题。所以这次美赛前我们便确定了选题。</li><li>选定题目后，阅读往年优秀论文，可以是这个题目的也可以不是。请尽可能多地阅读，并且总结分析以及比较，人家能得大奖一定有他的原因，每阅读一篇优秀论文就把人家优秀的地方学过来，不断总结积累。</li><li>经过多次真题训练，比赛前整理一套属于自己队伍的Latex或者Word模板，比赛时候方便使用。</li><li>熟练使用各种查找文献，下载文献的办法，知网、谷歌学术等等。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;所有的模型与算法是不可能学完的，大家根据自己的实际情况来学习，不必过于焦虑。
    
    </summary>
    
    
      <category term="数学建模" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="入门指导" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%85%A5%E9%97%A8%E6%8C%87%E5%AF%BC/"/>
    
    
      <category term="模型算法" scheme="http://yoursite.com/tags/%E6%A8%A1%E5%9E%8B%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>西电数模竞赛面试培训参赛经验汇总</title>
    <link href="http://yoursite.com/2020/06/11/%E8%A5%BF%E7%94%B5%E6%95%B0%E6%A8%A1%E7%AB%9E%E8%B5%9B%E9%9D%A2%E8%AF%95%E5%9F%B9%E8%AE%AD%E5%8F%82%E8%B5%9B%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2020/06/11/%E8%A5%BF%E7%94%B5%E6%95%B0%E6%A8%A1%E7%AB%9E%E8%B5%9B%E9%9D%A2%E8%AF%95%E5%9F%B9%E8%AE%AD%E5%8F%82%E8%B5%9B%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/</id>
    <published>2020-06-10T21:09:10.000Z</published>
    <updated>2020-06-10T14:38:01.736Z</updated>
    
    <content type="html"><![CDATA[<p>今天西电数学建模竞赛总教练刚在群里通知，数学建模国赛报名及选拔工作即将开始。</p><p>我想趁这个机会来分享下数模竞赛的从面试到培训，再到选导师，以及最后参赛的整个流程的经验。</p><p>在这个过程中，如果有哪儿些地方没说清楚或者你有自己的见解，也欢迎各位西电er私信我来对这个文章予以补充，用来给更多的学弟学妹或者第一次参与整个数模竞赛的流程的同学一些可供参考的建议。</p><p>学弟学妹们关于培训有什么问题或者担忧的地方，也欢迎私信我~</p><a id="more"></a><h4 id="一、国赛校队选拔"><a href="#一、国赛校队选拔" class="headerlink" title="一、国赛校队选拔"></a>一、国赛校队选拔</h4><p>首先，大家在五一期间刚刚参加完了校赛，校赛的主要参加队员是大一和大二的同学，大三同学很少参加的原因是，国赛在9月份的中秋节举办，成绩要到11月份才能出来，而那时候的大三也就是大四的学长学姐们早就要么完成了保研要么就是考研的最后冲刺阶段，所以校赛的主力基本是大一和大二的同学们，这些同学参与9月国赛的时候就是大二和大三了。而7月到8月的国赛培训一般是按照校赛的成绩来选拔的，选拔的标准一般而言是校一等奖加上排名靠前的校二等奖(对于大一的要求会相对宽松一点)，这些同学会被选拔出来作为校赛的培训队员。</p><p>当然不是说，没有过面试的同学就没有参加国赛的机会了，每年暑假的国赛培训都可以让同学们旁听的。不得不说，总教练心还是很软的，一般国赛培训好好参加，作业认真完成，韩老师都会同意进入校队参加比赛的。去年的校队后来旁听队伍加了十几支的队伍，再加上学校越来越重视数模竞赛(这次美赛就可以看出)，数模校队名额会越来越多，鼓励同学们不要放弃，跟着校队培训来，还是有很大的参赛的可能的。</p><h4 id="二、面试建议"><a href="#二、面试建议" class="headerlink" title="二、面试建议"></a>二、面试建议</h4><p>其次就是关于面试的事情，大家不必有太多的心理负担，一般而言大一和大二是分开面试的，主要就是问问校赛的论文以及对着简历问一些简单的问题，简历上面写一些自己擅长的技能，获得的奖项，以及自己专业课的均分及排名(数学类课程尤为重要)。大家简历的模板可以用word自带的模板，这里我给大家一个百度网盘的链接，是我们去年用的简历模板，整体界面还不错，可以直接编辑。</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1tDR3feJzKCKWl8mDiecUjw" target="_blank" rel="noopener">https://pan.baidu.com/s/1tDR3feJzKCKWl8mDiecUjw</a><br>提取码：7sa1</p></blockquote><p>面试的一般都是学校的数模教练，老师一定不会为难大家，所以调整好心态认真回答即可。</p><h4 id="三、国赛系统课程培训-暑假一轮培训"><a href="#三、国赛系统课程培训-暑假一轮培训" class="headerlink" title="三、国赛系统课程培训(暑假一轮培训)"></a>三、国赛系统课程培训(暑假一轮培训)</h4><p>下面我来说说国赛培训的事情吧，以下是去年国赛一轮培训的课程时间安排计划表。</p><p><img src="https://i.loli.net/2020/06/10/EmlYkzjo2Ar7SU9.jpg" alt=""></p><p>每年的主讲老师和内容都会有一些小小的变化，主讲老师也不全是学校数模的教练。不过国赛培训大家好好听课就行了，不用考虑太多的事情，培训主要针对的是对大家水平进行更系统地提升训练。可能大家会听得一头雾水(当年大一的我反正不是很能跟上)，不过不用担心，大家下了课好好去消化尽力弄懂，即使弄不清内在原理，但是也要会灵活熟练使用的。大部分课程讲完后或者讲的过程中，都会布置作业，请参加培训的各位千万把作业记清楚，因为作业是要求之后统一上交的，会根据培训作业完成情况对校队成员进行调整，另外请不要无故缺勤培训，三个人必须到场，否则后果自己承担喽~</p><h4 id="四、国赛真题训练培训-二轮培训"><a href="#四、国赛真题训练培训-二轮培训" class="headerlink" title="四、国赛真题训练培训(二轮培训)"></a>四、国赛真题训练培训(二轮培训)</h4><p>往年上完国赛的培训课程就会放暑假了(今年例外，太特殊了)，然后会要求同学们暑假提前返校(西电数模er不存在假期，我唯一完整的假期是大一寒假)，进行真题训练，一轮培训以授课为主，二轮培训主要是队伍的真题训练，一般而言都是中秋国赛开始前，会进行四次真题模拟训练，以及不少于两次的答辩。四次真题的第一道题一般是全校队统一的，由总教练韩老师来出题，大家根据这次题目的完成情况以及暑假一轮培训作业的情况去面试导师，这个之后再详细说，二轮培训之后就是做真题了，从校赛跃迁到国赛的跨度还是很大很大的，国赛的题目会非常非常的难，不过请不要去惧怕这些东西，好好弄还是能弄出结果的，之后再进行答辩以及总结分析，再多看看优秀论文，二轮培训后的水平会有非常大幅度的提升，前提当然是你们队伍认真参加完成。</p><h4 id="五、面试导师"><a href="#五、面试导师" class="headerlink" title="五、面试导师"></a>五、面试导师</h4><p>这应该是大家最关心的一个环节了吧，去年的我天天追着学长问他们什么时候选择老师的，正如上面所说，数模校队的队伍是要求暑假提前返校的，返校后第一件事就是完成全校队统一的数模练习题，时间大概是4天，之后数模群会发今年国赛指导老师的名单以及联系的邮箱，大家把自己队伍的简历，一轮培训的作业以及二轮培训第一次完成的答卷发到老师邮箱等待回复即可，去年的二轮国赛指导老师有13个，一般而言投一个就差不多够了，一般老师们的回复都比较快，如果老师明确拒绝了你们，那你们再换个老师投简历，不必广撒网。</p><p>这里我分别简单介绍下我的国赛以及美赛培训的指导老师，也欢迎各位西电数模er私信我来补充其他老师的。</p><ul><li>穆学文老师：我们国赛培训的老师，是我们当时校队面试的老师，所以投了他的简历，当时找他的有7支队伍，我们是唯一一只大一的队伍(压力山大)，老师要求我们在某一天晚上和他见个面了解下情况(不是每个老师都有这个面试的，我队友找的老师就没有)，同意让我们跟着他参加二轮培训指导。老师答辩指导认真负责，培训的时候帮忙改论文也非常非常细致，总之非常值得大家的选择。</li><li>张胜利老师：学校数模竞赛的大牛老师，指导2015国赛本科组MATLAB创新奖(全国每题一个，那篇文章至今作为数模国赛经典范文)以及2020美赛INFORMS冠名O奖(全球每题一个，也就是我们队伍，手动狗头)。数模指导水平不用多说，反正美赛培训那几天我们队伍水平突飞猛进，修改论文也非常细致，找张老师修改论文才知道什么是大佬啊，我们队伍诸多写作毛病都是张老师指出来的。但是这个老师的竞争可能比较激烈，主力还是大三的同学居多，当时国赛我们也没跟上张老师。</li></ul><p>等选择老师的最终结果确定之后，就开始以各个老师组进行二轮培训的真题训练以及答辩了。一般会再布置2~4道真题，至于具体的题目是根据各个老师来决定的(还有舍友的老师是自主命题的，非常生猛，大部分还是国赛真题)，大家在规定的四天完成后发给自己的指导老师，然后由老师来组织统一的答辩，答辩就是把指导的所有队伍聚在一起，轮流上台展示本题的答卷结果(最好能做ppt)，然后指导老师对你们这次作业进行评价，最后指导老师会指出各个队伍的优缺点，别的队伍的优点大家都可以学习学习。答辩还有个重要的目的就是选拔正式队伍(之后解释)，请大家务必重视。完成真题训练后，基本就是要参赛了。</p><h4 id="六、校赛名单终确定"><a href="#六、校赛名单终确定" class="headerlink" title="六、校赛名单终确定"></a>六、校赛名单终确定</h4><p>在暑假前的面试所完成的，是一轮国赛培训的名单，并非最终校队名单。等经过两轮国赛培训，去掉一些培训缺勤以及一轮二轮培训作业不完成的队伍，加上态度良好认真完成一轮二轮培训作业的旁听队伍，最终组成校队名单。这些队伍就是能够参加中秋国赛的所有队伍。</p><p>现在我来解释下正式队伍和挂名队伍，每个指导老师会让7支队伍左右参加自己的国赛二轮培训，但经过答辩以及二轮作业完成情况，会选择4支正式队伍，以及3支挂名队伍，挂名队伍由再分配新的指导老师，其实差别也不太大，大家真的不必纠结是不是正式队伍。</p><h4 id="七、留一点小结尾"><a href="#七、留一点小结尾" class="headerlink" title="七、留一点小结尾"></a>七、留一点小结尾</h4><p>以上便是我写的全部参赛培训的经验了，下学期还会更新美赛的培训经验，总之今年是特殊的一年，大家国赛加油~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天西电数学建模竞赛总教练刚在群里通知，数学建模国赛报名及选拔工作即将开始。&lt;/p&gt;
&lt;p&gt;我想趁这个机会来分享下数模竞赛的从面试到培训，再到选导师，以及最后参赛的整个流程的经验。&lt;/p&gt;
&lt;p&gt;在这个过程中，如果有哪儿些地方没说清楚或者你有自己的见解，也欢迎各位西电er私信我来对这个文章予以补充，用来给更多的学弟学妹或者第一次参与整个数模竞赛的流程的同学一些可供参考的建议。&lt;/p&gt;
&lt;p&gt;学弟学妹们关于培训有什么问题或者担忧的地方，也欢迎私信我~&lt;/p&gt;
    
    </summary>
    
    
      <category term="数学建模" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="入门指导" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%85%A5%E9%97%A8%E6%8C%87%E5%AF%BC/"/>
    
    
      <category term="西电" scheme="http://yoursite.com/tags/%E8%A5%BF%E7%94%B5/"/>
    
  </entry>
  
  <entry>
    <title>科研论文常用LaTex代码</title>
    <link href="http://yoursite.com/2020/06/07/%E7%A7%91%E7%A0%94%E8%AE%BA%E6%96%87%E5%B8%B8%E7%94%A8LaTex%E4%BB%A3%E7%A0%81/"/>
    <id>http://yoursite.com/2020/06/07/%E7%A7%91%E7%A0%94%E8%AE%BA%E6%96%87%E5%B8%B8%E7%94%A8LaTex%E4%BB%A3%E7%A0%81/</id>
    <published>2020-06-06T21:56:50.000Z</published>
    <updated>2020-06-10T14:38:17.705Z</updated>
    
    <content type="html"><![CDATA[<p>【转载队友的论文博客】</p><p>正是由于数学建模美赛，我们队伍的同学才开始去学习<strong>Latex</strong>这样一个论文工具的</p><p>用完之后，真香！Word从此是路人</p><a id="more"></a><p>也许大部分本科生还不太了解<strong>Latex</strong>究竟是什么？简而言之就是，论文写作排版的工具</p><p>据我观察，大部分的本科学长还是用Word来完成毕业设计的。</p><p>于是我们有个西电的保研群里面就开始天天问“字体用什么”“标题间距”“怎么调画图”等等之类的问题</p><p>而如果你学会了<strong>Latex</strong>这样一个工具，你就只管写就可以了，只要有毕设的固定模板，你只需要写你的文字就可以了，排版之类的全部自动生成，完全不用你担心。</p><p><strong>Latex</strong>的好处我就不在此一一列举了，反正等大家上了研究生，发paper还是需要会用到的（大部分出版社和学校毕设都会直接给模板，直接使用即可，不需要学会如何自己编写模板宏包）这学期的大作业和实验报告我全是用的<strong>Latex</strong>完成的（当然模板是论文队友自己编写的宏包）</p><p>不说多了，这里是论文队友的博客，整理了一些科研论文常用LaTeX代码，对数模美赛国赛的写作都有很好的帮助，非常适合初学者（指不知道常用命令的同学）等大家学会了，善用百度Bing等就可以任意写作了。</p><p><a href="[https://levitate-qian.github.io/2020/03/08/%E6%95%B0%E6%A8%A1%E8%AE%BA%E6%96%87%E5%B8%B8%E7%94%A8LaTeX%E4%BB%A3%E7%A0%81/](https://levitate-qian.github.io/2020/03/08/数模论文常用LaTeX代码/">【持续更新】论文常用LaTeX代码</a>)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【转载队友的论文博客】&lt;/p&gt;
&lt;p&gt;正是由于数学建模美赛，我们队伍的同学才开始去学习&lt;strong&gt;Latex&lt;/strong&gt;这样一个论文工具的&lt;/p&gt;
&lt;p&gt;用完之后，真香！Word从此是路人&lt;/p&gt;
    
    </summary>
    
    
      <category term="LaTex" scheme="http://yoursite.com/categories/LaTex/"/>
    
    
      <category term="LaTex" scheme="http://yoursite.com/tags/LaTex/"/>
    
  </entry>
  
  <entry>
    <title>如何写出一篇高质量的数模竞赛答卷</title>
    <link href="http://yoursite.com/2020/06/02/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%B8%80%E7%AF%87%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E6%95%B0%E6%A8%A1%E7%AB%9E%E8%B5%9B%E7%AD%94%E5%8D%B7/"/>
    <id>http://yoursite.com/2020/06/02/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%B8%80%E7%AF%87%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E6%95%B0%E6%A8%A1%E7%AB%9E%E8%B5%9B%E7%AD%94%E5%8D%B7/</id>
    <published>2020-06-02T15:29:33.000Z</published>
    <updated>2020-06-02T15:03:03.244Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、写在前面"><a href="#一、写在前面" class="headerlink" title="一、写在前面"></a>一、写在前面</h3><p>我相信很多人都和我一样，刚开始入门的时候，接触到的是眼花缭乱的数学知识，不管是学校数模培训也好还是网上教程也好，时间序列，博弈论，排队论这些等等。<a id="more"></a> 都让我们不止一次地想过放弃，特别是没学过线代和概率论的时候硬啃数模的书籍，那简直就是天书啊。但是后来我才知道，那些都只是让你对数学模型有个初步的概念，直到现在，你要是翻开姜启源书上的任意一页，让我给你手推某个模型的推导，我想我还是万万做不到的。</p><p>但这个影响你做出一份高质量的数模答卷吗？我想是不太影响的，虽说你模型算法都没全部了解是不行的，但是也不必被其深深地困扰，毕竟比赛的时候，多半还是要靠搜索引擎，不可能能让你直接用哪儿个模型来做的。真正对于写作能力能有巨大的提升的永远只有两件事，<strong>做题和看优秀论文</strong>。做题可以是参加比赛或参与学校培训，然而其实培训参赛就是你去看优秀论文的时候，优秀论文之所以被称为优秀论文一定有它的原因，而我们需要做的就是不断地阅读，总结以及比较。</p><h3 id="二、阅读优秀论文的重要性"><a href="#二、阅读优秀论文的重要性" class="headerlink" title="二、阅读优秀论文的重要性"></a>二、阅读优秀论文的重要性</h3><p>当大家把基础的模型算法(高级的需要靠自己不断积累，但是比赛现学完全来得及)都掌握的差不多的时候，真正能让大家脱颖而出的是，写作的成熟度。我们在看论文的时候，大多可以把论文分为两类。</p><h4 id="1-优秀论文的分类"><a href="#1-优秀论文的分类" class="headerlink" title="1. 优秀论文的分类"></a>1. 优秀论文的分类</h4><ul><li><strong>A类</strong></li></ul><p>模型算法十分高级且运用正确，求解精确，分析到位，大奖。很遗憾的是，这类我们很难借鉴与总结。</p><ul><li><strong>B类</strong></li></ul><p>模型算法较为普通，但也能正确求解并自圆其说，写作功底好，分析到位，这类文章其实也能获得大奖。而就是这种文章是我们需要学习的，需要去重点总结和挖掘的。</p><h4 id="2-我们队伍的感悟"><a href="#2-我们队伍的感悟" class="headerlink" title="2. 我们队伍的感悟"></a>2. 我们队伍的感悟</h4><p>我们队伍在美赛和国赛培训的时候都会做的一件事情就是，大量阅读优秀论文，并将论文分类，将B类论文整理出来，把它们横向对比总结一遍，再和我们的对比总结一遍。虽然这次我们团队的大奖有运气成分，但我一定敢说，阅读了大量美赛优秀论文，我们做了许多总结和整理，是我们这次能得奖的重要前提。那下面我就来说说，我们团队对于数模比赛论文写作的目前可以提供给大家分享的经验。</p><h3 id="三、论文架构"><a href="#三、论文架构" class="headerlink" title="三、论文架构"></a>三、论文架构</h3><p>所有数模论文都有它的套路和最基本的格式，问题分析，模型建立，结果分析，灵敏性分析等等文章必须按照这个来。以及各个部分应该<strong>写什么，不能写什么</strong>，论文长度的限制。</p><p>当然可能你看个几篇文章就会发现一个问题，大家的结构怎么都不一样？确实有这个问题。产生这个问题的原因一般有两个方面：1. 大家整体思路框架是差不多的，只不过有些队伍进行了微调。 2. 受题目限制，例如2018年国赛B题，注定了传统论文框架无法去写(这是个很烦的问题，清晰的论文逻辑思路是论文写作最关键的一点，遇到这种情况只能自己定合理的框架)。</p><p>有时候我和学弟交流时也会发现，有些学弟的写作故意不按照套路来，想显得与众不同。关于这个想法，我想说是有极大的风险的。当然，在阅读优秀论文的过程中，确实也出现过这种情况，有些文章的结构其实我自己看都乱的快看不下去了，但是请大家注意一般这类文章能成为优秀论文可不是因为他的结构出彩，而是多半由于它的模型算法，也就是上文所提到的A类文章。对于大多数同学而言，还是老老实实按照思维的连贯性来吧，现在的比赛包括美赛在内，基本都是以四五个问题或四五个task的形式出现的，一个问题一个task对应一种模型算法，有时候可以连在一起解决，这里我给大家最常用的论文套路框架。</p><blockquote><ol><li>摘要</li><li>问题重述</li><li>问题分析(简单分析问题)</li><li>基本假设</li><li>符号说明</li><li>模型的建立、求解、分析</li><li>模型的分析、评价、推广(比如灵敏性分析，优缺点等)</li><li>参考文献</li><li>附录代码</li></ol></blockquote><p>架构可以根据题目灵活调整，主要是调整模型的建立、求解、分析这块部分。这部分通常有两种情况：(1) 一问一问分析，模型建立，算法求解，结果分析，如果嫌长也可以另起大标题。(2) 先建立好几问模型，再算法，最后一起分析。</p><p>再次强调，建议初次参加数模竞赛的同学们不要随便更改架构，容易翻车，你的内容不突出的情况下，架构给老师看<br>的还十分乱，是件糟糕的事情。</p><h3 id="四、针对模型算法"><a href="#四、针对模型算法" class="headerlink" title="四、针对模型算法"></a>四、针对模型算法</h3><h4 id="1-篇幅"><a href="#1-篇幅" class="headerlink" title="1. 篇幅"></a>1. 篇幅</h4><p>我这里先说说整篇文章的篇幅，论文页面控制在20 页左右，不超过25 页，不少于19 页为好。（从摘要到参考文献）附录和代码不算在总页数中。20-23 页极佳。模型和算法的篇幅一定是大部分的，不要主次颠倒。其实第一次我们参加校赛都没人告诉我们，我们正文部分写了50多页，没拿到校一等奖还十分不甘心，现在想想还是有些有趣的。</p><h4 id="2-模型方面"><a href="#2-模型方面" class="headerlink" title="2. 模型方面"></a>2. 模型方面</h4><p>比赛的时候一定可以查阅文献，注意不管是什么比赛，真的很少用书上的基础模型，如果你用了说明你的模型不够具有创新性。大家可以用搜索引擎根据问题去找更实用的模型，或者队伍水平高，可以自制创新想法的模型，比如我们这次美赛的模型。</p><h4 id="3-算法方面"><a href="#3-算法方面" class="headerlink" title="3. 算法方面"></a>3. 算法方面</h4><p>算法方面，尽量不要使用遗传退火这些神棍算法，用不好也不一定好用，算法的话可以自己查找其他的算法，也可以平时看看非常经典以及常用的算法。算法方面以模型求解的精确度为主，毕竟是数模建模竞赛，算法是用来解决模型求解的，当然有的时候算法也能直接充当模型构建的重要组成部分。还是那句话，数学这种东西，多学永远没坏处。</p><h4 id="4-最重要的"><a href="#4-最重要的" class="headerlink" title="4. 最重要的"></a>4. 最重要的</h4><p>这点我认为是数模比赛中最重要的一点，也是所有队伍包括大二大三都做不好的一点。就是模型和算法的表述，如果是别人的模型算法，千万不要直接搬到自己的论文里面来。我们校赛干过这破事，我们先用几页的篇幅介绍了下什么是遗传算法，估计阅卷老师看到都无语了。所以我们要做的就是，模型和算法一定要结合我们的实际问题来叙述，要求较高，但是一定要注意。</p><p>给大家举个例子，比如我们培训时国赛2018年A题练习训练，用来求解微分方程的一个算法_Crank-Nicholson_，我大概花了一个中午的时间，看懂了这个算法的意思(好像就是有限差分的变形)，然后我们写了文章。</p><p><img src="https://i.loli.net/2020/06/02/DLqbTrtaeOZW3IR.png" alt=""></p><p>如你们所见，对于微分方程模型的数值求解算法，我们就一句话，一句话。。。真的就一句话就带过去了，这现在让我看来，可以直接说这个论文表述非常非常初级。这种情况下，一定要结合你本来的题目内容把这个算法怎么求解的过程给写清楚！</p><h3 id="五、针对插图以及结果图"><a href="#五、针对插图以及结果图" class="headerlink" title="五、针对插图以及结果图"></a>五、针对插图以及结果图</h3><p>这点就不用多说了吧，参加过数模竞赛的都知道，老师没有大家想的那么细致的去审阅你的文章，我们教练说看论文一共就3min 时间(可能还是多的，要是你对队伍写的让我不忍卒读，可能都没这个时间，直接打入冷宫)，在这个情况下你如果全是打断文字叙述而没有图的话你试试？不光要有图，还要尽量做的丰富以及质量高。</p><p>结果图，可以用matlab、python 和excel 等来制作，请展开想象力，让结果图丰富以及好看起来。图表，折线图，柱状图，连续图谱都可以画一画。文字不够，图表来凑。插图，插图包括很多，热传导示意图，受力分析图，复杂算法流程图等。如果只有图片没有文字，那当然也是不行的，所以如何在25 页内控制好比例，在有限的图表个数内让图表丰富以来，这些真的需要大家多看论文积累经验了。</p><p>还是推荐下我论文队友的博客内容，关于画图的，真的强推。</p><p><a href="[https://levitate-qian.github.io/2020/05/04/10%E7%B1%BB%E6%A1%88%E4%BE%8B%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3%E8%AE%BA%E6%96%87%E6%8F%92%E5%9B%BE%E5%88%B6%E4%BD%9C/?tdsourcetag=s_pctim_aiomsg](https://levitate-qian.github.io/2020/05/04/10类案例带你了解论文插图制作/?tdsourcetag=s_pctim_aiomsg">10类案例带你了解论文插图制作</a>)</p><h3 id="六、针对结果分析"><a href="#六、针对结果分析" class="headerlink" title="六、针对结果分析"></a>六、针对结果分析</h3><p>结果分析一定一定要到位，还记得我上面说的优秀论文的分类吗？所有优秀论文都逃不出一个共性，就是分析到位。这听上去像是一句废话，不过能将这点做好的人并不多，包括在我后来参与的科研中。所以请大家记住论文的一个关键点，每当老师看到一张结果图的时候，他是看不明白的。这时候你一定要把你的分析写在结果图的上下，而且越多越详细越好。千万不要只有一张图和一行分析就了事了，此是论文大忌。给大家举一个反例，例如2018A 结果分析，当时实在太年轻，一行字解决。</p><p><img src="https://i.loli.net/2020/06/02/nB2JMkZEpaYoTgK.png" alt=""></p><p>对你们没看错，我画了一张图，然后一行字解决了分析，真就一行字。什么都没有，现在看来确实让我觉得很匪夷所思哈哈哈。</p><h3 id="七、针对其他方面"><a href="#七、针对其他方面" class="headerlink" title="七、针对其他方面"></a>七、针对其他方面</h3><h4 id="1-灵敏性分析"><a href="#1-灵敏性分析" class="headerlink" title="1. 灵敏性分析"></a>1. 灵敏性分析</h4><p>灵敏性分析一般在论文结尾，也就是模型的分析那块，最好有，这绝对是加分项，需要有图有分析。图在美赛中可以稍微做的好看一点。</p><h4 id="2-摘要"><a href="#2-摘要" class="headerlink" title="2. 摘要"></a>2. 摘要</h4><p>放在最后讲，摘要当真是重中之重。你么说老师看论文3min 能看啥？看摘要，看图，看结果分析。其他什么问题重述，背景，优缺点，推广，参考文献是不可能有人看的。摘要一定是重中之中，建议对照往年优秀论文来写摘要。优秀论文的模型算法学不来，摘要还是一定要学的。每次写摘要都是建模队友主笔，我们团队三个人一起修改一起写，并最终修订了几十遍的版本。</p><h3 id="八、写在最后"><a href="#八、写在最后" class="headerlink" title="八、写在最后"></a>八、写在最后</h3><p>以上便是我关于如何做出一篇高质量的数模答卷的一些经验了，但是你看懂了这些，也只是摸清了一些写作的方向，但也会让你少走很多很多弯路，我相信你看到这儿是有一点收获的(或者完全没有，那不好意思是我太菜了，逃)。其实有很多东西，我是无法教你们的，我给大家的建议还是多看优秀论文多做总结，前段时间我们学校校赛，我也帮过一些学弟学妹看论文，这时候我再回头看那些文章就明白了很多问题，包括我原来自己写的那些(原来培训的论文真的现在看来特别好笑)。这种论文的整体感觉以及如何科学的安排论文分布，我无法只言片语地写给你，但是当你们的优秀论文看到一定数量并做了大量总结，我相信你们会形成一定的属于你们的风格。</p><p>让我们未来一起共勉吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、写在前面&quot;&gt;&lt;a href=&quot;#一、写在前面&quot; class=&quot;headerlink&quot; title=&quot;一、写在前面&quot;&gt;&lt;/a&gt;一、写在前面&lt;/h3&gt;&lt;p&gt;我相信很多人都和我一样，刚开始入门的时候，接触到的是眼花缭乱的数学知识，不管是学校数模培训也好还是网上教程也好，时间序列，博弈论，排队论这些等等。
    
    </summary>
    
    
      <category term="数学建模" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="入门指导" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%85%A5%E9%97%A8%E6%8C%87%E5%AF%BC/"/>
    
    
      <category term="数学建模" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
  </entry>
  
  <entry>
    <title>图像基本操作</title>
    <link href="http://yoursite.com/2020/03/24/%E5%9B%BE%E5%83%8F%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2020/03/24/%E5%9B%BE%E5%83%8F%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</id>
    <published>2020-03-24T15:16:32.000Z</published>
    <updated>2020-05-08T15:33:40.262Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、笔记整理"><a href="#一、笔记整理" class="headerlink" title="一、笔记整理"></a>一、笔记整理</h3><p>通过b站以及github的学习完成了本教程，讲解了图像处理的底层知识，本教程所有python代码将会放在我的github仓库上面，通过首页即可访问。欢迎大家通过github来学习，当然想提高学习效率，提前了解git，ssh以及其基本命令是必须的，之后我也会推荐关于计算机视觉以及深度学习的项目。</p><a id="more"></a><h3 id="二、图像的本质"><a href="#二、图像的本质" class="headerlink" title="二、图像的本质"></a>二、图像的本质</h3><p>在学习之前我们需要思考一个问题，在计算机的眼中，图像到底是什么东西。</p><p><img src="https://i.loli.net/2020/03/24/hCJsYW86rzHkeN7.png" alt=""></p><p>我们用所有cv教程中最经典的名画来举例，计算机将图像分割了成了无数小方格，这些小方格分别有自己对应的数字矩阵，而这些数字矩阵便是计算机解读和提取图像的信息。这些数字其实便是我们常说的RGB像素，这个概念并不难理解，其实在我们眼中图片是可视化的，而在计算机眼中，所有一切可视化的图片以及视屏都是矩阵。</p><p>这也是为何传统领域的图像处理属于信号与信息处理领域，本质上任何预处理的都是数字。</p><p>明白了这个概念，下面我们可以用简单的几个命令，来将图像的数字信息给提取出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img=cv2.imread(<span class="string">'image\lena.jpg'</span>)  <span class="comment"># 读取图片的RGB参数</span></span><br><span class="line">size=img.shape <span class="comment"># 获取矩阵的维度</span></span><br></pre></td></tr></table></figure><p>通过这样的命令，我们便可以得到一个$266\times 266 \times 3$的矩阵了，说明计算机将lena的图像分成了266*266的像素小方格，每个方格有三个参数，这三个参数分别代表B，G，R(这里注意不是RGB)。</p><p><img src="https://i.loli.net/2020/03/24/zlZnW9v5yqg4VXj.png" alt=""></p><p>下面还有一个问题，如果只告诉计算机一张图片的像素参数，计算机能否将它画出来。这当然也是很轻松的。</p><p>比如我们提取了lena图片中的img参数，用一个万不变的函数便能解决。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cv_show</span><span class="params">(name,img)</span>:</span></span><br><span class="line">    cv2.imshow(name,img)  <span class="comment"># 显示图片，可以多个窗口</span></span><br><span class="line">    cv2.waitKey(<span class="number">0</span>) <span class="comment"># 窗口停止时间，毫秒级，0表示任意键结束</span></span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line">cv_show(<span class="string">'image'</span>,img)</span><br></pre></td></tr></table></figure><p>上述代码非常简单，我就不仔细说明了。下面我们来思考下，如果一张彩色的图片，我们能否提取他灰度的参数，即灰度处理，将其变成灰度图像。只需要记下下面cv2的命令即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img=cv2.imread(<span class="string">'image\lena.jpg'</span>,cv2.IMREAD_GRAYSCALE) <span class="comment"># 灰度处理：读取灰度参数</span></span><br><span class="line">cv_show(<span class="string">'lena_gray'</span>,img)</span><br><span class="line">cv2.imwrite(<span class="string">'image\lena_gray.png'</span>,img) <span class="comment"># 保存图片</span></span><br></pre></td></tr></table></figure><p>并保存图片，我们得到了新的lena图片。</p><p><img src="https://i.loli.net/2020/03/24/JcZB8r4HSlyDdiT.png" alt=""></p><h3 id="三、处理视屏"><a href="#三、处理视屏" class="headerlink" title="三、处理视屏"></a>三、处理视屏</h3><h4 id="1-图像与视屏的关系"><a href="#1-图像与视屏的关系" class="headerlink" title="1. 图像与视屏的关系"></a>1. 图像与视屏的关系</h4><p>下面我们来研究如何处理视屏的图像，其实两者完全一样，视屏有帧数的概念，我们把一帧看做一个图像，那这样理解就轻松很多了，我们只需要一帧一帧地分离视屏，并用图像的处理知识就可以啦。</p><h4 id="2-几个基础的图像或视屏处理命令"><a href="#2-几个基础的图像或视屏处理命令" class="headerlink" title="2.几个基础的图像或视屏处理命令"></a>2.几个基础的图像或视屏处理命令</h4><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">cv2.VideoCapture(‘video.mp4’,(0))</td><td style="text-align:center">捕捉摄像头，后面的0代表默认，可有可无</td></tr><tr><td style="text-align:center">read()</td><td style="text-align:center">检查是否能打开视屏以及读取的图像内容</td></tr><tr><td style="text-align:center">cv2.cvtColor()</td><td style="text-align:center">转换颜色</td></tr><tr><td style="text-align:center">cv2.imshow()</td><td style="text-align:center">展示图像或视屏</td></tr><tr><td style="text-align:center">cv2.waitkeys()</td><td style="text-align:center">等待的时间或视屏图像展示时间</td></tr></tbody></table></div><h4 id="3-视屏基本操作"><a href="#3-视屏基本操作" class="headerlink" title="3.视屏基本操作"></a>3.视屏基本操作</h4><p>下面我们对视屏进行一些基本操作，包括提取视屏，检查是否能打开，将彩色视屏转换为灰色视屏，快进视屏。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 处理视屏</span></span><br><span class="line">video=cv2.VideoCapture(<span class="string">'image/test.mp4'</span>) <span class="comment"># 捕捉摄像头，用数字来控制不同的设备，例如外接通常为400</span></span><br><span class="line"><span class="comment"># 检查是否正确打开</span></span><br><span class="line"><span class="keyword">if</span> video.isOpened():</span><br><span class="line">    open, frame = video.read()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    open=<span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> open:</span><br><span class="line">    ret, frame=video.read()</span><br><span class="line">    <span class="keyword">if</span> frame <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> ret==<span class="literal">True</span>:</span><br><span class="line">        gray=cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)   <span class="comment"># 转换视屏颜色</span></span><br><span class="line">        cv2.imshow(<span class="string">'result'</span>,gray)</span><br><span class="line">        <span class="keyword">if</span> cv2.waitKey(<span class="number">10</span>) &amp; <span class="number">0xFF</span>==<span class="number">27</span>:  <span class="comment"># waitkey代表视屏播放时间，0xFF==27相当于键盘上的Esc键退出</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">video.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h4 id="四、图像基本操作"><a href="#四、图像基本操作" class="headerlink" title="四、图像基本操作"></a>四、图像基本操作</h4><h4 id="1-截取部分图像"><a href="#1-截取部分图像" class="headerlink" title="1.截取部分图像"></a>1.截取部分图像</h4><p>手机上处理照片有一个我们非常常用的功能，叫”裁剪”。同样，计算机上也有。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 截取部分图像数据</span></span><br><span class="line">img=cv2.imread(<span class="string">'image\lena.jpg'</span>)</span><br><span class="line">lena_new=img[<span class="number">0</span>:<span class="number">200</span>,<span class="number">0</span>:<span class="number">200</span>]</span><br><span class="line">cv_show(<span class="string">'lena_new'</span>,lena_new)</span><br><span class="line">cv2.imwrite(<span class="string">'image\lena_new.png'</span>,lena_new) <span class="comment"># 保存图片</span></span><br></pre></td></tr></table></figure><p>通过简单地规定矩阵的范围，我们可以得到裁剪后的图像。</p><p><img src="https://i.loli.net/2020/03/24/mgq8xSG6CedLTUZ.png" alt=""></p><h4 id="2-颜色通道提取"><a href="#2-颜色通道提取" class="headerlink" title="2.颜色通道提取"></a>2.颜色通道提取</h4><p>对于图像的颜色而言，我们之前说了如何将彩色图像转换为灰色图像，其实其他颜色也可以相互转化，我们通过对图像颜色的提取，修改b，g，r这三个在0~255之间的参数，便可以随意更改图像的颜色了。比如这里面，我只保留lena图像中的r参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 颜色通道提取</span></span><br><span class="line">b,g,r=cv2.split(img)</span><br><span class="line"><span class="comment"># 只保留R</span></span><br><span class="line">cur_img=img.copy()</span><br><span class="line">cur_img[:,:,<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">cur_img[:,:,<span class="number">1</span>]=<span class="number">0</span></span><br><span class="line">cv_show(<span class="string">'R'</span>,cur_img)</span><br><span class="line">cv2.imwrite(<span class="string">'image\lena_R.png'</span>,cur_img) <span class="comment"># 保存图片</span></span><br></pre></td></tr></table></figure><p>我们成功地得到了一张红色的lena照片。对色域感兴趣的小伙伴，可以直接google所有的RGB值。</p><p><img src="https://i.loli.net/2020/03/24/NuSbmdzq9pYBCw5.png" alt=""></p><h4 id="3-边界填充"><a href="#3-边界填充" class="headerlink" title="3.边界填充"></a>3.边界填充</h4><p>除了裁剪图像，有的时候我们还需要拓宽图像的边界，而边界的地方有许多种填充方式，在这里我为大家介绍其中的常用的6种。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 边界填充</span></span><br><span class="line">top_size,bottom_size,left_size,right_size = (<span class="number">50</span>,<span class="number">50</span>,<span class="number">50</span>,<span class="number">50</span>) <span class="comment"># 表示拓充上下左右的宽度</span></span><br><span class="line">replicate = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size, borderType=cv2.BORDER_REPLICATE)</span><br><span class="line">reflect = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size,cv2.BORDER_REFLECT)</span><br><span class="line">reflect101 = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size, cv2.BORDER_REFLECT_101)</span><br><span class="line">wrap = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size, cv2.BORDER_WRAP)</span><br><span class="line">constant = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size,cv2.BORDER_CONSTANT, value=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">231</span>), plt.imshow(img, <span class="string">'gray'</span>), plt.title(<span class="string">'ORIGINAL'</span>)</span><br><span class="line">plt.subplot(<span class="number">232</span>), plt.imshow(replicate, <span class="string">'gray'</span>), plt.title(<span class="string">'REPLICATE'</span>)</span><br><span class="line">plt.subplot(<span class="number">233</span>), plt.imshow(reflect, <span class="string">'gray'</span>), plt.title(<span class="string">'REFLECT'</span>)</span><br><span class="line">plt.subplot(<span class="number">234</span>), plt.imshow(reflect101, <span class="string">'gray'</span>), plt.title(<span class="string">'REFLECT_101'</span>)</span><br><span class="line">plt.subplot(<span class="number">235</span>), plt.imshow(wrap, <span class="string">'gray'</span>), plt.title(<span class="string">'WRAP'</span>)</span><br><span class="line">plt.subplot(<span class="number">236</span>), plt.imshow(constant, <span class="string">'gray'</span>), plt.title(<span class="string">'CONSTANT'</span>)</span><br><span class="line">plt.savefig(<span class="string">'image/image_filling.png'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>这些复杂的代码我觉得并不需要非常深刻地理解，当然如果感兴趣你也可以去看看python底层的库程序到底是怎么实现的。一共六张图片，效果如下图所示。</p><p><img src="https://i.loli.net/2020/03/24/DSwIb4hQto6H5N3.png" alt=""></p><h4 id="4-数值计算"><a href="#4-数值计算" class="headerlink" title="4.数值计算"></a>4.数值计算</h4><p>我们之前说了为了表示色域，所有图像提取的参数都是0~255，那如果我们给所有参数原有基础上加上10呢，又或者我们的参数超过了255怎么办？图像的计算一样非常简单，如果超过了，计算机会自动模256，让其回到原来的区间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数值计算</span></span><br><span class="line">img_cat=cv2.imread(<span class="string">'image/cat.jpg'</span>)</span><br><span class="line">img_car=cv2.imread(<span class="string">'image/car.png'</span>)</span><br><span class="line">img_cat2=img_cat+<span class="number">10</span></span><br><span class="line">img_sum=img_cat+img_cat2 <span class="comment"># 相当于%256</span></span><br><span class="line">img_sum2=cv2.add(img_cat,img_cat2)</span><br></pre></td></tr></table></figure><h4 id="5-图像融合"><a href="#5-图像融合" class="headerlink" title="5.图像融合"></a>5.图像融合</h4><p>相信对基于深度学习的cv感兴趣的伙伴，一定看过一个开源项目基于tensorflow的neural-style。对于简单的图像融合，我们有非常简单的命令。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 图像融合</span></span><br><span class="line"><span class="comment"># print(img_cat.shape,img_car.shape)</span></span><br><span class="line">img_car=cv2.resize(img_car,(<span class="number">500</span>,<span class="number">414</span>))</span><br><span class="line"><span class="comment"># img_car=cv2.resize(img_car,(0,0),fx=1,fy=3)</span></span><br><span class="line">res=cv2.addWeighted(img_cat,<span class="number">0.6</span>,img_car,<span class="number">0.4</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment"># cv_show('fusion',res)</span></span><br><span class="line">plt.imshow(res)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>但是需要注意的是，如果两张照片的尺寸不同，那显然他们像素矩阵是不能直接按权重相加的，这时候我们就需要resize的命令了，大可以动手操作一下以上程序，毕竟实践出真知。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、笔记整理&quot;&gt;&lt;a href=&quot;#一、笔记整理&quot; class=&quot;headerlink&quot; title=&quot;一、笔记整理&quot;&gt;&lt;/a&gt;一、笔记整理&lt;/h3&gt;&lt;p&gt;通过b站以及github的学习完成了本教程，讲解了图像处理的底层知识，本教程所有python代码将会放在我的github仓库上面，通过首页即可访问。欢迎大家通过github来学习，当然想提高学习效率，提前了解git，ssh以及其基本命令是必须的，之后我也会推荐关于计算机视觉以及深度学习的项目。&lt;/p&gt;
    
    </summary>
    
    
      <category term="图像处理与计算机视觉" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
      <category term="入门笔记整理" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/"/>
    
    
      <category term="图像处理" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>电路模拟仿真软件icircuit使用指南</title>
    <link href="http://yoursite.com/2020/03/13/%E7%94%B5%E8%B7%AF%E6%A8%A1%E6%8B%9F%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6icircuit%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2020/03/13/%E7%94%B5%E8%B7%AF%E6%A8%A1%E6%8B%9F%E4%BB%BF%E7%9C%9F%E8%BD%AF%E4%BB%B6icircuit%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</id>
    <published>2020-03-12T23:37:57.000Z</published>
    <updated>2020-05-08T15:34:11.196Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、为何选择icircuit？"><a href="#一、为何选择icircuit？" class="headerlink" title="一、为何选择icircuit？"></a>一、为何选择icircuit？</h3><p>这学期我们学校电院开始了《数字电路与逻辑设计》以及《模拟电子电路与技术基础》，这两门学科在电子领域地位和意义重大，想学好这两门课可不是很容易，他们相对于其他门学科而言，更加抽象。<a id="more"></a>个人觉得学习这两门课的最好方法就是实验，可是实验首先没有器材，其次实验的结果可能和你学的完全不一样。所以我把目标转向了仿真软件，我首先运用的就是射频电路分析的专业仿真软件multism。</p><p><img src="https://i.loli.net/2020/03/12/A4CxbX1JmvI9GFO.png" alt=""></p><p>但是复杂的界面以及冗长的操作手册有点让人忘而却步，虽然经过学习，multism也没有那么复杂，但它依然不够便捷，参数设置复杂，但其实我们课本并没有那么难，我只是想切切实实感受下电路的设置与构造。</p><p>(当然如果想要研究multism的同学，研究手册请到我网盘自己提取。链接：<a href="https://pan.baidu.com/s/179cNL4JUr9EVnwz51PS-cw" target="_blank" rel="noopener">https://pan.baidu.com/s/179cNL4JUr9EVnwz51PS-cw</a> 提取码：hlq7)</p><p><img src="https://i.loli.net/2020/03/12/7ValSIbuwyrgjOB.png" alt=""></p><p>于是我把研究的方向转到了ipad上的一款电路仿真软件——icircuit，这款软件几乎满足了我的所有需求，轻便，简洁，仿真结果迅速。美中不足的是，这款软件没有官方的教程文案，这让我倒弄了很久，但是研究一段时间之后，不得不赞叹这款软件的优秀表现。</p><p><img src="https://i.loli.net/2020/03/12/bQwkgxiXYIoA8HF.png" alt=""></p><h3 id="二、界面简介"><a href="#二、界面简介" class="headerlink" title="二、界面简介"></a>二、界面简介</h3><p>和大部分苹果app一样，它也是可以和其他云存储共享文件的，icloud，onedrive等等(当然这个文件共享和存储也没必要)，首先在最近项目中建立”电路.icircuit”文件，进入之后，就是我们设计电路并仿真的界面了。</p><p><img src="https://i.loli.net/2020/03/13/WMtbA5xk1TGJwqf.png" alt=""></p><p>界面分成几块区域，我们来单个介绍：</p><ul><li><ol><li>白色画板：<br>用来设计电路以及查看电路仿真的区域</li></ol></li><li><ol><li>加号添加器件：<br>点击下面蓝色的加号键，我们便能看到可以用的所有器件了，分了四个种类：来源，模拟，数字，硅。添加的方法十分方便，将器件拖入白色画板即可。</li></ol></li><li><ol><li>查看器件参数：<br>右边第三个按键，我们点击我们指定的电子器件，就可以在METER里面看到这个器件的所有参数了，包括电压电流以及其本身的性质等等。</li></ol></li><li><ol><li>可视化示波器：<br>右边第二个按键，波形图符号，大家可以再SCOPE面板中查看我们想要看到的电压电流特性波形。</li></ol></li></ul><h3 id="三、设计电路"><a href="#三、设计电路" class="headerlink" title="三、设计电路"></a>三、设计电路</h3><p>下面我们就要开始设计我们的电路了，这里我用我的作业来举例，比如老师让我们设计电路，使其实现相减器的功能，例如 $u_o=3u_{i1}-4u_{i2}$这样的电路关系。下面真的非常简单，相减器电路模型我就不说了，我来讲讲细节的操作。</p><h4 id="1-如何改变电子器件的方向"><a href="#1-如何改变电子器件的方向" class="headerlink" title="1. 如何改变电子器件的方向"></a>1. 如何改变电子器件的方向</h4><p>在我们设计电路的时候，往往为了直观，会把电阻或者电压弄成不一样的形状，当我们在icircuit中将器件拖入白板中时，默认方向为竖向，如果你想要调成横向时，得掌握一个技巧，以电阻为例，拖入白板之后，点击它使它变为蓝色，这时你会发现上下拖动和左右拖动，改变了它的长度以及纵向位置，并没有改变方向，这时我们就需要拖动电阻的某一端点，将其变为其他方向的电阻。其他电子器件同理。</p><p><img src="https://i.loli.net/2020/03/13/gVt82Q13jOBS9Rh.png" alt=""></p><h4 id="2-怎样改变电子器件的参数"><a href="#2-怎样改变电子器件的参数" class="headerlink" title="2. 怎样改变电子器件的参数"></a>2. 怎样改变电子器件的参数</h4><p>这其实是个简单的问题，比如交流电压源，单击触碰时可以将其删除，双击触碰便可以打开其参数面板。根据自己需求更改即可。</p><p><img src="https://i.loli.net/2020/03/13/M69yNd5vUqiPGmo.png" alt=""></p><h4 id="3-怎样连接各个电子器件"><a href="#3-怎样连接各个电子器件" class="headerlink" title="3. 怎样连接各个电子器件"></a>3. 怎样连接各个电子器件</h4><p>这个问题也是个非常简单的问题，你既可以拖动电子器件，改变它本身的长度(改变长度对参数没有任何影响)，也可以直接手画电力线，你不用触碰任何按钮，你只需要从一个电子器件的一端用手拖到另一端即可。反正总之连上去就行。如果在连接的过程，出现了短路或者反电路知识的情况，icircuit会给你报错。</p><p><img src="https://i.loli.net/2020/03/13/Xwnhb7SH1EQomdi.png" alt=""></p><h4 id="4-设计之后的电路图"><a href="#4-设计之后的电路图" class="headerlink" title="4. 设计之后的电路图"></a>4. 设计之后的电路图</h4><p>经过以上操作后，我相信实现一个简简单单的相减器，甚至更复杂的电路模型，都不是问题。如下图所示，这就是我设计的电路图，两个交流电压源，频率均为1Hz，振幅分别为2V和5V，同样我们可以使用参数面板来查看指定器件的参数。我们也可以看到黄色的小点在电路中流动，表示电路的可运行性。</p><p><img src="https://i.loli.net/2020/03/13/smg7Fw5Xrb6PWyj.png" alt=""></p><h3 id="四、仿真模拟"><a href="#四、仿真模拟" class="headerlink" title="四、仿真模拟"></a>四、仿真模拟</h3><p>下面要进行的就是最关键的步骤，仿真结果可视化输出，这也是当时让我琢磨了很久的部分。因为光用METER参数面板其实无法看出电压之间的关系，也就无法验证我们的结果。</p><h4 id="1-打开示波器，添加我们需要的参数"><a href="#1-打开示波器，添加我们需要的参数" class="headerlink" title="1. 打开示波器，添加我们需要的参数"></a>1. 打开示波器，添加我们需要的参数</h4><p>当我们设计完电路，打开示波器按钮时，懵了，啥也没有。</p><p><img src="https://i.loli.net/2020/03/14/EBO4QzNRLfT8S7t.png" alt=""></p><p>想一想当然也正常，设计完电路，软件也不知道你需要输出器件的波形啊。下面就是可视化的关键步骤了。<strong>添加我们需要的器件的参数</strong>，比如说这题目我们设计完电路，需要验证三个变量$u_o,u_{i1},u_{i2}$的电压是否满足电路关系，对应到电路图上来，也就是两个电压源以及一个电阻两端的电压，我们以最左边的交变电压源为例，我们需要输出它两端电压的波形图。点开METER面板，单击触碰它，使它变蓝，在METER参数面板中，我们就能看到他所有的参数，每个参数变量前，都有个小圆圈，我们这里需要电压，于是我们在符号Vd前面把圆圈点亮，这时我们便可以看到示波器里面，输出了交变电压两端的电压波形图了。</p><p><img src="https://i.loli.net/2020/03/14/EuY3SdL2pJ41i95.png" alt=""></p><p>在示波器中，我们可以看到电压的峰峰值，以及黄色标记，我们指定的交变电压源的周围也有一圈黄色光晕，代表它被选中且参数为黄色曲线。下面我们如法炮制，将另外两个参数也添加进入示波器中。</p><p><img src="https://i.loli.net/2020/03/14/K7BLcgxZtUesyVn.png" alt=""></p><h4 id="2-如何使波形图显示在同一个坐标系中"><a href="#2-如何使波形图显示在同一个坐标系中" class="headerlink" title="2. 如何使波形图显示在同一个坐标系中"></a>2. 如何使波形图显示在同一个坐标系中</h4><p>到上步之后，我们通过观察峰峰值，其实已经可以看出来了，我们设计的电路，满足了$u_o=3u_{i1}-4u_{i2}$这样的电路关系。但是输出的波形却是一模一样的，很难直观看出波形顶端差距，例如当我们可视化同相/反相比例放大器时，就是想直观看出波形的变化。</p><p><img src="https://i.loli.net/2020/03/14/lOCconmVpLeGbxI.png" alt=""></p><p>这个时候，我们点击示波器的 <strong>‘’$i$按钮’’</strong>，出现了示波器坐标系的调整面板，在这里面我们可以设置示波器的持续时间以及坐标系的最大最小幅值，如果我们需要将三个波形放到同一个坐标系下的话，点击堆叠按钮，取消堆叠，然后我们便得出了同一张坐标系下的三个波形图，更加直观。</p><p><img src="https://i.loli.net/2020/03/14/SaDogxhVXlA9POK.png" alt=""></p><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>以上便是我整理的所有icircuit使用指南的内容了，icircuit肯定不止这些功能，我只选取了对于学习数电模电有用的功能进行整理介绍，模电学习十分抽象，如果大家能利用自己的课余时间，将书上的电路模型都仿真一遍，相信对大家的学习会有很大的帮助。</p><p><img src="https://i.loli.net/2020/03/14/yhDurnQ6c9oEN1Z.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、为何选择icircuit？&quot;&gt;&lt;a href=&quot;#一、为何选择icircuit？&quot; class=&quot;headerlink&quot; title=&quot;一、为何选择icircuit？&quot;&gt;&lt;/a&gt;一、为何选择icircuit？&lt;/h3&gt;&lt;p&gt;这学期我们学校电院开始了《数字电路与逻辑设计》以及《模拟电子电路与技术基础》，这两门学科在电子领域地位和意义重大，想学好这两门课可不是很容易，他们相对于其他门学科而言，更加抽象。
    
    </summary>
    
    
      <category term="实用工具" scheme="http://yoursite.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="icircuit" scheme="http://yoursite.com/tags/icircuit/"/>
    
  </entry>
  
  <entry>
    <title>入门参与数学建模竞赛</title>
    <link href="http://yoursite.com/2020/02/13/%E5%85%A5%E9%97%A8%E5%8F%82%E4%B8%8E%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AB%9E%E8%B5%9B/"/>
    <id>http://yoursite.com/2020/02/13/%E5%85%A5%E9%97%A8%E5%8F%82%E4%B8%8E%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AB%9E%E8%B5%9B/</id>
    <published>2020-02-13T12:46:33.000Z</published>
    <updated>2020-05-08T15:40:30.247Z</updated>
    
    <content type="html"><![CDATA[<p>哇！终于有时间来写这个入门参与数模的指导教程了，由于疫情原因一直没发开学，正好也来写点东西。在这次2020年国际数学建模竞赛中，我们队伍获得了特等O奖，并被美国INFORMS(运筹与管理学协会)冠名为当年D题全球最佳答卷，不得不说这次运气真的好，大概率应该是退役了吧。<a id="more"></a>本科二年级拿到这个奖还是非常欣喜的，剩下的大学时光我也要去追求其他东西了，不过关于数模的入门教程我想我会认真更新的。</p><p><a href="http://www.comap-math.com/mcm/2020Certs/2006782.pdf" target="_blank" rel="noopener">冠名O奖证书</a></p><p><img src="https://i.loli.net/2020/05/08/8gnji4raC1BFqHb.jpg" alt=""></p><p>当然这篇文章作为入门指导，我当然不会说什么硬核的东西，我还是会以一个引导者的身份来和你们聊聊如何0基础入门数模竞赛，数学建模竞赛的门槛真的很低很低，但是能不能做得好又是另外一回事情了。</p><h3 id="一、前言：数模竞赛给我带来了什么"><a href="#一、前言：数模竞赛给我带来了什么" class="headerlink" title="一、前言：数模竞赛给我带来了什么"></a>一、前言：数模竞赛给我带来了什么</h3><p>本人是从大一开始准备数学建模竞赛的，当时甚至还没学过线代和概率，遇到书只能硬啃。参加了学校的校赛，国赛培训，国赛(陕西省一等奖)，美赛培训，美赛(今年的美赛)。比赛经验就是这么多场了，主要还是靠学校的培训提高了水平，感谢西电教练团！！！</p><h4 id="1-简历上的荣誉"><a href="#1-简历上的荣誉" class="headerlink" title="1. 简历上的荣誉"></a>1. 简历上的荣誉</h4><p>首先肯定是简历上的荣誉，可以让夏令营老师多看你一眼，虽然数模不如acm和电赛硬核，但能成为大学生三大竞赛之一，想必也有它的理由。大学生数模竞赛主要有两个认可度比较高的比赛，一是每年9月的国赛(全国大学生数学建模竞赛)，二是美赛(国际大学生数学建模竞赛)。各有各的专攻方向，之后也会详细说这两个比赛的区别。</p><h4 id="2-个人技能的提升"><a href="#2-个人技能的提升" class="headerlink" title="2. 个人技能的提升"></a>2. 个人技能的提升</h4><p>说实话，最初想参加美赛真的没想到能拿这么大的奖，纯粹是因为我们学校电院加分比较多。但仔细想想，在美赛培训当中，又强迫我学习了许多对于科研非常有用但我原来懒得学的东西。如果不是数学建模，我们可能到现在也只能面向Bing和CDSN使用MATLAB，更不会使用像LaTeX这样的偏科研写作的专业排版软件。其实整个数模比赛3-4天的过程就是压缩了的科研经历，在这里我学会了大量英文文献的阅读和写作，快速学习模型与算法并应用的能力等等。确实数模真的给我能力的提升太多太多了，’Math is always dependable.’。多学数学，不管你以后从事什么，你都不会吃亏。</p><h4 id="3-对于科研心态的转变"><a href="#3-对于科研心态的转变" class="headerlink" title="3. 对于科研心态的转变"></a>3. 对于科研心态的转变</h4><p>在上面我就说过，数模比赛就是一次科研经历。在科研的道路上，遇到挫折几乎是绝对的事情，不可能有人说他的科研生涯都能顺风顺水，所有idea都能实现。在比赛的时候，对于模型无法实现，结果无法导出，你是否能以平和的心态去面对，确实是件需要锻炼的事情。除此之外，我相信大部分都和我一样，比赛的几天非常辛苦，于是就希望能拿到一个匹配甚至超过自己努力结果的成绩，孩子们，这可没有因果关系。患得患失的心态就是我大一的常态，不得不说这让我很累，想得越多对自己的生活学习影响越大，你是否能以坦然的心态来面对呢？(前段时间我看了我们校赛的文章，真的再也看不下去了)</p><h3 id="二、队伍组建：最最最重要的事情"><a href="#二、队伍组建：最最最重要的事情" class="headerlink" title="二、队伍组建：最最最重要的事情"></a>二、队伍组建：最最最重要的事情</h3><h4 id="1-为什么重要？"><a href="#1-为什么重要？" class="headerlink" title="1. 为什么重要？"></a>1. 为什么重要？</h4><p>道理很简单，你的队友不一定要是一位大佬，但他需要愿意去学习，数模比赛最重要的东西就是愿意去学习新的或者是你根本看不懂的知识。初等模型，初等算法，论文写作架构，我相信这些是大家入门时必看的东西，然而三人一起学习的效果一定强于一个人学习。另外，你们的团队需要早早地磨合好，尽量不要中途有人退出，然后又找人进来。我打数模以来也接触了许多支队伍，能拿大奖的不一定要是三位大佬，有时候一个团结的队伍能爆发出更大的能量，我很幸运我能遇到两位志同道合的朋友，陪我一直坚持到了今天。</p><h4 id="2-专业可以适当考虑，但并不是决定性因素"><a href="#2-专业可以适当考虑，但并不是决定性因素" class="headerlink" title="2. 专业可以适当考虑，但并不是决定性因素"></a>2. 专业可以适当考虑，但并不是决定性因素</h4><p>关于第二点，很多人在组队上都有一定的执念，希望建模队友是数统院的，编程队友是计算机院的，论文队友是商学院的，而且团队最好男女搭配等等。个人觉得这些因素确实可以考虑，但不应该是你们的首要决定因素。我们的队伍三人均来自于电子工程学院，但是你在电院并不代表你不擅长计算机或者论文写作啊，这并没有必然联系。我认为还是以愿意努力学习作为选队友的第一标准。</p><h4 id="3-建模、实现、写作"><a href="#3-建模、实现、写作" class="headerlink" title="3. 建模、实现、写作"></a>3. 建模、实现、写作</h4><p>数模比赛说到底就是让你解决一个实际问题，建立模型、实现模型、论文写作这就是比赛的流程，队友的职能也分为建模、编程、论文三个方向。简而言之，建模队友主要的工作是对于比赛的实际问题建立模型，将实际问题转化为数学问题。编程队友主要的工作是利用计算机软件求解建模队友转化的数字问题，例如方程等其他任何形式。而论文队友主要的工作是将建模与算法的过程与结果记录下来。三个方向缺一不可，个人觉得都十分重要。</p><p>需要注意的是，各队友之间的职能其实也并没有那么明确的界限，比如编程论文队友也可以参与建模，建模队友也可以辅助编程debug，建模编程队友最后也一定会参与审稿写作修改等。你可以专精一个方向，但其他的方向你最好也要会，这么复杂的工作流程，更加说明了前期找队友的重要性，认真努力才是你们找队友的第一指导性因素。</p><h3 id="三、-软件学习：比赛工具的使用"><a href="#三、-软件学习：比赛工具的使用" class="headerlink" title="三、 软件学习：比赛工具的使用"></a>三、 软件学习：比赛工具的使用</h3><p>这部分主要谈谈使用哪些软件，包括编程工具、写作工具、绘图工具等。</p><h4 id="1-编程工具"><a href="#1-编程工具" class="headerlink" title="1. 编程工具"></a>1. 编程工具</h4><blockquote><p>MATLAB</p><p>Python</p><p>C/C++</p><p>SPSS, Mathematics, Lingo</p></blockquote><p>不管是数模比赛还是以后做科研，MATLAB几乎是各专业必会的软件，提前学习总是没错的，我大一上花一周时间就学完了各种基本的操作，如矩阵命令，语法，解方程，画图等。对于比赛而言，大部分的方程求解，数据导出，结果图绘制都要靠MATLAB。这里我给大家推荐b站搜索MATLAB郭彦甫教程，当年我就是看着这个教程入门的，很适合新手非常快。Python和C/C++我就不多说了，在特定的时候，MATLAB的求解并不如Python和C++这种语言方便，这次美赛我们的主代码就是靠的Python求解模型的。SPSS、Mathematics和Lingo我对于这三个软件的使用也只是轻度的，可能在特定的时候，比如规划我可能会使用Lingo，但三个软件并不作为你主要学习的东西，比赛的时候需要解决什么问题，直接搜索对应命令即可。</p><h4 id="2-写作工具"><a href="#2-写作工具" class="headerlink" title="2. 写作工具"></a>2. 写作工具</h4><blockquote><p>Word</p><p>Latex</p></blockquote><p>主流的比赛写作软件就是这两个，国赛我们用的是Word模板，美赛是Latex，官方都认可。Latex是需要学习成本的，如果你参加了几次培训和比赛并准备参加美赛，我会建议你去学习它，因为Latex使用起来确实方便很多，包括你以后写毕设和研究生文章都能给你许多便利。写作工具的使用我不多说了，这方面我也只会一些简单的，不过完成一篇论文基本也没问题，很快就能上手。</p><h4 id="3-绘图工具"><a href="#3-绘图工具" class="headerlink" title="3. 绘图工具"></a>3. 绘图工具</h4><blockquote><p>PPT</p><p>Excel</p><p>Visio</p></blockquote><p>图形的绘制在比赛中的重要性不言而喻，美赛更是极为看重。你可能会想插图的设计难道不是用Ps或者Ai，ppt和excel怎么能干这个？给大家一个链接<a href="[https://levitate-qian.github.io/2020/05/04/10%E7%B1%BB%E6%A1%88%E4%BE%8B%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3%E8%AE%BA%E6%96%87%E6%8F%92%E5%9B%BE%E5%88%B6%E4%BD%9C/?tdsourcetag=s_pctim_aiomsg](https://levitate-qian.github.io/2020/05/04/10类案例带你了解论文插图制作/?tdsourcetag=s_pctim_aiomsg">10类案例带你了解论文插图制作</a>)</p><p>这是我的论文队友，对于所有比赛图形绘制的总结，包括结果图的美化，插图的设计等等，看完这篇文章，你可能会对ppt的功能产生翻天覆地的改观，容我说一句：微软牛逼！</p><p>Visio也是微软家的产品，我们主要用它来画流程图，来表示复杂的算法或者模型建立求解过程，非常容易上手。</p><h3 id="四、-书籍推荐：必不可少"><a href="#四、-书籍推荐：必不可少" class="headerlink" title="四、 书籍推荐：必不可少"></a>四、 书籍推荐：必不可少</h3><p>终于讲到了最后一个部分，那就是你需要看哪儿些书。我把我的书单整理了一下，因为我才参与数模比赛其实满打满算一年的时间，我选取了与数模有关的书籍，<strong>不包括我们课外看的书</strong>。</p><blockquote><ol><li>数学模型（第五版）姜启源高教社</li><li>数学建模方法及其应用（第三版）韩中庚高教社</li><li>MATLAB 数学建模方法与实践（第3 版）北京航空航天大学出版社</li><li>数学建模算法与应用（第2 版）国防工业出版社</li><li>数学建模方法与分析（第4 版）机械工业出版社</li><li>MATLAB 智能算法30 个案例分析（第2 版）北京航空航天大学出<br>版社</li></ol></blockquote><p>大概就是这六本书了，不过只能遗憾的告诉你们，这些书你们是无法看完或者说吃透的，即使你们半懵半懂翻完了一遍，也只是入门了，离做题还有距离。不过没有关系，即使我到现在也不敢说全部能够理解了。首先是姜启源老师的数学模型比较经典，基本初等模型都讲完了，这里希望大家注意，比赛并不会让你直接使用初等模型，一般没这个可能性。韩老师的数学模型书是我最喜欢的一本，给我更贴近数模比赛的感觉。</p><p>3~6主要是我这个编程队友看的了，3~5我觉得大家可以将它们作为工具书来翻找，当然你不可能能全部记下来，但是想要熟练使用工具书，能理解所有算法的意义与功能是前提。最后一本书大家也可以作为工具书，智能算法包括了遗传算法和退火蚁群这些，一般不建议使用这些神棍算法，但是也要视情况而定，多学习总没有坏处。</p><p>最后还有其他的各种课外书籍，举个例子，我大一下在研究周老师的《机器学习》，这次美赛我有个算法就用到了Lasso回归的思想，多看书积累，总是无害的。</p><p>哈哈哈，这个入门就写到这儿了，虽然都是被讲烂的东西，但还是要记录下，之后会更新更多实用的经验贴。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;哇！终于有时间来写这个入门参与数模的指导教程了，由于疫情原因一直没发开学，正好也来写点东西。在这次2020年国际数学建模竞赛中，我们队伍获得了特等O奖，并被美国INFORMS(运筹与管理学协会)冠名为当年D题全球最佳答卷，不得不说这次运气真的好，大概率应该是退役了吧。
    
    </summary>
    
    
      <category term="数学建模" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="入门指导" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%85%A5%E9%97%A8%E6%8C%87%E5%AF%BC/"/>
    
    
      <category term="数学建模" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
  </entry>
  
  <entry>
    <title>写在前面</title>
    <link href="http://yoursite.com/2020/02/13/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/"/>
    <id>http://yoursite.com/2020/02/13/%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2/</id>
    <published>2020-02-12T23:18:18.000Z</published>
    <updated>2020-05-08T15:33:13.800Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、聊聊OpenCV"><a href="#一、聊聊OpenCV" class="headerlink" title="一、聊聊OpenCV"></a>一、聊聊OpenCV</h3><p>计算机视觉应该是目前和自然语言处理一起在人工智能方向最火的领域，主要是因为这两个人工智能分支，是目前应用领域最广泛的。然而其实就目前时代而言，所有的人工智能研究生博士生都转向了这两个领域去研究，导致了公司岗位的过度饱和。但是实际情况是计算机视觉领域，工程师过剩，学术人才短缺。<a id="more"></a>我之前给大家推荐过一个学习线路：</p><ul><li>学习《机器学习》《深度学习》等内容。</li><li>认真研读几篇CV的paper。</li><li>了解CV方向的Alexnet，R-CNN，yolo系列等。</li><li>下载VOC，ImageNet，COCO，Kaggle开源数据集。</li><li>在github上准备几个CV的框架，例如pytorch，Tensorflow等，准备数据集来跑一下。</li></ul><p>做到以上几点，本科阶段那绝对都是高手了，大牛算不上，但是肯定比一般人要厉害了，但是如果说找工作岗位和未来更进一步，但肯定是不够的。因为以上内容其实很快就能学会了，我们真正要学会的，或者是难的东西永远是底层架构，不管是软件开发方向还是人工智能方向（<strong>当然也有工程师能特别厉害，充分利用资源等</strong>）。其实计算机视觉最底层的东西不是人工智能，而是图像处理，所以我认为计算机视觉要从图像处理开始学起，但是这些内容是更难啃的骨头，但是我相信如果坚持下来，之后的视觉学习会事半功倍。</p><h3 id="二、工具准备"><a href="#二、工具准备" class="headerlink" title="二、工具准备"></a>二、工具准备</h3><p>我来说说我目前的编译环境好了，其实ide方面我对于vscode一直情有独钟，基本靠他来写所有语言的代码，但是图像处理内容所用的Python库，很可惜在vscode上经常报错，查询了很多方法无法解决，于是我直接开始使用Anaconda，人家集成好的环境，更加方便，ide也改用了spyder。</p><h3 id="三、环境配置"><a href="#三、环境配置" class="headerlink" title="三、环境配置"></a>三、环境配置</h3><p>首先在官网上<a href="https://www.anaconda.com/download/" target="_blank" rel="noopener">https://www.anaconda.com/download/</a>下载anaconda环境配置包，大家下载安装全部默认即可。<br><strong>下载Anaconda不需要提前安装Python，安装了也没关系</strong></p><p>这时，电脑本地会多一个Anaconda3的文件夹，会有5个东西。<br><img src="https://i.loli.net/2020/02/12/pODNQ7M8itSGe1s.png" alt=""><br>我们需要来学习的有两个东西：<code>Anaconda Prompt</code> 和 <code>Spyder</code></p><blockquote><p>Anaconda Prompt就是相当于本地终端cmd，如果有Python基础的都知道，在安装Python库文件的时候我们通过使用终端的pip命令安装。<br>之前说了安装Anaconda不需要安装Python，但是如果安装了也要注意，这时候的你的电脑有两个环境，一个Python环境，一个Anaconda环境。<br>其中cmd的pip安装库是安装在了Python环境下，在Anaconda Prompt里面pip安装才在Anaconda环境下，换言之，在cmd里面使用pip install 的库，并不能在Anaconda下调用。<br>Spyder就是Anaconda自带的编译器，还是十分方便的。</p></blockquote><p>安装完Anaconda后，我们打开<code>Anaconda Prompt</code>，输入指令查看目录。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd Anaconda3  <span class="comment"># 进入Anaconda3文件夹，按照不用安装路径更改</span></span><br><span class="line">dir           <span class="comment"># 查看本目录下的配置文件</span></span><br><span class="line">python        <span class="comment"># 如果出现程序命令行状态，证明安装成功</span></span><br></pre></td></tr></table></figure><br><img src="https://i.loli.net/2020/02/13/gZw731GOUmsbQ8R.png" alt=""><br><img src="https://i.loli.net/2020/02/13/JcnFOe3DUoQjxfs.png" alt=""></p><p>然后我们进入Anaconda3目录下的Scripts文件夹，里面包含了Anaconda3的所有配置文件，然后我们查看下Anaconda给我们集成好的库文件。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd Scripts    <span class="comment"># 进入Scripts文件夹，查看配置文件</span></span><br><span class="line">pip list      <span class="comment"># 查看集成好的库文件</span></span><br></pre></td></tr></table></figure><br><img src="https://i.loli.net/2020/02/13/eCgGqT6uxkrOm8s.png" alt=""></p><p>下面我们来正式开始安装两个常用的CV库文件：<code>opencv-python</code>和<code>opencv-contrib-python</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install opencv-python</span><br><span class="line">pip install opencv-contrib-python</span><br></pre></td></tr></table></figure><p>然后验证下是否安装完成，进入Python环境。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">cv2.__version__   <span class="comment"># 查看版本号</span></span><br></pre></td></tr></table></figure><br><img src="https://i.loli.net/2020/02/13/N7xHXjvCrazfO9y.png" alt=""></p><p>至此，CV的库文件安装成功，在Spyder IDE中大家就可以直接调用了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、聊聊OpenCV&quot;&gt;&lt;a href=&quot;#一、聊聊OpenCV&quot; class=&quot;headerlink&quot; title=&quot;一、聊聊OpenCV&quot;&gt;&lt;/a&gt;一、聊聊OpenCV&lt;/h3&gt;&lt;p&gt;计算机视觉应该是目前和自然语言处理一起在人工智能方向最火的领域，主要是因为这两个人工智能分支，是目前应用领域最广泛的。然而其实就目前时代而言，所有的人工智能研究生博士生都转向了这两个领域去研究，导致了公司岗位的过度饱和。但是实际情况是计算机视觉领域，工程师过剩，学术人才短缺。
    
    </summary>
    
    
      <category term="图像处理与计算机视觉" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
      <category term="入门笔记整理" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/"/>
    
    
      <category term="计算机视觉" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
  </entry>
  
  <entry>
    <title>编程与人工智能推荐书目以及学习路线</title>
    <link href="http://yoursite.com/2020/02/12/%E7%BC%96%E7%A8%8B%E4%B8%8E%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%8E%A8%E8%8D%90%E4%B9%A6%E7%9B%AE%E4%BB%A5%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    <id>http://yoursite.com/2020/02/12/%E7%BC%96%E7%A8%8B%E4%B8%8E%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E6%8E%A8%E8%8D%90%E4%B9%A6%E7%9B%AE%E4%BB%A5%E5%8F%8A%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</id>
    <published>2020-02-11T22:12:21.000Z</published>
    <updated>2020-02-12T04:37:00.059Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、分享理由"><a href="#一、分享理由" class="headerlink" title="一、分享理由"></a>一、分享理由</h3><p>博主现在于西安电子科技大学读电子信息工程专业，这个专业在我们学校的研究方向为雷达天线这块嵌入式的内容，然而读大学以来其实我对于编程，软件开发以及人工智能方面的兴趣颇浓，甚于硬件部分。<a id="more"></a>所以考虑研究生转计算机研究方向，你要问我EE转CS是不是一种趋势，我只能说据我的了解，EE要比CS更加难读，在就业方面，CS近乎于饱和，EE就业竞争压力小，但是相反的EE夕阳产业也较多，但这并不算明显的劣势，主要还是我更对编程及数学方面感兴趣点，虽然EE的图像处理，模式识别和智能系统方向也是人工智能的分支，但我还是更喜欢软件的东西。去年我们学校西电发布的关于AI的论文在全国高校居第二位，仅次于清华，绝大部分都是图像处理方向的研究，我也参加了电子工程学院图像处理的实验室学习，之后也会分享学习内容。</p><p>说了这么多，作为研究生想转CS方向的本科生，我肯定是要学习CS的本科我们EE没学的知识，我们学校人工智能专业和我们专业本科学习科目基本相同，我也是课外看了一些书目，然后自己做了些整理。其实人工智能这方面更多靠的是兴趣来自学，比如cv这些方向内容，本科很少有这方面深入的课程，与EE大部分课程一样都是蜻蜓点水，只有读了研究生博士生和导师做项目锻炼实战的能力。下面主要来讲讲我的学习思路。</p><h3 id="二、编程语言类书籍"><a href="#二、编程语言类书籍" class="headerlink" title="二、编程语言类书籍"></a>二、编程语言类书籍</h3><h4 id="写在前面：“纸上得来终觉浅，绝知此事要躬行”-任何编程语言如果说光看书都只是个笑话，一定要动手实战训练才能到到看的效果，github上面有无数经典的实战项目可供我们上手练习。"><a href="#写在前面：“纸上得来终觉浅，绝知此事要躬行”-任何编程语言如果说光看书都只是个笑话，一定要动手实战训练才能到到看的效果，github上面有无数经典的实战项目可供我们上手练习。" class="headerlink" title="写在前面：“纸上得来终觉浅，绝知此事要躬行” 任何编程语言如果说光看书都只是个笑话，一定要动手实战训练才能到到看的效果，github上面有无数经典的实战项目可供我们上手练习。"></a><strong>写在前面：“纸上得来终觉浅，绝知此事要躬行” 任何编程语言如果说光看书都只是个笑话，一定要动手实战训练才能到到看的效果，github上面有无数经典的实战项目可供我们上手练习。</strong></h4><h4 id="1-C语言"><a href="#1-C语言" class="headerlink" title="1. C语言"></a>1. C语言</h4><p>作为大学的第一门编程语言，和我小学时候学的basic编程语言相似，对我而言上手还是轻松的，但是想深入的学习C语言的难点，比如指针，内存管理，谭浩强的教学书籍肯定是不够的，所以这里我推荐额外的三本书。</p><ul><li><p><strong>C语言程序设计现代方法</strong><br><img src="https://tse3-mm.cn.bing.net/th/id/OIP.lIHIbM-8IrjdoUtBuEYANAAAAA?w=132&h=176&c=7&o=5&dpr=1.5&pid=1.7" alt=""><br>这本书是我用来自学的书，个人感觉还不错，更加适合小白入门，内容通俗易懂。</p></li><li><p><strong>C Primer Plus</strong><br><img src="https://tse1-mm.cn.bing.net/th/id/OIP.oyCOuxWBzqHmptlXd9_MjwHaHa?w=201&h=201&c=7&o=5&dpr=1.5&pid=1.7" alt=""><br>经典中的经典，这个不用多说，应该是内容最全的C语言书籍了，但是内容并不是十分新手向，然而对于学习C语言中难的部分有重大的好处。</p></li><li><p><strong>C HOW TO PROGRAM</strong><br><img src="https://tse4-mm.cn.bing.net/th/id/OIP.iL8C_emJBwxaJxy7bBahHQHaJq?w=138&h=181&c=7&o=5&dpr=1.5&pid=1.7" alt=""><br>这本书现在也有中文版了，中文名为C语言大学教程，是学长推荐的书籍，这本书也是我最喜欢的一本，里面的代码以及风格非常吸引人，充分体现了编程语言之美的特点，书里还包括一些C语言高级的操作以及实战，个人非常喜欢。</p></li></ul><h4 id="2-C"><a href="#2-C" class="headerlink" title="2. C++"></a>2. C++</h4><p>C++在上大学前也接触过但是不多，停留在基础语法方面，在大一学C的过程中顺便学了C++，讲真学了C++再也不想用C编程了，特别是大二学习数据结构，用C写了几百行代码，内心哭着想明明C++一个库文件就能搞定了啊。除了硬件编程，使用汇编和C之外，C++应该是使用最广泛地语言了，不管是Python或者Matlab开发的底层库大部分都是基于C++的，学好C++比只学一门Python更重要。</p><ul><li><strong>C++ Primer Plus</strong><br><img src="https://tse2-mm.cn.bing.net/th/id/OIP.NchuvFN-tGgIBKpGK_fpJAAAAA?w=146&h=207&c=7&o=5&dpr=1.5&pid=1.7" alt=""><br>这本书也是经典中的经典，其实挺适合初学者的，还有一本书C++ Prime少个plus，个人觉得差别不是很大，基本上吃透这本书，C++就没啥问题了，更多的还是需要实战，C++比C更高级不光在语法还有各种库文件，灵活使用，C++将比C简洁许多。</li></ul><h4 id="3-Java"><a href="#3-Java" class="headerlink" title="3. Java"></a>3. Java</h4><p>Java也是我大一特别喜欢的一门语言，作为后端的老大，任何软件开发项目都需要Java来搭建网络框架，不做多的介绍，如果你的兴趣是软件开发研究，这就是必学的语言。</p><ul><li><strong>Java编程思想</strong><br><img src="https://tse3-mm.cn.bing.net/th/id/OIP.XgDm2k8XNgH8Z2Fk9iRVLgAAAA?w=139&h=196&c=7&o=5&dpr=1.5&pid=1.7" alt=""><br>这本书是java经典中的经典，作为后端老大，java更多的还是靠项目实战。</li></ul><h4 id="4-Python"><a href="#4-Python" class="headerlink" title="4. Python"></a>4. Python</h4><p>Python是近几年最火的编程语言，这是我大一下的一门课，Python方面我只推荐一本书，因为我觉得Python看书真的不是最重要的事情，Python编程讲究的是简洁以及快捷，配合它的各种库，它几乎是能做所有事情的工具。但是请注意，它是工具，配合上Python的库，它可以Excel分析，网络爬虫，人脸识别，机器学习深度学习，图像处理等等内容，在暑假我浏览Python底层文件库的时候，我竟然还发现Python也能写arduino单片机了，并且不管是前端后端，Python也可以参与开发工作。及至到此，你可能觉得学好了Python可以打遍天下了，但是必然不是，光学好Python反而在以后很不受待见，主要是Python门槛低见效高，各类培训机构更是抓住这样的机会大把捞钱，其实10几天成为Python工程师，也只是学会了调包。综上，Python可以作为你增值的最好工具，但是不能是你唯一的语言。</p><ul><li><strong>Python编程从入门到实践</strong><br><img src="https://tse2-mm.cn.bing.net/th/id/OIP.RoW031enRzgYeDbZaifGSQHaHa?w=182&h=180&c=7&o=5&dpr=1.5&pid=1.7" alt=""><br>这本书基本上就是我寒假入门的书，基于Python3，我觉得入门很好，语法讲全了也很透彻，后面还有关于一个做飞机游戏的实战，用到了matplotlib和pygame库，学习Python，语法和算法并不是最重要的，重要的是学习如何安装库，调用库，使用库来实现你的功能。</li></ul><h4 id="5-GoLang"><a href="#5-GoLang" class="headerlink" title="5. GoLang"></a>5. GoLang</h4><p>Go语言是我闲暇带着学的语言，它是新出来的一门语言，Go语言市面上没有啥经典的书，所以我只推荐一本书。</p><ul><li><strong>Go语言实战</strong><br><img src="https://tse3-mm.cn.bing.net/th/id/OIP.UM3pnGA88svvkQALU3I-RgAAAA?w=197&h=197&c=7&o=5&dpr=1.5&pid=1.7" alt=""><br>Go语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。</li></ul><h4 id="写在最后：我只是兴趣才涉及了这5门语言，实际上没必要，看自己以后的研究方向，决定深入学习哪儿种语言。"><a href="#写在最后：我只是兴趣才涉及了这5门语言，实际上没必要，看自己以后的研究方向，决定深入学习哪儿种语言。" class="headerlink" title="写在最后：我只是兴趣才涉及了这5门语言，实际上没必要，看自己以后的研究方向，决定深入学习哪儿种语言。"></a><strong>写在最后：我只是兴趣才涉及了这5门语言，实际上没必要，看自己以后的研究方向，决定深入学习哪儿种语言。</strong></h4><h3 id="三、数据结构与算法类书籍"><a href="#三、数据结构与算法类书籍" class="headerlink" title="三、数据结构与算法类书籍"></a>三、数据结构与算法类书籍</h3><p>光学会语言肯定是不够的，语言是实现工具，要想真正使它起到重要作用，计算机数据结构和经典算法也必须掌握。</p><ul><li><p><strong>算法导论</strong><br><img src="https://tse1-mm.cn.bing.net/th/id/OIP.e1_aiovnGSX9QGjdXIiceAHaKD?w=139&h=189&c=7&o=5&dpr=1.5&pid=1.7" alt=""><br>“年轻人，来感受力量吧。”算法导论是算法中的经典书籍，但是需要深厚的数学功底，以及学习过数据结构的知识，才能感受到其中的力量。</p></li><li><p><strong>算法</strong><br><img src="https://tse1-mm.cn.bing.net/th/id/OIP.xzUf8h_as43rg9W74PlQYQAAAA?w=217&h=213&c=7&o=5&dpr=1.5&pid=1.7" alt=""><br>与算法导论那本书买错了，我当时看着算法导论，就哭了。算法第四版是我们学校计科专业的用书，这本书还是比算法导论友善很多的。</p></li><li><p><strong>数据结构</strong><br><img src="https://tse1-mm.cn.bing.net/th/id/OIP.JXZV2FgQ5DHpHs4fbHCQ5QAAAA?w=208&h=208&c=7&o=5&dpr=1.5&pid=1.7" alt=""><br>说实话这本书实在不适合初学者，我大一基本是面向csdn在看这本书，但是这本书对于学习所有数据结构内容又是经典，建议结合github上现成的数据结构代码来看。</p></li></ul><h3 id="四、计算机知识类书籍"><a href="#四、计算机知识类书籍" class="headerlink" title="四、计算机知识类书籍"></a>四、计算机知识类书籍</h3><p>非计算机科班出身想转CS的必读书目，简而言之，就是人家的本科知识，我也整理了些不在计算机大类基础中的书籍，这些内容是关于计算机底层以及系统类的知识。</p><h4 id="1-计算机网络类"><a href="#1-计算机网络类" class="headerlink" title="1. 计算机网络类"></a>1. 计算机网络类</h4><p>计算机网络是计算机知识中非常重要，但是十分枯燥的部分，我推荐三本书，一本轻松，两本硬核。</p><ul><li><p><strong>图解HTTP</strong><br><img src="https://tse1-mm.cn.bing.net/th/id/OIP.ZiS7EuKRoNJu2aZKigCcBQHaJ4?w=160&h=204&c=7&o=5&dpr=1.5&pid=1.7" alt=""><br>这本书是俱乐部推荐学习web端知识的，是我最喜欢的书，主要是生动形象，通俗易懂，建议web小白学习，非常有趣。</p></li><li><p><strong>TCP/IP详解</strong><br><img src="https://tse4-mm.cn.bing.net/th/id/OIP.VzusU2dkDc9Ntd6RjkJDAQAAAA?w=216&h=208&c=7&o=5&dpr=1.5&pid=1.7" alt=""><br>这本书是学习计算机网络特别经典的书籍，计算机网络狭义而言就是TCP/IP协议，但这本书比较晦涩难懂，需要基础知识。</p></li><li><p><strong>计算机网络 自顶向下的方法</strong><br><img src="https://tse2-mm.cn.bing.net/th/id/OIP.jefPCQYLnhgPTsRWDfpnSwD6D6?w=205&h=205&c=7&o=5&dpr=1.5&pid=1.7" alt=""><br>这本书比起上本书稍微好懂一点，但也只是稍微，计算机网络本身就是枯燥的东西，个人还是更推荐上一本。</p></li></ul><h4 id="2-Linux系统类"><a href="#2-Linux系统类" class="headerlink" title="2. Linux系统类"></a>2. Linux系统类</h4><p>Linux系统应该不用多说他的重要性了吧，基本上90%的项目都是在Linux开发的，所以学好Linux真的非常重要。我推荐两本经典的书。</p><ul><li><p><strong>鸟哥的Linux私房菜</strong><br><img src="https://tse2-mm.cn.bing.net/th/id/OIP.QQ9ADeGcN6sCfSmAFbZmAQAAAA?w=212&h=213&c=7&o=5&dpr=1.5&pid=1.7" alt=""><br>这本书包含了几乎所有Linux命令，我推荐作为工具书使用，但是务必要熟悉其内容。</p></li><li><p><strong>UNIX环境高级编程</strong><br><img src="https://tse3-mm.cn.bing.net/th/id/OIP.Y6wj4wINzpyuKDJGY7HHqQAAAA?w=145&h=202&c=7&o=5&dpr=1.5&pid=1.7" alt=""><br>上本书基本上是在说Linux环境的使用，而这本书就是关于在环境下编程开发的。</p></li></ul><h4 id="3-数据库类"><a href="#3-数据库类" class="headerlink" title="3. 数据库类"></a>3. 数据库类</h4><ul><li><strong>MySQL必知必会</strong><br><img src="https://tse2-mm.cn.bing.net/th/id/OIP.gX2nuq_9D7LzgBDEvEc_wgAAAA?w=159&h=160&c=7&o=5&dpr=1.5&pid=1.7" alt=""><br>数据库方面就推荐这一本书，毕竟这本书讲解的已经十分全面了，不做额外的推荐。</li></ul><h3 id="五、人工智能类书籍"><a href="#五、人工智能类书籍" class="headerlink" title="五、人工智能类书籍"></a>五、人工智能类书籍</h3><p>AI是最近几年火到爆的一个话题，至于有没有必要投身于，这个就智者见智仁者见仁了。我这里推荐的也只是入门级的经典书籍，其实人工智能大部分方向都是纯数学类，真正需要计算机编程的，是应用实践与产品落地。首先，看以下的书我们需要有些数学的准备知识。</p><blockquote><p>统计学<br>线性代数</p></blockquote><p>以上两个内容我不做推荐的，但是统计学和线性代数加在一起，几乎就是整个机器学习的知识，所以还是非常重要的。</p><h4 id="1-人工智能简介类"><a href="#1-人工智能简介类" class="headerlink" title="1. 人工智能简介类"></a>1. 人工智能简介类</h4><ul><li><strong>人工智能</strong><br><img src="https://tse3-mm.cn.bing.net/th/id/OIP.oilZ7dR4jCecof11jNkaXwAAAA?w=185&h=180&c=7&o=5&dpr=1.5&pid=1.7" alt=""><br>这里推荐下李开复教授的书籍，对于想学人工智能的同学可以先了解了解。</li></ul><h4 id="2-机器学习类"><a href="#2-机器学习类" class="headerlink" title="2. 机器学习类"></a>2. 机器学习类</h4><p>机器学习是人工智能最基础的部分，其实看过机器学习的内容后，还是会发现机器学习基本都是数学类的内容，再具体一点，就是统计学，所以数学真的非常重要。</p><ul><li><p><strong>机器学习</strong><br><img src="https://tse1-mm.cn.bing.net/th/id/OIP.eaoccMazmKDdfUylonVQDAAAAA?w=175&h=205&c=7&o=5&dpr=1.5&pid=1.7" alt=""><br>这本书包含了几乎所有著名的机器学习模型，详细讲解其原理，缺点是没有代码，不过把它作为入门类书籍还是可以的，另外大家也可以结合吴恩达的课程一起学习。</p></li><li><p><strong>Scikit-Learn与TensorFlow机器学习实用指南</strong><br><img src="https://tse3-mm.cn.bing.net/th/id/OIP.OJhiUZi0-LetLWUPbIyboAAAAA?w=126&h=166&c=7&o=5&dpr=1.5&pid=1.7" alt=""><br>Amazon销售量第一，这本书就是关于机器学习的实战部分内容了，源码已经在github上开源了。</p></li></ul><h4 id="3-深度学习类"><a href="#3-深度学习类" class="headerlink" title="3. 深度学习类"></a>3. 深度学习类</h4><p>深度学习和神经网络的知识大家其实可以一起学习，没必要再分细致，了解其数学背景才是关键的事情。</p><ul><li><p><strong>深度学习</strong><br><img src="https://tse1-mm.cn.bing.net/th/id/OIP.-LzszgWLjsZrbL3hMkYrRQHaJ9?w=144&h=193&c=7&o=5&dpr=1.5&pid=1.7" alt=""><br>花书，圣经，深度学习经典材料，厚度感人，十分经典不做过多的介绍，反正学习路上绕不开这本书。</p></li><li><p><strong>Deep Learning with Python</strong><br><img src="https://tse3-mm.cn.bing.net/th/id/OIP.Gs2KxopjWL5fSlSpMYGKigAAAA?w=129&h=161&c=7&o=5&dpr=1.5&pid=1.7" alt=""><br>这本书真的很适合小白入门，用的工具是Keras，作为TensorFlow的high level API，不那么复杂的Python编程，所有较为容易的上手实践项目，这本书好像没有中文版的，但是真的很有意思，另外这本书缺点就是不够深入，几乎没有数学公式和原理，当然这也是他不复杂的原因。</p></li></ul><h3 id="六、学习路线"><a href="#六、学习路线" class="headerlink" title="六、学习路线"></a>六、学习路线</h3><p>推荐了这么多，我来讲讲学习路线，以上的书我也不可能全部看完的，但是这些书在学生时代看看，有利无弊。以下是我整理的方向。</p><h4 id="1-软件开发方向"><a href="#1-软件开发方向" class="headerlink" title="1. 软件开发方向"></a>1. 软件开发方向</h4><ul><li>编程语言类书籍选择C++，Python，Java作为主要语言来看。</li><li>计算机网络类的书那是必须要掌握的。</li><li>接下来就可以再细分了，软件开发还分前端，后端，全栈。大家可以先去了解这些方向，再选择用书，比如后端可以选择最近很火的Spring框架的书来看，这里不做详细推荐。</li></ul><h4 id="2-人工智能方向"><a href="#2-人工智能方向" class="headerlink" title="2. 人工智能方向"></a>2. 人工智能方向</h4><ul><li>编程语言类书籍选择C++，Python作为主要语言。</li><li>计算机网络最好了解。</li><li>人工智能类必看。</li><li>结合吴恩达的机器学习和深度学习的课程。</li><li>阅读人工智能方向的paper，了解典型的，例如cv方向的Alexnet，R-CNN，yolo系列等。</li><li>下载VOC，ImageNet，COCO，Kaggle开源数据集。</li><li>了解人工智能基本模型框架，例如pytorch，Tensorflow等，准备数据集来跑一下。</li></ul><hr><p><strong>我觉得以上内容作为本科学习绝对足够了，我也不知道我以后具体会研究什么方向，所以趁学生时代，还是先读书吧。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、分享理由&quot;&gt;&lt;a href=&quot;#一、分享理由&quot; class=&quot;headerlink&quot; title=&quot;一、分享理由&quot;&gt;&lt;/a&gt;一、分享理由&lt;/h3&gt;&lt;p&gt;博主现在于西安电子科技大学读电子信息工程专业，这个专业在我们学校的研究方向为雷达天线这块嵌入式的内容，然而读大学以来其实我对于编程，软件开发以及人工智能方面的兴趣颇浓，甚于硬件部分。
    
    </summary>
    
    
      <category term="经验分享" scheme="http://yoursite.com/categories/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="经验分享" scheme="http://yoursite.com/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>Matlab安装教程</title>
    <link href="http://yoursite.com/2020/02/12/Matlab%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/02/12/Matlab%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</id>
    <published>2020-02-11T21:11:42.000Z</published>
    <updated>2020-05-08T15:33:59.988Z</updated>
    
    <content type="html"><![CDATA[<h4 id="以下教程仅适用于win10环境，安装以Matlab-2017b为例"><a href="#以下教程仅适用于win10环境，安装以Matlab-2017b为例" class="headerlink" title="以下教程仅适用于win10环境，安装以Matlab 2017b为例"></a>以下教程仅适用于win10环境，安装以Matlab 2017b为例</h4><h3 id="一、Matlab的作用"><a href="#一、Matlab的作用" class="headerlink" title="一、Matlab的作用"></a>一、Matlab的作用</h3><p>因为博主本科在校期间参与数学建模竞赛，并作为编程队员，Matlab是必须掌握的编程语言。在数学建模竞赛中，Matlab主要发挥的作用包括数学计算，模型求解以及可视化图形绘制。<a id="more"></a>其实除此之外，Matlab更是所有工科专业所必须的模型仿真以及参数调制的软件，它几乎能实现问题的求解，包括电磁场分解，神经网络，视屏图像处理等等功能。今天我们来详细讲解Matlab的安装。</p><h3 id="二、软件准备"><a href="#二、软件准备" class="headerlink" title="二、软件准备"></a>二、软件准备</h3><p>本文采取种子下载的方式，较安全。<br>Torrent种子下载器的百度网盘链接：</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1O0rRAlQM6nfsQTxsaNgxOg" target="_blank" rel="noopener">https://pan.baidu.com/s/1O0rRAlQM6nfsQTxsaNgxOg</a><br>提取码：0ubq</p></blockquote><p>Matlab2018b种子文件(持续更新)</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1uTsnFpCbfc5Te5gX2LFCsQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1uTsnFpCbfc5Te5gX2LFCsQ</a><br>提取码：ed74</p></blockquote><p>下载解压后，将种子放进Torrent下载器中下载后，本地上有三个文件。<br><img src="https://images2018.cnblogs.com/blog/1377919/201806/1377919-20180606212719529-257398164.png" alt=""><br>两个光盘安装文件，一个破解文件。</p><h3 id="三、正式安装"><a href="#三、正式安装" class="headerlink" title="三、正式安装"></a>三、正式安装</h3><ol><li>点击dvd1的exe文件。</li><li>选择<code>使用文件安装秘钥</code>，点击<code>下一步</code>。<br><img src="https://images2018.cnblogs.com/blog/1377919/201806/1377919-20180606212746326-843939953.png" alt=""></li><li>允许用户协议，选择<code>是</code>，点击<code>下一步</code>。<br><img src="https://images2018.cnblogs.com/blog/1377919/201806/1377919-20180606212812111-1863935724.png" alt=""></li><li>选择<code>我已有我的许可证的文件安装秘钥</code>，输入序列号<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">09806</span><span class="number">-07443</span><span class="number">-53955</span><span class="number">-64350</span><span class="number">-21751</span><span class="number">-41297</span></span><br></pre></td></tr></table></figure><img src="https://images2018.cnblogs.com/blog/1377919/201806/1377919-20180606212917786-104551208.png" alt=""></li><li>接下来按照默认即可，点击安装，等待安装完成。<br><img src="https://images2018.cnblogs.com/blog/1377919/201806/1377919-20180606213247371-1135438213.jpg" alt=""></li><li>安装到一半会出现下面情况，点击确定。<br><img src="https://images2018.cnblogs.com/blog/1377919/201806/1377919-20180606213300771-502055264.png" alt=""></li><li>我们到此电脑目录下，弹出DVD1，并继续安装dvd2的文件即可，到此安装文件进度条可到100%。<strong>安装完成</strong></li></ol><h3 id="四、软件破解"><a href="#四、软件破解" class="headerlink" title="四、软件破解"></a>四、软件破解</h3><ol><li>解压破解文件夹，打开破解文件夹的<code>R2017b</code>，将破解的补丁文件<code>bin</code>复制到安装目录<code>/MATLAB/R2017b/</code>下覆盖原文件。<br><img src="https://images2018.cnblogs.com/blog/1377919/201806/1377919-20180606213336258-1057227094.png" alt=""></li><li>将破解文件夹下的<code>license_server.lic</code>和<code>license_standalone.lic</code>复制到安装目录<code>/MATLAB/R2017b/licenses</code>下覆盖原文件。<br><img src="https://images2018.cnblogs.com/blog/1377919/201806/1377919-20180606213404125-168800029.png" alt=""></li></ol><h3 id="五、软件激活"><a href="#五、软件激活" class="headerlink" title="五、软件激活"></a>五、软件激活</h3><ol><li>点击<code>/bin/win64/</code>里面的<code>active_matlab</code>,进行激活。<br><img src="https://images2018.cnblogs.com/blog/1377919/201806/1377919-20180606213424537-1031916014.png" alt=""></li><li>选择<code>在不使用Internet的情况下手动激活</code>。<br><img src="https://images2018.cnblogs.com/blog/1377919/201806/1377919-20180606213501889-548808556.png" alt=""></li><li>然后在<code>输入许可文件的完整安装路径</code>的选项下选择文件<code>license_standalone.lic</code>。<br><img src="https://images2018.cnblogs.com/blog/1377919/201806/1377919-20180606213537839-972029521.png" alt=""></li><li>点击<code>下一步</code>，激活完成。</li></ol><h3 id="六、Matlab推荐材料"><a href="#六、Matlab推荐材料" class="headerlink" title="六、Matlab推荐材料"></a>六、Matlab推荐材料</h3><ol><li>视屏教学材料，台大的郭彦甫老师授课，讲解清晰透彻，适合刚入门的小白学习，14讲内容，看完理解之后，基本内容就没有问题了，考虑到国内无法观看youtube平台的视屏，所以我选择了b站上别的up主搬运的视屏。<a href="https://www.bilibili.com/video/av68228488?from=search&amp;seid=10223858992775987688" target="_blank" rel="noopener">https://www.bilibili.com/video/av68228488?from=search&amp;seid=10223858992775987688</a></li><li>MATLAB2018从入门到精通，关于matlab的知识十分全面，可以与视屏配套使用。<br><img src="https://tse3-mm.cn.bing.net/th/id/OIP.q_AHtHnA6emmUEbVW7CSlAAAAA?w=188&amp;h=188&amp;c=7&amp;o=5&amp;dpr=1.5&amp;pid=1.7" alt=""></li><li>MATLAB智能算法30个案例分析，这里面有许多高级的算法，遗传算法，蚁群算法，退火算法，可以作为进阶教材学习。<br><img src="https://tse4-mm.cn.bing.net/th/id/OIP.2vHN_wwhiwgI4uYi5x2APQAAAA?w=202&amp;h=202&amp;c=7&amp;o=5&amp;dpr=1.5&amp;pid=1.7" alt=""></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;以下教程仅适用于win10环境，安装以Matlab-2017b为例&quot;&gt;&lt;a href=&quot;#以下教程仅适用于win10环境，安装以Matlab-2017b为例&quot; class=&quot;headerlink&quot; title=&quot;以下教程仅适用于win10环境，安装以Matlab 2017b为例&quot;&gt;&lt;/a&gt;以下教程仅适用于win10环境，安装以Matlab 2017b为例&lt;/h4&gt;&lt;h3 id=&quot;一、Matlab的作用&quot;&gt;&lt;a href=&quot;#一、Matlab的作用&quot; class=&quot;headerlink&quot; title=&quot;一、Matlab的作用&quot;&gt;&lt;/a&gt;一、Matlab的作用&lt;/h3&gt;&lt;p&gt;因为博主本科在校期间参与数学建模竞赛，并作为编程队员，Matlab是必须掌握的编程语言。在数学建模竞赛中，Matlab主要发挥的作用包括数学计算，模型求解以及可视化图形绘制。
    
    </summary>
    
    
      <category term="实用工具" scheme="http://yoursite.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="Matlab" scheme="http://yoursite.com/tags/Matlab/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客搭建教程</title>
    <link href="http://yoursite.com/2020/02/11/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/02/11/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</id>
    <published>2020-02-10T18:27:23.000Z</published>
    <updated>2020-05-08T15:33:50.805Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、-hexo博客的作用"><a href="#一、-hexo博客的作用" class="headerlink" title="一、 hexo博客的作用"></a>一、 hexo博客的作用</h3><p>博客就像一个人公开的日记一般，可以记录很多包括生活学习在内的诸多事情，作为IT的学生，拥有一个属于自己的博客，也将是未来校招或研究生面试重要的加分项。<br><a id="more"></a></p><h3 id="二、-教程内容"><a href="#二、-教程内容" class="headerlink" title="二、 教程内容"></a>二、 教程内容</h3><p>本文将带你从0开始，根据以下5个内容，搭建属于自己的hexo博客。</p><ul><li><ol><li>部署环境</li></ol></li><li><ol><li>初始化个人博客</li></ol></li><li><ol><li>markdown写博客</li></ol></li><li><ol><li>通过github把博客部署到远端</li></ol></li><li><ol><li>设置博客主题</li></ol></li></ul><h3 id="三、-博客搭建"><a href="#三、-博客搭建" class="headerlink" title="三、 博客搭建"></a>三、 博客搭建</h3><h4 id="1-软件准备"><a href="#1-软件准备" class="headerlink" title="1. 软件准备"></a>1. 软件准备</h4><blockquote><p>node.js<br>git工具</p></blockquote><p>首先需要下载<code>nodejs</code>，我们可以去<a href="https://nodejs.org/" target="_blank" rel="noopener">https://nodejs.org/</a>下载<br><img src="https://i.loli.net/2020/02/11/EuDAUeitgs1L3jm.png" alt="nodejis"><br>下载完按照其默认安装即可。<br>下载安装完之后，本地就有了两个组件：<code>nodejs</code>和<code>npm</code>。</p><p>下面我们下载git工具，直接在官网上下载即可。<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">https://git-scm.com/download/win</a><br>和nodejs一样根据他的提示下载安装。<br>安装完成后，本地将会有三个东西：<code>Git Gui</code> <code>Git cmd</code> <code>Git Bash</code><br>我们打开<code>Git Bash</code>输入以下指令，来设置自己的用户名和邮箱<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --<span class="keyword">global</span> user.name <span class="string">"nameVal"</span>   <span class="comment"># 全局配置自己的用户名</span></span><br><span class="line">git config --<span class="keyword">global</span> user.email <span class="string">"emailVal"</span> <span class="comment"># 全局配置自己的邮箱</span></span><br></pre></td></tr></table></figure><br>配置完之后我们可以确认下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list  <span class="comment"># 查看git配置信息</span></span><br></pre></td></tr></table></figure><br>以上便是hexo博客搭建的软件准备了，下面我们开始部署环境。</p><h4 id="2-环境部署"><a href="#2-环境部署" class="headerlink" title="2. 环境部署"></a>2. 环境部署</h4><p>打开电脑终端<code>cmd</code>，在<code>shell</code>中输入命令<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v <span class="comment"># 查看nodejs版本</span></span><br><span class="line">npm -v  <span class="comment"># 查看npm版本</span></span><br></pre></td></tr></table></figure><br>查看无误后，下面开始在终端输入命令，安装hexo博客框架。<br>由于国内<code>npm</code>安装速度问题，我们可以通过淘宝镜像换成<code>cnpm</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.taobao.org</span><br><span class="line"><span class="comment"># 安装完成之后可以查看版本来验证安装成功</span></span><br><span class="line">cnpm -v</span><br></pre></td></tr></table></figure><br>这样<code>cnpm</code>安装完成，接下来安装hexo。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br><span class="line"><span class="comment"># 安装完成后同样查看下版本</span></span><br><span class="line">hexo -v</span><br></pre></td></tr></table></figure><br>以上便是hexo博客的环境部署，非常方便。</p><h4 id="3-初始化个人博客"><a href="#3-初始化个人博客" class="headerlink" title="3. 初始化个人博客"></a>3. 初始化个人博客</h4><p>下面我们在<code>cmd</code>的默认路径下<code>C:\Users\nameVal&gt;</code>下新建一个文件夹，名为blog(名字当然随便取)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir blog</span><br></pre></td></tr></table></figure><br>然后我们在本地就能看到一个新的文件夹blog，我们的所有配置都在此文件夹下面。<br>然后我们在<code>cmd</code>中进入blog这个目录下面<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd blog</span><br></pre></td></tr></table></figure><br>下面开始初始化博客<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init  <span class="comment"># 需要一些时间等待</span></span><br></pre></td></tr></table></figure><br>经过等待之后，博客已经搭建完成。大家可以进入blog文件夹查看生成的配置文件。然后我们启动博客预览。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s <span class="comment"># hexo s==hexo server意思是启动本地服务器</span></span><br></pre></td></tr></table></figure><br>然后我们在本地服务器中输入<code>cmd</code>中提示的4000端口就可以看到自己的博客了。<br><img src="https://i.loli.net/2020/02/11/ms53VpJQgfMWRcO.png" alt=""><br><code>hexo s</code>一般是在本地作为博客预览的一个命令。</p><h4 id="4-markdown写博客"><a href="#4-markdown写博客" class="headerlink" title="4. markdown写博客"></a>4. markdown写博客</h4><p>下面我们就要开始在我们的hexo博客下写博客了。我们首先需要创建一篇新的博客，在blog目录下输入命令。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo n <span class="string">"我的第一篇博客"</span>  <span class="comment"># 引号内写博客的标题</span></span><br></pre></td></tr></table></figure><br>然后在<code>blog/source/_posts/</code>的目录下就能找到我们创建的第一篇博客的markdown文件。<br>markdown格式是程序员常用写博客的方式，markdown的语法十分简单。<br>给大家markdown的菜鸟教程<a href="https://www.runoob.com/markdown/md-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/markdown/md-tutorial.html</a><br>基本上里面的语法就能解决常用的问题了，如果有里面没有的，要善用搜索引擎。<br>完成博客内容后，我们首先要在本地预览此篇博客的内容，写完之后打开<code>cmd</code>终端，在blog目录下输入两个命令。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g <span class="comment"># hexo g==hexo generate生成博客</span></span><br><span class="line">hexo s <span class="comment"># 在本地服务器上启动</span></span><br></pre></td></tr></table></figure><br>这是我们刷新本地服务器地址，就能看到我们的博客了。</p><h4 id="5-通过github把博客部署到远端"><a href="#5-通过github把博客部署到远端" class="headerlink" title="5. 通过github把博客部署到远端"></a>5. 通过github把博客部署到远端</h4><p><code>local:4000</code>作为我们本地的测试端，但是我们的博客内容不可能仅仅在本地用，所以我们需要把它部署到远端去。<br>github是一种非常稳定的方式，以后我们只要通过github的方式来访问我们的博客就可以了，而且此方法免费。<br><strong>当然大家也可以购买阿里云服务器，为自己的博客地址更改域名，这就看个人需求了</strong><br>ps：如果你还没有github账号，请赶紧注册<a href="https://www.github.com/" target="_blank" rel="noopener">https://www.github.com/</a>，这可是程序员乃至所有工科生必备神器，以及最大的同性交友网站gayhub(滑稽)。<br>下面打开自己的github，我们首先新建一个仓库(new repository)。<br><img src="https://i.loli.net/2020/02/11/5SoyteL4BYb3pnR.png" alt=""><br>用户部署个人博客的github仓库的命名必须要与你的用户名一致才行。如下图所示，因为我的博客已经部署好了，所以它会提示已存在。<br><img src="https://i.loli.net/2020/02/11/QMuhEzAomG4lc2S.png" alt=""><br>然后按照默认的点击<code>create repository</code>就行了。这现在是个空仓库，这是我们部署的博客地址<a href="https://Alpha-Yang.github.io" target="_blank" rel="noopener">https://Alpha-Yang.github.io</a><br><img src="https://i.loli.net/2020/02/11/mikay2LEFxNPHvd.png" alt=""><br>下面我们先不管它，打开终端命令行<code>cmd</code>下载git插件。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install --save hexo deployer-git</span><br></pre></td></tr></table></figure><br>然后我们需要设置其配置文件，在<code>blog/</code>目录下找到配置文件<code>_config.yml</code>，用notepad或vim等记事本工具将其打开，更改该文件底部Deployment的内容。<br><img src="https://i.loli.net/2020/02/11/bNcDdlqYVOIJ5gL.png" alt=""><br>最后一步，我们将博客部署到远端，打开<code>cmd</code>终端。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d <span class="comment"># hexo d=hexo deployer部署到远端</span></span><br></pre></td></tr></table></figure><br>这时候输入你的github账号及密码(<strong>这里注意你的密码不会显示出来，所以输入即可</strong>)<br>这时候你会发现的仓库多了很多东西，然后把我们的仓库名拿出来访问，即<a href="https://alpha-yang.github.io" target="_blank" rel="noopener">https://alpha-yang.github.io</a><br>就能看到我们的博客被部署到github上了，这样的话博客的部署工作也就完成了。所以我们今后使用hexo的命令基本为五个，这里我做下整理。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo n <span class="string">"博客名"</span>   <span class="comment"># 新建一篇博客</span></span><br><span class="line">hexo g           <span class="comment"># 博客内容生成</span></span><br><span class="line">hexo s           <span class="comment"># 启动本地服务器，预览更改后的博客</span></span><br><span class="line">hexo d           <span class="comment"># 将更改后的博客部署到远端</span></span><br><span class="line">hexo clean       <span class="comment"># 在hexo g之前的文件清理，不是必要。</span></span><br></pre></td></tr></table></figure><br>以上就完成了所有的博客搭建的内容教程，这时候你就有了属于你自己的博客了。</p><h3 id="四、-设置博客主题"><a href="#四、-设置博客主题" class="headerlink" title="四、 设置博客主题"></a>四、 设置博客主题</h3><p>hexo博客的默认主题为landscape，我们可以自由地更换主题，大家可以去github上广泛地搜索，下面我们来讲解下如何更换主题。</p><h4 id="1-博客主题下载"><a href="#1-博客主题下载" class="headerlink" title="1. 博客主题下载"></a>1. 博客主题下载</h4><p>在hexo博客中有好多主题被广泛使用，这里我推荐我使用的两款主题</p><blockquote><p>next(目前正在使用)<br>yimlia</p></blockquote><p>两款主题的下载地址分别为</p><blockquote><p><a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">https://github.com/theme-next/hexo-theme-next</a><br><a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">https://github.com/litten/hexo-theme-yilia</a></p></blockquote><p>可以现在github上预览看下自己喜欢的主题。<br>我们下面来下载主题，打开<code>cmd</code>终端，在blog目录下输入命令。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next.git themes/next</span><br></pre></td></tr></table></figure><br>克隆完之后，在<code>blog/themes/</code>的目录下就有next文件夹了。</p><h4 id="2-将主题导入自己的博客"><a href="#2-将主题导入自己的博客" class="headerlink" title="2. 将主题导入自己的博客"></a>2. 将主题导入自己的博客</h4><p>打开blog目录下的配置文件<code>_config.yml</code>，更改theme的内容<br><img src="https://i.loli.net/2020/02/11/Umzn6IaltJZPXi7.png" alt=""><br>这样主题就导入成功了，接下来生成新内容，并部署到远端就可以了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><br>就可以在我们的网址上看到新的主题了。<br><strong>有可能出现尚未生效的情况，大家多刷新或等待就可以了，这是正常情况</strong></p><h4 id="3-常用更改"><a href="#3-常用更改" class="headerlink" title="3. 常用更改"></a>3. 常用更改</h4><p>最后的最后，我们需要学会更改配置文件的内容，根据自己的喜好优化博客即可，比如更改名字背景或添加特效等等。</p><p>第一个是<code>blog/</code>目录下的<code>_config.yml</code>配置文件<br><img src="https://i.loli.net/2020/02/11/238yAmoSVrMPkHj.png" alt=""><br>我们可以设置博客标题，副标题，描述，昵称，语言以及时区等等。</p><p>第二个是<code>blog/themes/next/</code>目录下的<code>_config.yml</code>配置文件<br>其实next主题还有四种样式可以选择，我选择的是Gemini样式<br><img src="https://i.loli.net/2020/02/11/ko1bgBWGqX89QlJ.png" alt=""><br>大家想要哪儿个样式，就在配置文件中取消注释就可以了。</p><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>以上所有内容便是hexo博客搭建的所有内容了。除了hexo以外，当然还有其他很多博客的框架，选择hexo的原因是应用比较广泛，可讨论的地方比较多。当然大家搭建博客还是先玩起来，至于其他的之后再考虑。<br>关于博客的其他细节内容，大家一定要善用搜索引擎，我也会考虑写一篇hexo next主题优化的博客内容，供大家参考。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、-hexo博客的作用&quot;&gt;&lt;a href=&quot;#一、-hexo博客的作用&quot; class=&quot;headerlink&quot; title=&quot;一、 hexo博客的作用&quot;&gt;&lt;/a&gt;一、 hexo博客的作用&lt;/h3&gt;&lt;p&gt;博客就像一个人公开的日记一般，可以记录很多包括生活学习在内的诸多事情，作为IT的学生，拥有一个属于自己的博客，也将是未来校招或研究生面试重要的加分项。&lt;br&gt;
    
    </summary>
    
    
      <category term="实用工具" scheme="http://yoursite.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
