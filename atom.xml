<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杨文昊的个人博客</title>
  
  <subtitle>愿你出走半生，归来仍是少年。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-04T05:18:11.567Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Alpha Yang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【吴恩达笔记】支持向量机SVM</title>
    <link href="http://yoursite.com/2020/07/04/%E3%80%90%E5%90%B4%E6%81%A9%E8%BE%BE%E7%AC%94%E8%AE%B0%E3%80%91%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BASVM/"/>
    <id>http://yoursite.com/2020/07/04/%E3%80%90%E5%90%B4%E6%81%A9%E8%BE%BE%E7%AC%94%E8%AE%B0%E3%80%91%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BASVM/</id>
    <published>2020-07-04T11:01:10.000Z</published>
    <updated>2020-07-04T05:18:11.567Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Support Vector Machines(简称SVM)支持向量机</strong>是机器学习中非常重要的一种算法，一般用于分类与判别，你可以能还会见到<strong>Support Vector Classification(简称SVC)、Support Vector Regression(简称SVR)</strong>，分别用于分类与回归，别担心他们的内理是一模一样的，只是功能不同而进行了划分罢了。</p><a id="more"></a><h3 id="优化目标-Optimization-Objective"><a href="#优化目标-Optimization-Objective" class="headerlink" title="优化目标(Optimization Objective)"></a>优化目标(Optimization Objective)</h3><p>我们先从Logistic回归说起，我们知道在Logistic回归中，Sigmoid函数的作用$z=\theta^Tx$，如果我们需要让$y=1$，那我们就想要$h(x)\approx1$，即$z\gg0$，反之则是，$z\ll0$。下面我们为远大于和远小于划定一定的界限，首先我们还是以代价函数的例子来说明，我们之前定义了：</p><script type="math/tex; mode=display">Cost(h(x),y)=-ylog\frac{1}{1+e^{-\theta^Tx}}-(1-y)log\left(1-\frac{1}{1+e^{-\theta^Tx}}\right)</script><p>我们分别画出当$y=0,1$时的函数图像：</p><p><img src="/../image/ml41.jpg" alt=""></p><p>我们可以很明显地看出当$y=1,z&gt;1$时，代价z就差不多变成0了，反之则是$z&lt;-1$。这里注意一下，关于1和-1，基本是我们约定俗成的，请大家不用过分在意。于是我们得到了新的代价，在机器学习，我们把它成为支持向量：</p><script type="math/tex; mode=display">\begin{align}cost_1(z)&=0 \text{ if } z>1\\cost_0(z)&=0 \text{ if } z<-1\end{align}</script><p>下面我们重写SVM的整体代价函数，我们加入了正则项，并与logistic作对比：</p><script type="math/tex; mode=display">\begin{align}Logistic: J(\theta)&=min\frac{1}{m}[\sum_{i=1}^my^{(i)}\left(-logh(x^{(i)})\right)+(1-y^{(i)})\left(-log(1-h(x^{(i)}))\right)]+\frac{\lambda}{2m}\sum_{j=1}^n\theta_j^2\\SVM: J(\theta)&=minC\sum_{i=1}^m[y^{(i)}cost_1(\theta^Tx^{(i)})+(1-y^{(i)})cost_0(\theta^Tx^{(i)})]+\frac{1}{2}\sum_{i=1}^n\theta_j^2\end{align}</script><p>我们可以看出SVM中有一个常数C，没有关系，你可以把他当做和正则化参数一样的东西，用于调整权重的比例，防止过拟合的问题。这就是SVM的优化目标，即代价函数。</p><h3 id="大间隔学习-Large-Margin-Learning"><a href="#大间隔学习-Large-Margin-Learning" class="headerlink" title="大间隔学习(Large Margin Learning)"></a>大间隔学习(Large Margin Learning)</h3><p>支持向量机还有一个名称，就是大间隔学习，下面我会用可视化的方式来告诉你为何它是大间隔学习，以及为何它的效果要优于我们的Logistic回归。假设我们有一个二分类的样本，如下图所示：</p><p><img src="/../image/ml42.jpg" alt=""></p><p>在这里分类问题中，L1和L2是我们Logsitic回归可能得到的决策界限，可以看出的是，虽然这两条直线，确实分开了两个样本，但是分类效果并不太好。而支持向量机划分的决策界限，则是S1，其中S2和S3为初始划定界限，最终选择S1作为决策界限，而S1与S2、S3的距离被称为Margin。这就是我们称SVM为大间隔学习的原因，其中关于SVM为何能做到这样的原因，就牵扯到了其背后的数学原理，在这里不做展开，比较复杂，建议基础扎实后看西瓜书或<a href="http://blog.pluskid.org/" target="_blank" rel="noopener">我老板朋友Free Mind的博客</a>。ps：之前听说有位学长面试时手推SVM，被lamda录取了。</p><h3 id="核函数-Kernel"><a href="#核函数-Kernel" class="headerlink" title="核函数(Kernel)"></a>核函数(Kernel)</h3><p>其实核函数核方法这些东西在所有的模型算法中都能应用到，但是其在SVM中的效果明显，所以核函数常常后来和SVM一起出现。我们在解决非线性问题的时候，常常会为假设函数的选择而困扰，选择单变量一次项$x_1$，还是单变量高次项$x_1^n$，还是选择多变量的积$x_1x_2x_3$，这常常会给我们的分类问题的解决造成障碍，于是我们可以得到一个较为统一的式子：</p><script type="math/tex; mode=display">h_{\theta}(x)=\theta_0+\theta_1f_1+\theta_2f_2+\theta_3f_3+...</script><p>下面我们就来谈谈如何选择这项通用式子中的$f_1,f_2,f_3$。对于给定的特征向量x，我们定义三个坐标点$l^{(1)},l^{(2)},l^{(3)}$。我们以此来决定通向式中的三个权重：</p><script type="math/tex; mode=display">\begin{align}f_1=similarity(x,l^{(1)})=exp(-\frac{\left\|x-l^{(1)}\right\|^2}{2\sigma^2})\\f_2=similarity(x,l^{(2)})=exp(-\frac{\left\|x-l^{(2)}\right\|^2}{2\sigma^2})\\f_3=similarity(x,l^{(3)})=exp(-\frac{\left\|x-l^{(3)}\right\|^2}{2\sigma^2})\end{align}</script><p>其中similarity函数就是我们所经常使用<strong>高斯核函数(Gaussion Kernels)</strong>，如果特征值离我们的定义坐标点越近，则$f\approx1$，反之则是$f\approx0 $。</p><p>简单说说，我们如何选择坐标点$l^{(1)},l^{(2)},l^{(3)},…$，我通常的选择方法笔记比较简单(当然还有很多复杂的选择方法)，比如我们有m个特征向量样本即$x^{(1)},x^{(2)},…,x^{(m)}$。</p><p>那我们便选择m个坐标点，$l^{(1)}=x^{(1)},l^{(2)}=x^{(2)},…,l^{(m)}=x^{(m)}$。一般而言，我会这么选择。然而核函数还有很多种，我这里列举一些：</p><ul><li>String kernel</li><li>chi-square kernel</li><li>histogram intersection kernel</li></ul><p>不过最常用且较为容易的还是高斯核函数。</p><h3 id="与Logistic如何选择"><a href="#与Logistic如何选择" class="headerlink" title="与Logistic如何选择"></a>与Logistic如何选择</h3><p>我们假设$n=number\text{ }of\text{ }features(x\in\mathbb{R}^{n+1}),m=number\;of\;trainingg\;examples$。</p><ul><li>如果n相对于m来说非常大：我们选用Logistic回归，或者不用核函数的SVM(不用核函数就相当于线性核函数Linear Kernel)。</li><li>如果n比较小，m中等：我们选用高斯核函数的SVM。</li><li>如果n小，m大：那我们需要增加特征向量的种类，然后同理第一种情况</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;Support Vector Machines(简称SVM)支持向量机&lt;/strong&gt;是机器学习中非常重要的一种算法，一般用于分类与判别，你可以能还会见到&lt;strong&gt;Support Vector Classification(简称SVC)、Support Vector Regression(简称SVR)&lt;/strong&gt;，分别用于分类与回归，别担心他们的内理是一模一样的，只是功能不同而进行了划分罢了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="吴恩达课程笔记" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%90%B4%E6%81%A9%E8%BE%BE%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="SVM" scheme="http://yoursite.com/tags/SVM/"/>
    
  </entry>
  
  <entry>
    <title>【分类与判别算法】支持向量机SVM</title>
    <link href="http://yoursite.com/2020/07/04/%E3%80%90%E5%88%86%E7%B1%BB%E4%B8%8E%E5%88%A4%E5%88%AB%E7%AE%97%E6%B3%95%E3%80%91%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BASVM/"/>
    <id>http://yoursite.com/2020/07/04/%E3%80%90%E5%88%86%E7%B1%BB%E4%B8%8E%E5%88%A4%E5%88%AB%E7%AE%97%E6%B3%95%E3%80%91%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BASVM/</id>
    <published>2020-07-04T11:00:36.000Z</published>
    <updated>2020-07-04T05:18:51.239Z</updated>
    
    <content type="html"><![CDATA[<p>终于讲到了算法的内容了，<strong>Support Vector Machines(简称SVM)支持向量机</strong>是机器学习与数学建模中非常重要的一种算法，一般用于分类与判别，你可以能还会见到<strong>Support Vector Classification(简称SVC)、Support Vector Regression(简称SVR)</strong>，分别用于分类与回归，别担心他们的内理是一模一样的，只是功能不同而进行了划分罢了。</p><a id="more"></a><h3 id="优化目标-Optimization-Objective"><a href="#优化目标-Optimization-Objective" class="headerlink" title="优化目标(Optimization Objective)"></a>优化目标(Optimization Objective)</h3><p>我们先从Logistic回归说起，我们知道在Logistic回归中，Sigmoid函数的作用$z=\theta^Tx$，如果我们需要让$y=1$，那我们就想要$h(x)\approx1$，即$z\gg0$，反之则是，$z\ll0$。下面我们为远大于和远小于划定一定的界限，首先我们还是以代价函数的例子来说明，我们之前定义了：</p><script type="math/tex; mode=display">Cost(h(x),y)=-ylog\frac{1}{1+e^{-\theta^Tx}}-(1-y)log\left(1-\frac{1}{1+e^{-\theta^Tx}}\right)</script><p>我们分别画出当$y=0,1$时的函数图像：</p><p><img src="/../image/ml41.jpg" alt=""></p><p>我们可以很明显地看出当$y=1,z&gt;1$时，代价z就差不多变成0了，反之则是$z&lt;-1$。这里注意一下，关于1和-1，基本是我们约定俗成的，请大家不用过分在意。于是我们得到了新的代价，在机器学习，我们把它成为支持向量：</p><script type="math/tex; mode=display">\begin{align}cost_1(z)&=0 \text{ if } z>1\\cost_0(z)&=0 \text{ if } z<-1\end{align}</script><p>下面我们重写SVM的整体代价函数，我们加入了正则项，并与logistic作对比：</p><script type="math/tex; mode=display">\begin{align}Logistic: J(\theta)&=min\frac{1}{m}[\sum_{i=1}^my^{(i)}\left(-logh(x^{(i)})\right)+(1-y^{(i)})\left(-log(1-h(x^{(i)}))\right)]+\frac{\lambda}{2m}\sum_{j=1}^n\theta_j^2\\SVM: J(\theta)&=minC\sum_{i=1}^m[y^{(i)}cost_1(\theta^Tx^{(i)})+(1-y^{(i)})cost_0(\theta^Tx^{(i)})]+\frac{1}{2}\sum_{i=1}^n\theta_j^2\end{align}</script><p>我们可以看出SVM中有一个常数C，没有关系，你可以把他当做和正则化参数一样的东西，用于调整权重的比例，防止过拟合的问题。这就是SVM的优化目标，即代价函数。</p><h3 id="大间隔学习-Large-Margin-Learning"><a href="#大间隔学习-Large-Margin-Learning" class="headerlink" title="大间隔学习(Large Margin Learning)"></a>大间隔学习(Large Margin Learning)</h3><p>支持向量机还有一个名称，就是大间隔学习，下面我会用可视化的方式来告诉你为何它是大间隔学习，以及为何它的效果要优于我们的Logistic回归。假设我们有一个二分类的样本，如下图所示：</p><p><img src="/../image/ml42.jpg" alt=""></p><p>在这里分类问题中，L1和L2是我们Logsitic回归可能得到的决策界限，可以看出的是，虽然这两条直线，确实分开了两个样本，但是分类效果并不太好。而支持向量机划分的决策界限，则是S1，其中S2和S3为初始划定界限，最终选择S1作为决策界限，而S1与S2、S3的距离被称为Margin。这就是我们称SVM为大间隔学习的原因，其中关于SVM为何能做到这样的原因，就牵扯到了其背后的数学原理，在这里不做展开，比较复杂，建议基础扎实后看西瓜书或<a href="http://blog.pluskid.org/" target="_blank" rel="noopener">我老板朋友Free Mind的博客</a>。ps：之前听说有位学长面试时手推SVM，被lamda录取了。</p><h3 id="核函数-Kernel"><a href="#核函数-Kernel" class="headerlink" title="核函数(Kernel)"></a>核函数(Kernel)</h3><p>其实核函数核方法这些东西在所有的模型算法中都能应用到，但是其在SVM中的效果明显，所以核函数常常后来和SVM一起出现。我们在解决非线性问题的时候，常常会为假设函数的选择而困扰，选择单变量一次项$x_1$，还是单变量高次项$x_1^n$，还是选择多变量的积$x_1x_2x_3$，这常常会给我们的分类问题的解决造成障碍，于是我们可以得到一个较为统一的式子：</p><script type="math/tex; mode=display">h_{\theta}(x)=\theta_0+\theta_1f_1+\theta_2f_2+\theta_3f_3+...</script><p>下面我们就来谈谈如何选择这项通用式子中的$f_1,f_2,f_3$。对于给定的特征向量x，我们定义三个坐标点$l^{(1)},l^{(2)},l^{(3)}$。我们以此来决定通向式中的三个权重：</p><script type="math/tex; mode=display">\begin{align}f_1=similarity(x,l^{(1)})=exp(-\frac{\left\|x-l^{(1)}\right\|^2}{2\sigma^2})\\f_2=similarity(x,l^{(2)})=exp(-\frac{\left\|x-l^{(2)}\right\|^2}{2\sigma^2})\\f_3=similarity(x,l^{(3)})=exp(-\frac{\left\|x-l^{(3)}\right\|^2}{2\sigma^2})\end{align}</script><p>其中similarity函数就是我们所经常使用<strong>高斯核函数(Gaussion Kernels)</strong>，如果特征值离我们的定义坐标点越近，则$f\approx1$，反之则是$f\approx0 $。</p><p>简单说说，我们如何选择坐标点$l^{(1)},l^{(2)},l^{(3)},…$，我通常的选择方法笔记比较简单(当然还有很多复杂的选择方法)，比如我们有m个特征向量样本即$x^{(1)},x^{(2)},…,x^{(m)}$。</p><p>那我们便选择m个坐标点，$l^{(1)}=x^{(1)},l^{(2)}=x^{(2)},…,l^{(m)}=x^{(m)}$。一般而言，我会这么选择。然而核函数还有很多种，我这里列举一些：</p><ul><li>String kernel</li><li>chi-square kernel</li><li>histogram intersection kernel</li></ul><p>不过最常用且较为容易的还是高斯核函数。</p><h3 id="与Logistic如何选择"><a href="#与Logistic如何选择" class="headerlink" title="与Logistic如何选择"></a>与Logistic如何选择</h3><p>我们假设$n=number\text{ }of\text{ }features(x\in\mathbb{R}^{n+1}),m=number\;of\;trainingg\;examples$。</p><ul><li>如果n相对于m来说非常大：我们选用Logistic回归，或者不用核函数的SVM(不用核函数就相当于线性核函数Linear Kernel)。</li><li>如果n比较小，m中等：我们选用高斯核函数的SVM。</li><li>如果n小，m大：那我们需要增加特征向量的种类，然后同理第一种情况</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于讲到了算法的内容了，&lt;strong&gt;Support Vector Machines(简称SVM)支持向量机&lt;/strong&gt;是机器学习与数学建模中非常重要的一种算法，一般用于分类与判别，你可以能还会见到&lt;strong&gt;Support Vector Classification(简称SVC)、Support Vector Regression(简称SVR)&lt;/strong&gt;，分别用于分类与回归，别担心他们的内理是一模一样的，只是功能不同而进行了划分罢了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数学建模" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="算法篇" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E7%AE%97%E6%B3%95%E7%AF%87/"/>
    
    
      <category term="SVM" scheme="http://yoursite.com/tags/SVM/"/>
    
  </entry>
  
  <entry>
    <title>【吴恩达笔记】正则化</title>
    <link href="http://yoursite.com/2020/07/03/%E3%80%90%E5%90%B4%E6%81%A9%E8%BE%BE%E7%AC%94%E8%AE%B0%E3%80%91%E6%AD%A3%E5%88%99%E5%8C%96/"/>
    <id>http://yoursite.com/2020/07/03/%E3%80%90%E5%90%B4%E6%81%A9%E8%BE%BE%E7%AC%94%E8%AE%B0%E3%80%91%E6%AD%A3%E5%88%99%E5%8C%96/</id>
    <published>2020-07-03T11:44:01.000Z</published>
    <updated>2020-07-04T05:17:53.202Z</updated>
    
    <content type="html"><![CDATA[<p>关于<strong>Regularization(正则化)</strong>的问题，这实际上在数学模型优化以及机器学习系统设计中，都是特别难处理的问题，所以我这里也只能用我浅显的认知和大家讲述正则化中最基本的知识。</p><a id="more"></a><h3 id="关于拟合：Underfitting-VS-Overfitting"><a href="#关于拟合：Underfitting-VS-Overfitting" class="headerlink" title="关于拟合：Underfitting VS Overfitting"></a>关于拟合：Underfitting VS Overfitting</h3><p><img src="/../image/ml31.jpg" alt=""></p><p>还是之前关于房价的例子，如果我们尝试用不同的函数进行拟合，选用一次函数，我们会发现，我们并没有完成一个比较好的拟合效果，所以我们称这种拟合为<strong>欠拟合(Underfitting)</strong>。而选用四次函数，我们会发现这样的拟合可能会误差很小，即<script type="math/tex">J(\theta)=\frac{1}{2m}\sum\limits_{i=1}^n\left(h_\theta(x)-y^{(i)}\right)^2\approx0</script>，但是很显然这个，函数拟合的并不满足实际情况(实际曲线根本不可能这么陡峭)，也就是说这个拟合的泛化效果不好，这种情况我们称为过拟合。而正则化正是为我们解决过拟合问题的。</p><h3 id="正则化代价函数"><a href="#正则化代价函数" class="headerlink" title="正则化代价函数"></a>正则化代价函数</h3><p>我们考虑一个问题，会出现过拟合现象的原因可能是我们对于参数的权重选用不得当，所以我们得像个办法来进行约束，引入一个新的正则化参数$\lambda$，<strong>regularization parament</strong> 。从而我们可以得到新的代价函数：</p><script type="math/tex; mode=display">J(\theta)=\frac{1}{2m}[\sum_{i=1}^{m}\left(h_\theta(x^{(i)})-y^{(i)}\right)^2+\lambda\sum_{i=1}^n\theta_j^2]</script><p>这样我们通过控制正则化参数的值就能对模型或者系统进行一定程度的优化或者说可视化的控制。</p><p>不管是正则化任何模型，我们控制的都是我们待定的权重，通过这样的方式，我们可以固定函数的类别，得到更合理的模型，在处理非线性的问题中广泛应用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于&lt;strong&gt;Regularization(正则化)&lt;/strong&gt;的问题，这实际上在数学模型优化以及机器学习系统设计中，都是特别难处理的问题，所以我这里也只能用我浅显的认知和大家讲述正则化中最基本的知识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="吴恩达课程笔记" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%90%B4%E6%81%A9%E8%BE%BE%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="正则化" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>【模型优化】浅谈正则化</title>
    <link href="http://yoursite.com/2020/07/03/%E3%80%90%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8C%96%E3%80%91%E6%B5%85%E8%B0%88%E6%AD%A3%E5%88%99%E5%8C%96/"/>
    <id>http://yoursite.com/2020/07/03/%E3%80%90%E6%A8%A1%E5%9E%8B%E4%BC%98%E5%8C%96%E3%80%91%E6%B5%85%E8%B0%88%E6%AD%A3%E5%88%99%E5%8C%96/</id>
    <published>2020-07-03T11:43:35.000Z</published>
    <updated>2020-07-04T05:18:02.374Z</updated>
    
    <content type="html"><![CDATA[<p>关于<strong>Regularization(正则化)</strong>的问题，这实际上在数学模型优化以及机器学习系统设计中，都是特别难处理的问题，所以我这里也只能用我浅显的认知和大家讲述正则化中最基本的知识。</p><a id="more"></a><h3 id="关于拟合：Underfitting-VS-Overfitting"><a href="#关于拟合：Underfitting-VS-Overfitting" class="headerlink" title="关于拟合：Underfitting VS Overfitting"></a>关于拟合：Underfitting VS Overfitting</h3><p><img src="/../image/ml31.jpg" alt=""></p><p>还是之前关于房价的例子，如果我们尝试用不同的函数进行拟合，选用一次函数，我们会发现，我们并没有完成一个比较好的拟合效果，所以我们称这种拟合为<strong>欠拟合(Underfitting)</strong>。而选用四次函数，我们会发现这样的拟合可能会误差很小，即<script type="math/tex">J(\theta)=\frac{1}{2m}\sum\limits_{i=1}^n\left(h_\theta(x)-y^{(i)}\right)^2\approx0</script>，但是很显然这个，函数拟合的并不满足实际情况(实际曲线根本不可能这么陡峭)，也就是说这个拟合的泛化效果不好，这种情况我们称为过拟合。而正则化正是为我们解决过拟合问题的。</p><h3 id="正则化代价函数"><a href="#正则化代价函数" class="headerlink" title="正则化代价函数"></a>正则化代价函数</h3><p>我们考虑一个问题，会出现过拟合现象的原因可能是我们对于参数的权重选用不得当，所以我们得像个办法来进行约束，引入一个新的正则化参数$\lambda$，<strong>regularization parament</strong> 。从而我们可以得到新的代价函数：</p><script type="math/tex; mode=display">J(\theta)=\frac{1}{2m}[\sum_{i=1}^{m}\left(h_\theta(x^{(i)})-y^{(i)}\right)^2+\lambda\sum_{i=1}^n\theta_j^2]</script><p>这样我们通过控制正则化参数的值就能对模型或者系统进行一定程度的优化或者说可视化的控制。</p><p>不管是正则化任何模型，我们控制的都是我们待定的权重，通过这样的方式，我们可以固定函数的类别，得到更合理的模型，在处理非线性的问题中广泛应用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于&lt;strong&gt;Regularization(正则化)&lt;/strong&gt;的问题，这实际上在数学模型优化以及机器学习系统设计中，都是特别难处理的问题，所以我这里也只能用我浅显的认知和大家讲述正则化中最基本的知识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数学建模" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="模型篇" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E6%A8%A1%E5%9E%8B%E7%AF%87/"/>
    
    
      <category term="正则化" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>【初等模型】Logistic回归模型</title>
    <link href="http://yoursite.com/2020/06/29/%E3%80%90%E5%88%9D%E7%AD%89%E6%A8%A1%E5%9E%8B%E3%80%91Logistic%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/06/29/%E3%80%90%E5%88%9D%E7%AD%89%E6%A8%A1%E5%9E%8B%E3%80%91Logistic%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-06-28T21:14:03.000Z</published>
    <updated>2020-07-02T16:09:56.294Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇博客中，我们讲到了线性回归模型，是监督学习中的一个做预测工作的例子。而这里的Logistic回归则是监督学习的一个做分类工作例子，在数学建模与机器学习中，Logistic回归通常用于分类的目的，例如邮件的垃圾邮件分类，肿瘤的恶性良性分类等等。By the way，Logistic回归和Logistic分类是一回事，大家完全可以将两者等价。</p><p>Logistic回归有两种任务情况，分别是二元分类和多元分类问题，从字面上理解来说，binary problem是二元问题：非此即彼，非0即1 。而多元分类则是有多个分类组别，下面我们先从易入难，从binary的Logistic回归说起。</p><a id="more"></a><h3 id="Logistic模型描述"><a href="#Logistic模型描述" class="headerlink" title="Logistic模型描述"></a>Logistic模型描述</h3><p>和线性回归模型思想一项，也会存在单特征或多个特征$x^{(1)}_j$的情况，但是我们的目标值或者是输出值只有两种，0或1，即$y\in \{0,1\}$。其中”0”代表”Negative Class”，”1”代表”Positive Class”。</p><p>但是我们通过假设函数计算的输出值即$h_{\theta}(x)$可不可能只有0或1两个情况，很显然，根本没有连续函数能达到这个功能，所以在输出值有一段连续值得情况下，我们设置一个<strong>阈值(threshold)</strong>。例如我们讨论关于肿瘤恶性与良性的分类，设置阈值为0.5，这是什么意思呢？</p><p>如果$h_{\theta}(x)\geq 0.5$，那我们预测$y=1$，即在这种情况下，我们更倾向于将这个肿瘤划分为恶性的。反之$h_{\theta}(x)&lt;0.5$，则$y=0$。在这方面，后来也有很多扩展，比如应用于年龄估计和情感计算的多标签分布学习与标记增强，拜读过东南大学耿新老师的论文，如果有兴趣可以去看看。</p><p>为了使得分类任务靠设定阈值顺利进行，我们其实还得保证输出$h(x)$的范围的确定性，如果范围过于不确定，那阈值的选择会比较困难，所以之后我们会讲到这种方法，使得$0\leq h_{\theta}(x)\leq 1$。</p><h3 id="假设函数的新表示方法-区别于线性回归"><a href="#假设函数的新表示方法-区别于线性回归" class="headerlink" title="假设函数的新表示方法(区别于线性回归)"></a>假设函数的新表示方法(区别于线性回归)</h3><p>在上文中提到，我们为了想让$0\leq h_{\theta}(x)\leq 1$满足在这个范围内，我们引入一个神奇的函数，在机器学习中这个函数当真反复出现，<strong>Sigmoid function/Logistic function</strong>(这两个函数就是等价的，一个意思)：</p><p><img src="/../image/ml21.jpg" alt=""></p><p>这是个生物学函数，为了显示它的重要性，我单独列一行出来：</p><script type="math/tex; mode=display">g(z)=\frac{1}{1+e^{-z}}</script><p>现在我们写出Logistic回归模型的假设函数，并与之前的线性回归模型的进行对比：</p><script type="math/tex; mode=display">\begin{align}Linear&:h_{\theta}(x)=\theta^Tx\\Logistic&:h_{\theta}(x)=g(\theta^Tx)=\frac{1}{1+e^{-\theta^Tx}}\end{align}</script><p>事实上，就是区别于Sigmoid函数，还是之前恶性与良性肿瘤的例子。根据我输入的特征向量，求出的假设函数$h(x)$实际上代表着预测$y=1$的概率，即：</p><script type="math/tex; mode=display">h(x)=P(y=1|x;\theta),y=0,1</script><p>比如输出一组特征值，我们输出$h(x)=0.7$代表肿瘤为恶性的可能性为$70\%$，考虑到我们之前所定阈值为0.5，所以这个肿瘤我们划分在恶性中去。</p><h3 id="决策界限-Decision-Boundary"><a href="#决策界限-Decision-Boundary" class="headerlink" title="决策界限(Decision Boundary)"></a>决策界限(Decision Boundary)</h3><h4 id="线性"><a href="#线性" class="headerlink" title="线性"></a>线性</h4><p><img src="/../image/ml22.jpg" alt=""></p><p>通常选择线性or非线性，主要还是观察数据集的分布情况。比如上图，我们采用线性Boundary，$z=\theta^Tx$我们通过现有的数据集计算出了，$\theta^T=\begin{bmatrix}-3 &amp; 1&amp; 1\end{bmatrix}$，由于我们知道Sigmoid函数的性质我们知道，当$z\geq0$时，$g(z)\geq0.5$，我们认为它属于恶性肿瘤，反之相对即可。即我们最终计算出的线性决策界限，就是$z\geq0$时为恶性肿瘤，即$-3+x_1+x_2\geq0$。我们通过$\theta$反推得出了决策界限。</p><h4 id="非线性"><a href="#非线性" class="headerlink" title="非线性"></a>非线性</h4><p><img src="/../image/ml23.jpg" alt=""></p><p>在这个非线性的例子中，我们处理非线性的决策边界问题，令假设函数的表达式为：</p><script type="math/tex; mode=display">h(x)=g(\theta_0+\theta_1x_1+\theta_2x_2+\theta_3x_1^2+\theta_4x_2^2)</script><p>当然你可能会觉得这个假设函数的设置过于主观，that’s ok. 这可能是我通常不会选择Logistic来处理非线性分类问题的原因。在这种分类问题，我更喜欢构建SVM的模型，这个我们之后会提到。好了，话说回来，这个我们通过计算得到，$\theta^T=\begin{bmatrix}-1 &amp; 0 &amp; 0 &amp; 1 &amp; 1\end{bmatrix}$，由Sigmoid的性质可得，当$z\geq 0$时，即$x_1^2+x^2_2\geq 1$，在这个情况下，我们更希望相信这个分类成为恶性肿瘤，反之也相对。下面我们来说说，Logistic回归的代价函数。</p><h3 id="代价函数-Cost-Function"><a href="#代价函数-Cost-Function" class="headerlink" title="代价函数(Cost Function)"></a>代价函数(Cost Function)</h3><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>我们上述讨论了决策边界的问题，那么我们现在需要解决的问题就是如何选取最优的$\theta$值，即代价函数最小。首先，我先说Logistic的代价函数，和我们之前的线性回归的表达形式一模一样：</p><script type="math/tex; mode=display">J(\theta)=\frac{1}{2m}\sum_{i=1}^m\left(h_\theta(x^{(i)})-y^{(i)}\right)^2</script><p>你可能觉得这个代价函数和线性回归的一模一样，但是有一些细微的差别，在这里$h(x)=g(z)$，而线性回归则没有加入sigmoid函数。但是，我们其实通常并不选择这个函数为我们所要的代价函数，我这里简单说下原因，由于我们的假设函数是关于sigmoid的函数，是一个非线性的函数。代入计算，我们的代价函数会是一个非凸函数。</p><p><img src="/../image/ml24.jpg" alt=""></p><p>在这个情况下，非凸函数如左图所示，他有很多的局部最优点，所以我们使用梯度下降法是找不到全局最优点的。而我们需要找一个<strong>凸函数(convex function)</strong>，也就是弓形函数，仅有一个全局最优解，所以我们通过梯度下降法就能很好做到找到代价函数的最优点。</p><h4 id="改进Cost，重新化简代价函数"><a href="#改进Cost，重新化简代价函数" class="headerlink" title="改进Cost，重新化简代价函数"></a>改进Cost，重新化简代价函数</h4><p>在上个引入部分中，我们令代价函数的部分为：</p><script type="math/tex; mode=display">\begin{align}J(\theta)&=\frac{1}{m}\sum_{i=1}^m\frac{1}{2}\left(h_\theta(x^{(i)})-y^{(i)}\right)^2\\Cost(h_\theta(x^{(i)}),y^{(i)})&=\frac{1}{2}\left(h_\theta(x^{(i)})-y^{(i)}\right)^2\\\end{align}</script><p>下面我们来改进一个新的Cost从而得到新的代价函数，而这个代价函数我们希望他是convex的，还是以二分类问题来举例：</p><script type="math/tex; mode=display">Cost(h_\theta(x),y)=\begin{cases}-log(h_\theta(x)) & \text{if } y=1\\-log(1-h_\theta(x)) & \text{if } y=0\\\end{cases}</script><p>在binary的问题中，我们注意到y的值总是0或1，所以我们重新化简代价函数：</p><script type="math/tex; mode=display">J(\theta)=-\frac{1}{m}[\sum_{i=1}^my^{(i)}logh_{\theta}(x^{(i)})+(1-y^{(i)})log(1-h_{\theta}(x^{(i)}))]</script><p>然后我们又可以愉快地用梯度下降算法啦！！</p><h3 id="多元分类问题-Multi-class-classification"><a href="#多元分类问题-Multi-class-classification" class="headerlink" title="多元分类问题(Multi-class classification)"></a>多元分类问题(Multi-class classification)</h3><p>其实，多元分类与二元分类基本类似，我们现在假设我们有三个类别(更多的也一样)，Class 1~3，我们简单用下图来说明下问题。</p><p><img src="/../image/ml25.jpg" alt=""></p><p>吴恩达老师上课的课件，看到$h_{\theta}^{(i)}=P(y=i|x;\theta)$这个公式(julao不愧是julao)，让我茅塞顿开。其实多元分类问题就可以写成二元分类，如果你还没看懂，我来做下简单的解释。</p><script type="math/tex; mode=display">J^{(i)}(\theta)=-\frac{1}{m}[\sum_{i=1}^mylogh^{(i)}_{\theta}(x)+(i-y)log(1-h^{(i)}_{\theta}(x))]</script><p>这样，我们便依然可以采用梯度下降法去求解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇博客中，我们讲到了线性回归模型，是监督学习中的一个做预测工作的例子。而这里的Logistic回归则是监督学习的一个做分类工作例子，在数学建模与机器学习中，Logistic回归通常用于分类的目的，例如邮件的垃圾邮件分类，肿瘤的恶性良性分类等等。By the way，Logistic回归和Logistic分类是一回事，大家完全可以将两者等价。&lt;/p&gt;
&lt;p&gt;Logistic回归有两种任务情况，分别是二元分类和多元分类问题，从字面上理解来说，binary problem是二元问题：非此即彼，非0即1 。而多元分类则是有多个分类组别，下面我们先从易入难，从binary的Logistic回归说起。&lt;/p&gt;
    
    </summary>
    
    
      <category term="数学建模" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="模型篇" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E6%A8%A1%E5%9E%8B%E7%AF%87/"/>
    
    
      <category term="Logistic" scheme="http://yoursite.com/tags/Logistic/"/>
    
  </entry>
  
  <entry>
    <title>【吴恩达笔记】Logistic回归</title>
    <link href="http://yoursite.com/2020/06/29/%E3%80%90%E5%90%B4%E6%81%A9%E8%BE%BE%E7%AC%94%E8%AE%B0%E3%80%91Logistic%E5%9B%9E%E5%BD%92/"/>
    <id>http://yoursite.com/2020/06/29/%E3%80%90%E5%90%B4%E6%81%A9%E8%BE%BE%E7%AC%94%E8%AE%B0%E3%80%91Logistic%E5%9B%9E%E5%BD%92/</id>
    <published>2020-06-28T21:13:21.000Z</published>
    <updated>2020-07-03T02:31:53.704Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇博客中，我们讲到了线性回归模型，是监督学习中的一个做预测工作的例子。而这里的Logistic回归则是监督学习的一个做分类工作例子，在数学建模与机器学习中，Logistic回归通常用于分类的目的，例如邮件的垃圾邮件分类，肿瘤的恶性良性分类等等。By the way，Logistic回归和Logistic分类是一回事，大家完全可以将两者等价。</p><p>Logistic回归有两种任务情况，分别是二元分类和多元分类问题，从字面上理解来说，binary problem是二元问题：非此即彼，非0即1 。而多元分类则是有多个分类组别，下面我们先从易入难，从binary的Logistic回归说起。</p><a id="more"></a><h3 id="Logistic模型描述"><a href="#Logistic模型描述" class="headerlink" title="Logistic模型描述"></a>Logistic模型描述</h3><p>和线性回归模型思想一项，也会存在单特征或多个特征$x^{(1)}_j$的情况，但是我们的目标值或者是输出值只有两种，0或1，即$y\in \{0,1\}$。其中”0”代表”Negative Class”，”1”代表”Positive Class”。</p><p>但是我们通过假设函数计算的输出值即$h_{\theta}(x)$可不可能只有0或1两个情况，很显然，根本没有连续函数能达到这个功能，所以在输出值有一段连续值得情况下，我们设置一个<strong>阈值(threshold)</strong>。例如我们讨论关于肿瘤恶性与良性的分类，设置阈值为0.5，这是什么意思呢？</p><p>如果$h_{\theta}(x)\geq 0.5$，那我们预测$y=1$，即在这种情况下，我们更倾向于将这个肿瘤划分为恶性的。反之$h_{\theta}(x)&lt;0.5$，则$y=0$。在这方面，后来也有很多扩展，比如应用于年龄估计和情感计算的多标签分布学习与标记增强，拜读过东南大学耿新老师的论文，如果有兴趣可以去看看。</p><p>为了使得分类任务靠设定阈值顺利进行，我们其实还得保证输出$h(x)$的范围的确定性，如果范围过于不确定，那阈值的选择会比较困难，所以之后我们会讲到这种方法，使得$0\leq h_{\theta}(x)\leq 1$。</p><h3 id="假设函数的新表示方法-区别于线性回归"><a href="#假设函数的新表示方法-区别于线性回归" class="headerlink" title="假设函数的新表示方法(区别于线性回归)"></a>假设函数的新表示方法(区别于线性回归)</h3><p>在上文中提到，我们为了想让$0\leq h_{\theta}(x)\leq 1$满足在这个范围内，我们引入一个神奇的函数，在机器学习中这个函数当真反复出现，<strong>Sigmoid function/Logistic function</strong>(这两个函数就是等价的，一个意思)：</p><p><img src="/../image/ml21.jpg" alt=""></p><p>这是个生物学函数，为了显示它的重要性，我单独列一行出来：</p><script type="math/tex; mode=display">g(z)=\frac{1}{1+e^{-z}}</script><p>现在我们写出Logistic回归模型的假设函数，并与之前的线性回归模型的进行对比：</p><script type="math/tex; mode=display">\begin{align}Linear&:h_{\theta}(x)=\theta^Tx\\Logistic&:h_{\theta}(x)=g(\theta^Tx)=\frac{1}{1+e^{-\theta^Tx}}\end{align}</script><p>事实上，就是区别于Sigmoid函数，还是之前恶性与良性肿瘤的例子。根据我输入的特征向量，求出的假设函数$h(x)$实际上代表着预测$y=1$的概率，即：</p><script type="math/tex; mode=display">h(x)=P(y=1|x;\theta),y=0,1</script><p>比如输出一组特征值，我们输出$h(x)=0.7$代表肿瘤为恶性的可能性为$70\%$，考虑到我们之前所定阈值为0.5，所以这个肿瘤我们划分在恶性中去。</p><h3 id="决策界限-Decision-Boundary"><a href="#决策界限-Decision-Boundary" class="headerlink" title="决策界限(Decision Boundary)"></a>决策界限(Decision Boundary)</h3><h4 id="线性"><a href="#线性" class="headerlink" title="线性"></a>线性</h4><p><img src="/../image/ml22.jpg" alt=""></p><p>通常选择线性or非线性，主要还是观察数据集的分布情况。比如上图，我们采用线性Boundary，$z=\theta^Tx$我们通过现有的数据集计算出了，$\theta^T=\begin{bmatrix}-3 &amp; 1&amp; 1\end{bmatrix}$，由于我们知道Sigmoid函数的性质我们知道，当$z\geq0$时，$g(z)\geq0.5$，我们认为它属于恶性肿瘤，反之相对即可。即我们最终计算出的线性决策界限，就是$z\geq0$时为恶性肿瘤，即$-3+x_1+x_2\geq0$。我们通过$\theta$反推得出了决策界限。</p><h4 id="非线性"><a href="#非线性" class="headerlink" title="非线性"></a>非线性</h4><p><img src="/../image/ml23.jpg" alt=""></p><p>在这个非线性的例子中，我们处理非线性的决策边界问题，令假设函数的表达式为：</p><script type="math/tex; mode=display">h(x)=g(\theta_0+\theta_1x_1+\theta_2x_2+\theta_3x_1^2+\theta_4x_2^2)</script><p>当然你可能会觉得这个假设函数的设置过于主观，that’s ok. 这可能是我通常不会选择Logistic来处理非线性分类问题的原因。在这种分类问题，我更喜欢构建SVM的模型，这个我们之后会提到。好了，话说回来，这个我们通过计算得到，$\theta^T=\begin{bmatrix}-1 &amp; 0 &amp; 0 &amp; 1 &amp; 1\end{bmatrix}$，由Sigmoid的性质可得，当$z\geq 0$时，即$x_1^2+x^2_2\geq 1$，在这个情况下，我们更希望相信这个分类成为恶性肿瘤，反之也相对。下面我们来说说，Logistic回归的代价函数。</p><h3 id="代价函数-Cost-Function"><a href="#代价函数-Cost-Function" class="headerlink" title="代价函数(Cost Function)"></a>代价函数(Cost Function)</h3><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>我们上述讨论了决策边界的问题，那么我们现在需要解决的问题就是如何选取最优的$\theta$值，即代价函数最小。首先，我先说Logistic的代价函数，和我们之前的线性回归的表达形式一模一样：</p><script type="math/tex; mode=display">J(\theta)=\frac{1}{2m}\sum_{i=1}^m\left(h_\theta(x^{(i)})-y^{(i)}\right)^2</script><p>你可能觉得这个代价函数和线性回归的一模一样，但是有一些细微的差别，在这里$h(x)=g(z)$，而线性回归则没有加入sigmoid函数。但是，我们其实通常并不选择这个函数为我们所要的代价函数，我这里简单说下原因，由于我们的假设函数是关于sigmoid的函数，是一个非线性的函数。代入计算，我们的代价函数会是一个非凸函数。</p><p><img src="/../image/ml24.jpg" alt=""></p><p>在这个情况下，非凸函数如左图所示，他有很多的局部最优点，所以我们使用梯度下降法是找不到全局最优点的。而我们需要找一个<strong>凸函数(convex function)</strong>，也就是弓形函数，仅有一个全局最优解，所以我们通过梯度下降法就能很好做到找到代价函数的最优点。</p><h4 id="改进Cost，重新化简代价函数"><a href="#改进Cost，重新化简代价函数" class="headerlink" title="改进Cost，重新化简代价函数"></a>改进Cost，重新化简代价函数</h4><p>在上个引入部分中，我们令代价函数的部分为：</p><script type="math/tex; mode=display">\begin{align}J(\theta)&=\frac{1}{m}\sum_{i=1}^m\frac{1}{2}\left(h_\theta(x^{(i)})-y^{(i)}\right)^2\\Cost(h_\theta(x^{(i)}),y^{(i)})&=\frac{1}{2}\left(h_\theta(x^{(i)})-y^{(i)}\right)^2\\\end{align}</script><p>下面我们来改进一个新的Cost从而得到新的代价函数，而这个代价函数我们希望他是convex的，还是以二分类问题来举例：</p><script type="math/tex; mode=display">Cost(h_\theta(x),y)=\begin{cases}-log(h_\theta(x)) & \text{if } y=1\\-log(1-h_\theta(x)) & \text{if } y=0\\\end{cases}</script><p>在binary的问题中，我们注意到y的值总是0或1，所以我们重新化简代价函数：</p><script type="math/tex; mode=display">J(\theta)=-\frac{1}{m}[\sum_{i=1}^my^{(i)}logh_{\theta}(x^{(i)})+(1-y^{(i)})log(1-h_{\theta}(x^{(i)}))]</script><p>然后我们又可以愉快地用梯度下降算法啦！！</p><h3 id="多元分类问题-Multi-class-classification"><a href="#多元分类问题-Multi-class-classification" class="headerlink" title="多元分类问题(Multi-class classification)"></a>多元分类问题(Multi-class classification)</h3><p>其实，多元分类与二元分类基本类似，我们现在假设我们有三个类别(更多的也一样)，Class 1~3，我们简单用下图来说明下问题。</p><p><img src="/../image/ml25.jpg" alt=""></p><p>吴恩达老师上课的课件，看到$h_{\theta}^{(i)}=P(y=i|x;\theta)$这个公式(julao不愧是julao)，让我茅塞顿开。其实多元分类问题就可以写成二元分类，如果你还没看懂，我来做下简单的解释。</p><script type="math/tex; mode=display">J^{(i)}(\theta)=-\frac{1}{m}[\sum_{i=1}^mylogh^{(i)}_{\theta}(x)+(i-y)log(1-h^{(i)}_{\theta}(x))]</script><p>这样，我们便依然可以采用梯度下降法去求解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇博客中，我们讲到了线性回归模型，是监督学习中的一个做预测工作的例子。而这里的Logistic回归则是监督学习的一个做分类工作例子，在数学建模与机器学习中，Logistic回归通常用于分类的目的，例如邮件的垃圾邮件分类，肿瘤的恶性良性分类等等。By the way，Logistic回归和Logistic分类是一回事，大家完全可以将两者等价。&lt;/p&gt;
&lt;p&gt;Logistic回归有两种任务情况，分别是二元分类和多元分类问题，从字面上理解来说，binary problem是二元问题：非此即彼，非0即1 。而多元分类则是有多个分类组别，下面我们先从易入难，从binary的Logistic回归说起。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="吴恩达课程笔记" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%90%B4%E6%81%A9%E8%BE%BE%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Logistic" scheme="http://yoursite.com/tags/Logistic/"/>
    
  </entry>
  
  <entry>
    <title>【初等模型】线性回归</title>
    <link href="http://yoursite.com/2020/06/29/%E3%80%90%E5%88%9D%E7%AD%89%E6%A8%A1%E5%9E%8B%E3%80%91%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    <id>http://yoursite.com/2020/06/29/%E3%80%90%E5%88%9D%E7%AD%89%E6%A8%A1%E5%9E%8B%E3%80%91%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</id>
    <published>2020-06-28T20:19:57.000Z</published>
    <updated>2020-06-28T13:29:45.296Z</updated>
    
    <content type="html"><![CDATA[<p>你可能会发现这篇博客与我之前的机器学习的线性回归完全一样，没错，就是一样的。知识点都是线性回归，所以能有什么区别呢，线性回归模型都是数学模型与机器学习中最基础的模型，需要注意的是，学校老师培训的数学建模竞赛培训可能更重视原理，导致大部分同学听了个寂寞。但是往往比赛我们会使用就行，不用太过于纠结，另外题目与源代码之后补上2333。</p><h3 id="一元线性回归-单变量线性回归-Linear-Regression-with-one-variable"><a href="#一元线性回归-单变量线性回归-Linear-Regression-with-one-variable" class="headerlink" title="一元线性回归(单变量线性回归)  Linear Regression with one variable"></a>一元线性回归(单变量线性回归)  Linear Regression with one variable</h3><a id="more"></a><h4 id="1-模型描述"><a href="#1-模型描述" class="headerlink" title="1. 模型描述"></a>1. 模型描述</h4><p>首先明确线性回归的作用，在机器学习中，我们可以广义的把机器学习划分为两类学习，监督学习与无监督学习。简单而言，监督学习就是给出了准确答案，期望计算机能学习其中的原理，并对我们未知的事情做出一定的预测。无监督学习就是指，我们并不知道准确结果的事情，希望机器通过学习，能从中抽取有效信息，举个简单的例子，例如邮箱垃圾邮件分类，新闻栏目划分等等，这些我们都能通过无监督学习去解决。</p><p>好了下面再举一个关于监督学习的例子，吴老师上课的例子是房价预估，如下图所示。</p><p><img src="/../image/ml1.jpg" alt=""></p><p>给你一定数量的数据集，代表房屋尺寸与价格的散点图，现在你希望知道除这些数据集以外的Size所对应的Price，相当于我之前说的预测。比如Size为1250时，那Price可能为2200左右这样子。那这个过程，我们实际就是想从现已知的数据集中学习某些知识内容，从而达到预测的效果。而这个过程就是我们所说的，<strong>回归</strong>。</p><p>其实就是拟合函数曲线，从而达到其与数据集的最优拟合，然后预测所有的Size。由于这个房子的单价这个假设中只与Size有关，所以我们称它为单变量或是一元。</p><p>下图是关于机器学习的基本流程图，你可以认为几乎所有机器学习问题都是这个框架的东西。</p><p><img src="/../image/ml2.jpg" alt=""></p><p>而这其中的$h$，代表$hypothesis$，由流程图可以看出，它是由数据集与学习算法得来的，在数学模型中，它代表回归模型，在机器学习中，我们通常把它称作假设函数。</p><script type="math/tex; mode=display">\begin{align}how\quad &to \quad represent \quad h \quad ?\\h_{\theta}(x)&=\theta_0+\theta_1x\end{align}</script><p>以上便是我们在一元线性回归模型中的假设函数了，可以看出，实际上我们是对数据集拟合了一个一次函数，所以我们才说是线性回归，那么实际的问题中，当然不是所有问题都是线性的关系，这个我们之后再去说。好了，目前为止，我已经解释了所有关于一元线性回归模型的意义了，下面我们来看点重要的。</p><h4 id="2-代价函数-cost-function"><a href="#2-代价函数-cost-function" class="headerlink" title="2. 代价函数 cost function"></a>2. 代价函数 cost function</h4><p><img src="/../image/ml3.jpg" alt=""></p><p>下面我们来看个更具体的例子，我们已经给出了数据集，要求求出Size和Price的内在关系，可以很明显的知道这是个一元回归问题，至于线性，这个我们不是我们现在需要考虑的，我们就当它拟合为线性一次函数。首先先解释数据集中几个变量符号的意义：</p><ul><li><strong>m：数据集的数量</strong></li><li><strong>x：特征/输入变量</strong>      $x^{(i)}$代表第i个特征$(i=1,2,…,m)$</li><li><strong>y：目标/输出变量</strong>      $y^{(i)}$代表第i个目标$(i=1,2,…,m)$</li></ul><p>当然不同的人有不同的表示方法，我相信这不是比较关键的东西，whatever。我们还是需要得到我们的假设函数$h_{\theta}(x)=\theta_0+\theta_1x$，如何选择$\theta_i$，即参数，才是我们需要关注的问题。ps：之后的$h_{\theta}(x)$全部简写为$h(x)$</p><p>我们的目的当然是，一次线性函数与原数据集有高度的拟合，即我们假设函数$h(x)$得到的结果与原目标$y$差距越小越好，于是我们得到了我们所谓的回归目标：</p><script type="math/tex; mode=display">min_{\theta_i}:\frac{1}{2m}\sum_{i=1}^m \left(h(x^{(i)})-y^{(i)}\right)^2</script><p>这其实是个方差公式的形式，我们添上了系数1/2。然后很明显地，我们完全可以用这个函数来判断我们的拟合程度，这个值越小就说明我们的拟合效果越好。于是，我们就规定了一个函数：</p><script type="math/tex; mode=display">J(\theta_i)=\frac{1}{2m}\sum_{i=1}^m \left(h(x^{(i)})-y^{(i)}\right)^2</script><p>然而这个函数就是<strong>代价函数(cost function)</strong>，表面意思就是为了拟合某个数据集，我们所需要付出的代价。在所有机器学习的问题中，我们都在研究如何使得代价函数最小，也就是我们上面所说的回归目标。</p><p><img src="/../image/ml4.jpg" alt=""></p><p>解决问题时，我们通常会有两张常见的可视化图片，第一张是$h(x)$的图，也就是Size和Price的数据集的图，第二张图是关于代价函数的，也有画三维图的，当然也有这种画等高线的。在接下来的问题中，我们会研究通过何种算法，让机器帮助我们找到最优目标的参数值。</p><h4 id="3-梯度下降算法-Gradient-Descent-Algorithm"><a href="#3-梯度下降算法-Gradient-Descent-Algorithm" class="headerlink" title="3. 梯度下降算法  Gradient Descent Algorithm"></a>3. 梯度下降算法  Gradient Descent Algorithm</h4><p>再次明确我们的模型函数，我们现在有$J(\theta_i)$,目标是让这个函数得到最小值。朴素的思想就是我们可以定起始的$\theta_i$，然后不断地改变他们，直到他们最后到达了最小值。很明显，这样的想法我们还需要更可靠的算法，毕竟全部遍历是不可能的。</p><p>所以这也就引入了梯度下降算法来解决这个问题，先给大家看某个代价函数，以及算法实现的某个过程。</p><p><img src="/../image/ml5.jpg" alt=""></p><p>想法不变，我们从某个$(\theta_0,\theta_1)$开始，不断改变他们的值，直到收敛到局部最优。而这个改变的过程我们称为梯度下降，为了方便理解，我直接给出参数改变的公式，也就是$\theta_i$不断更新的依据，假设仅有两个参数的时候。</p><script type="math/tex; mode=display">\theta_j:=\theta_j-\alpha \frac{\partial}{\partial \theta_j}J(\theta_0,\theta_1) \quad (j=0,1)</script><p>这便是梯度下降最关键的地方，其中有了偏导数符号，这个如果看不懂的话，还是要先学微积分的。仔细想想的话，这样确实能通过下降的方式，使得代价函数收敛到局部最优解。其中$\alpha$代表学习率，你可以理解为每次更新的步长，这个也很关键，但是之后我们也会提到。</p><p>还有需要强调的是，我们的$\theta_i$是同步更新(Simultaneous update)的，这个如果你学过计算方法这门课中求解微分方程的两种方法或许你应该深有体会。</p><p>下面这个例子是同步更新</p><script type="math/tex; mode=display">\begin{align}\\Correct&:Simultaneous \quad update\\temp0&:=\theta_0-\alpha \frac{\partial}{\partial \theta_0}J(\theta_0,\theta_1)\\temp1&:=\theta_1-\alpha \frac{\partial}{\partial \theta_1}J(\theta_0,\theta_1)\\\theta_0&:=temp0\\\theta_1&:=temp1\end{align}</script><p>然后这是不同步更新的例子</p><script type="math/tex; mode=display">\begin{align}Inco&rrect:\\temp0&:=\theta_0-\alpha \frac{\partial}{\partial \theta_0}J(\theta_0,\theta_1)\\\theta_0&:=temp0\\temp1&:=\theta_1-\alpha \frac{\partial}{\partial \theta_1}J(\theta_0,\theta_1)\\\theta_1&:=temp1\end{align}</script><p>在不同步更新的例子中我们发现，$\theta_0$更新后带入了$\theta_1$的更新公式中，这不是我们想要的。</p><p>理解清楚了这个后，我们就明白了梯度下降法的公式了，你可能会说选择不同的开始的起始值会导致不同的收敛点，确实是这样，比如下面这个图。</p><p><img src="/../image/ml6.jpg" alt=""></p><p>很显然因为选择了不同的$\theta_i$会导致两种不同的路线，通过梯度下降算法我们只能找到局部收敛点，而不是全局最优点。不过这也没关系，我们处理问题的时候都尽量会选择弓形函数，也就是<strong>凸函数(convex function)</strong>.这种函数我们保证它仅有一个收敛点，即全局最优解。</p><h3 id="多元线性回归-Linear-Regression-with-Multiple-Variables"><a href="#多元线性回归-Linear-Regression-with-Multiple-Variables" class="headerlink" title="多元线性回归  Linear Regression with Multiple Variables"></a>多元线性回归  Linear Regression with Multiple Variables</h3><h4 id="1-模型描述-多特征"><a href="#1-模型描述-多特征" class="headerlink" title="1. 模型描述 多特征"></a>1. 模型描述 多特征</h4><p>我们根据上面那个房价的例子，很显然在实际的生活中，房价Price绝不可能只与其Size有关系的，你的北京六环和二环的房子能比得起来吗？哦，我知道你没有。这里还是根据那个房价的例子，不过我们提出了更多的影响因素。</p><p><img src="/../image/ml7.jpg" alt=""></p><p>我们还是首先来规定下符号：</p><ul><li><strong>m：数据集的数量</strong></li><li><strong>n：特征的个数</strong>  例如此例n=4</li><li><strong>$x^{(i)}$：序号为i的数据集的特征向量</strong></li><li><strong>$x_j^{(i)}$：序号为i的数据集的第j个特征</strong>  比如40年我们如何表示？ $x_4^{(2)}$=40</li></ul><p>假设函数那当然也是多变量的了，我默认大家都学完了矩阵的东西，所以我就直接用矩阵的表示形式来列了。</p><script type="math/tex; mode=display">\begin{align}h(x)&=\theta_0+\theta_1x_1+\theta_2x_2+...+\theta_nx_n\\define \quad x_0&=1\\x=\begin{bmatrix} x_0\\x_1\\x_2\\\vdots\\x_n \end{bmatrix} \quad& \theta=\begin{bmatrix} \theta_0\\\theta_1\\\theta_2\\\vdots\\\theta_n \end{bmatrix}\\h(x)&=\theta^Tx\end{align}</script><p>我们采用矩阵的表达方式，已经写出了假设函数的矩阵形式，很简单，那下面就来说说如何在这个假设函数中进行梯度下降。</p><h4 id="2-多变量梯度下降"><a href="#2-多变量梯度下降" class="headerlink" title="2. 多变量梯度下降"></a>2. 多变量梯度下降</h4><p>其实梯度下降的公式都是一样的，只不过原来一元的时候只需要更新两个$\theta$值，现在需要更新n个，仅此而已。</p><script type="math/tex; mode=display">\theta_j:=\theta_j-\alpha \frac{\partial}{\partial \theta_j}J(\theta) \quad (j=0,1,...,n)</script><p>但是我们需要注意的，可不是这些。</p><h5 id="1-特征缩放"><a href="#1-特征缩放" class="headerlink" title="(1) 特征缩放"></a>(1) 特征缩放</h5><p>线性回归的目的就是在于求出我们所需要的权重，即$\theta$值，而权重和每个特征量的大小相关。试想一下，如果一个房间的Size的范围是1000左右，而房子的楼层是3以内的数，那我们直接拟合出来的权重，肯定更偏向于Size啊，而这显然不符合实际情况。这就是多元回归区别于一元回归的事情，一元回归就一个变量，咱们不需要考虑其大小范围。但是多元我们必须考虑，我们最好能够将所有变量统一缩放到某个区间，比如$-1\leq x_i\leq 1$。当然这个区间不是必须的，这里只给个参考范围。而对于所有的变量，我们都需要先进行<strong>均值标准化(Mean Normalization)</strong> 的处理。</p><script type="math/tex; mode=display">\begin{align}Mean &\quad Normalization:\\x_j&:=\frac{x_j-\mu_j}{\sigma_j}\end{align}</script><p>我相信如果你学过概率论的话，这个式子应该经常出现，不管是在八大公式还是假设检验里面。还是需要解释一下，这其中$\mu_j$表示第j组特征向量的均值，而$\sigma_j$表示第j组数据的标准差。</p><h5 id="2-特征合并"><a href="#2-特征合并" class="headerlink" title="(2) 特征合并"></a>(2) 特征合并</h5><p>这个是很好理解，也算是多元线性回归里面的一点技巧。比如题目给出的因素中，Price与房子的frontage和depth有关，那我们就要想到$Size=Frontage\times Depth$。于是我们就能把这个两个特征当成一个来处理，其实实际问题中这样的例子还是挺常见的。</p><h5 id="3-学习率与假设函数选择"><a href="#3-学习率与假设函数选择" class="headerlink" title="(3) 学习率与假设函数选择"></a>(3) 学习率与假设函数选择</h5><p>关于学习率$\alpha$与假设函数次项的选择，我在这里就不明说了，因为我自己也不是很能给出一个具体的方案。以及这样的情况遇到的较少。</p><h3 id="正规方程求解参数-Normal-Equation"><a href="#正规方程求解参数-Normal-Equation" class="headerlink" title="正规方程求解参数  Normal Equation"></a>正规方程求解参数  Normal Equation</h3><p>事实上，我们除了梯度下降法，还有另一种方法求解我们所需要的参数以及权重$\theta$的方法，就是用普通的方程求解，剩下的交给MATLAB就好，以上面那个例子来说明。</p><p><img src="/../image/ml7.jpg" alt=""></p><p>我们希望求得一组$\theta$值，能够假设函数能够很好地拟合最终的Price，其实我们不难列出我们的假设函数：</p><script type="math/tex; mode=display">h(x)=\begin{bmatrix}1 & 2104 & 5 &1 &45\\1 & 1416 & 3 &2 &40\\\vdots & \vdots & \vdots & \vdots & \vdots\end{bmatrix}\times\begin{bmatrix}\theta_0 \\\theta_1 \\\vdots \\\theta_n\end{bmatrix}=X\theta</script><p>实际上我们添加了$x_0=1$这一项，如果能够理解的话，那说明你基本明白了线性回归的知识点。然后我们要用Normal的方法解得我们需要的$\theta$：</p><script type="math/tex; mode=display">\theta = (X^TX)^{-1}X^Ty \quad ,\quad y=\begin{bmatrix} 460\\232\\315\\178\\ \vdots\end{bmatrix}</script><p>很遗憾地告诉你，我并不能告诉你这个方程是怎么推出来的，其实你也不需要理解。在数学建模竞赛或是机器学习研究中，我们大部分情况下只需要会用即可。</p><p>ok，到这里关于线性回归模型的求解，你已经学会了两种方法，梯度下降算法与正规方程解法，你可能会觉得正规方程解法会比较方便，下面我就来说说正规方程解法的局限性。</p><ul><li>正规方程解法需要计算矩阵的逆，当特征数大于样本数时，矩阵为奇异矩阵，无逆矩阵，虽然MATLAB命令<code>pinv</code>也能得到近似解，但是这往往不符合我们的预测要求。</li><li>当样本数量也特别大的时候，矩阵计算会非常缓慢，通常几千以内的矩阵，MATLAB计算还是比梯度下降快的，数量再往上我们可能就要选择梯度下降法了。</li></ul><p>当然梯度下降法也要选择学习率与迭代次数，这就需要我们理解代价函数，并根据此来判断。Emmm，说到这里，线性回归的内容基本就结束了，我可能会遗憾的告诉你，大部分数学建模竞赛或是机器学习问题，光靠线性回归模型基本不可能解决问题，因为真正的实际问题是线性关系的真的很少，但是这并不影响线性回归依旧是你最需要掌握的算法，这是所有其他问题的基础。</p><p>Good Luck！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你可能会发现这篇博客与我之前的机器学习的线性回归完全一样，没错，就是一样的。知识点都是线性回归，所以能有什么区别呢，线性回归模型都是数学模型与机器学习中最基础的模型，需要注意的是，学校老师培训的数学建模竞赛培训可能更重视原理，导致大部分同学听了个寂寞。但是往往比赛我们会使用就行，不用太过于纠结，另外题目与源代码之后补上2333。&lt;/p&gt;
&lt;h3 id=&quot;一元线性回归-单变量线性回归-Linear-Regression-with-one-variable&quot;&gt;&lt;a href=&quot;#一元线性回归-单变量线性回归-Linear-Regression-with-one-variable&quot; class=&quot;headerlink&quot; title=&quot;一元线性回归(单变量线性回归)  Linear Regression with one variable&quot;&gt;&lt;/a&gt;一元线性回归(单变量线性回归)  Linear Regression with one variable&lt;/h3&gt;
    
    </summary>
    
    
      <category term="数学建模" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="模型篇" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E6%A8%A1%E5%9E%8B%E7%AF%87/"/>
    
    
      <category term="线性回归" scheme="http://yoursite.com/tags/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>【吴恩达笔记】线性回归</title>
    <link href="http://yoursite.com/2020/06/27/%E3%80%90%E5%90%B4%E6%81%A9%E8%BE%BE%E7%AC%94%E8%AE%B0%E3%80%91%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    <id>http://yoursite.com/2020/06/27/%E3%80%90%E5%90%B4%E6%81%A9%E8%BE%BE%E7%AC%94%E8%AE%B0%E3%80%91%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</id>
    <published>2020-06-27T14:58:06.000Z</published>
    <updated>2020-06-28T12:16:35.667Z</updated>
    
    <content type="html"><![CDATA[<p>吴恩达老师的机器学习公开课应该算是目前我见过，最适合小白入门的公开课程了。即使内容对新人比较友好，但我想还是需要整理些许笔记的，因为涉及到机器学习的基础阶段，各个概念的掌握情况，我跳过了一些对我个人而言不重要的栏目，比如线性代数和matlab教程这些。之后也会补上上课的作业，Coursera申请助学金需要时间比较久。</p><h3 id="一元线性回归-单变量线性回归-Linear-Regression-with-one-variable"><a href="#一元线性回归-单变量线性回归-Linear-Regression-with-one-variable" class="headerlink" title="一元线性回归(单变量线性回归)  Linear Regression with one variable"></a>一元线性回归(单变量线性回归)  Linear Regression with one variable</h3><a id="more"></a><h4 id="1-模型描述"><a href="#1-模型描述" class="headerlink" title="1. 模型描述"></a>1. 模型描述</h4><p>首先明确线性回归的作用，在机器学习中，我们可以广义的把机器学习划分为两类学习，监督学习与无监督学习。简单而言，监督学习就是给出了准确答案，期望计算机能学习其中的原理，并对我们未知的事情做出一定的预测。无监督学习就是指，我们并不知道准确结果的事情，希望机器通过学习，能从中抽取有效信息，举个简单的例子，例如邮箱垃圾邮件分类，新闻栏目划分等等，这些我们都能通过无监督学习去解决。</p><p>好了下面再举一个关于监督学习的例子，吴老师上课的例子是房价预估，如下图所示。</p><p><img src="/../image/ml1.jpg" alt=""></p><p>给你一定数量的数据集，代表房屋尺寸与价格的散点图，现在你希望知道除这些数据集以外的Size所对应的Price，相当于我之前说的预测。比如Size为1250时，那Price可能为2200左右这样子。那这个过程，我们实际就是想从现已知的数据集中学习某些知识内容，从而达到预测的效果。而这个过程就是我们所说的，<strong>回归</strong>。</p><p>其实就是拟合函数曲线，从而达到其与数据集的最优拟合，然后预测所有的Size。由于这个房子的单价这个假设中只与Size有关，所以我们称它为单变量或是一元。</p><p>下图是关于机器学习的基本流程图，你可以认为几乎所有机器学习问题都是这个框架的东西。</p><p><img src="/../image/ml2.jpg" alt=""></p><p>而这其中的$h$，代表$hypothesis$，由流程图可以看出，它是由数据集与学习算法得来的，在数学模型中，它代表回归模型，在机器学习中，我们通常把它称作假设函数。</p><script type="math/tex; mode=display">\begin{align}how\quad &to \quad represent \quad h \quad ?\\h_{\theta}(x)&=\theta_0+\theta_1x\end{align}</script><p>以上便是我们在一元线性回归模型中的假设函数了，可以看出，实际上我们是对数据集拟合了一个一次函数，所以我们才说是线性回归，那么实际的问题中，当然不是所有问题都是线性的关系，这个我们之后再去说。好了，目前为止，我已经解释了所有关于一元线性回归模型的意义了，下面我们来看点重要的。</p><h4 id="2-代价函数-cost-function"><a href="#2-代价函数-cost-function" class="headerlink" title="2. 代价函数 cost function"></a>2. 代价函数 cost function</h4><p><img src="/../image/ml3.jpg" alt=""></p><p>下面我们来看个更具体的例子，我们已经给出了数据集，要求求出Size和Price的内在关系，可以很明显的知道这是个一元回归问题，至于线性，这个我们不是我们现在需要考虑的，我们就当它拟合为线性一次函数。首先先解释数据集中几个变量符号的意义：</p><ul><li><strong>m：数据集的数量</strong></li><li><strong>x：特征/输入变量</strong>      $x^{(i)}$代表第i个特征$(i=1,2,…,m)$</li><li><strong>y：目标/输出变量</strong>      $y^{(i)}$代表第i个目标$(i=1,2,…,m)$</li></ul><p>当然不同的人有不同的表示方法，我相信这不是比较关键的东西，whatever。我们还是需要得到我们的假设函数$h_{\theta}(x)=\theta_0+\theta_1x$，如何选择$\theta_i$，即参数，才是我们需要关注的问题。ps：之后的$h_{\theta}(x)$全部简写为$h(x)$</p><p>我们的目的当然是，一次线性函数与原数据集有高度的拟合，即我们假设函数$h(x)$得到的结果与原目标$y$差距越小越好，于是我们得到了我们所谓的回归目标：</p><script type="math/tex; mode=display">min_{\theta_i}:\frac{1}{2m}\sum_{i=1}^m \left(h(x^{(i)})-y^{(i)}\right)^2</script><p>这其实是个方差公式的形式，我们添上了系数1/2。然后很明显地，我们完全可以用这个函数来判断我们的拟合程度，这个值越小就说明我们的拟合效果越好。于是，我们就规定了一个函数：</p><script type="math/tex; mode=display">J(\theta_i)=\frac{1}{2m}\sum_{i=1}^m \left(h(x^{(i)})-y^{(i)}\right)^2</script><p>然而这个函数就是<strong>代价函数(cost function)</strong>，表面意思就是为了拟合某个数据集，我们所需要付出的代价。在所有机器学习的问题中，我们都在研究如何使得代价函数最小，也就是我们上面所说的回归目标。</p><p><img src="/../image/ml4.jpg" alt=""></p><p>解决问题时，我们通常会有两张常见的可视化图片，第一张是$h(x)$的图，也就是Size和Price的数据集的图，第二张图是关于代价函数的，也有画三维图的，当然也有这种画等高线的。在接下来的问题中，我们会研究通过何种算法，让机器帮助我们找到最优目标的参数值。</p><h4 id="3-梯度下降算法-Gradient-Descent-Algorithm"><a href="#3-梯度下降算法-Gradient-Descent-Algorithm" class="headerlink" title="3. 梯度下降算法  Gradient Descent Algorithm"></a>3. 梯度下降算法  Gradient Descent Algorithm</h4><p>再次明确我们的模型函数，我们现在有$J(\theta_i)$,目标是让这个函数得到最小值。朴素的思想就是我们可以定起始的$\theta_i$，然后不断地改变他们，直到他们最后到达了最小值。很明显，这样的想法我们还需要更可靠的算法，毕竟全部遍历是不可能的。</p><p>所以这也就引入了梯度下降算法来解决这个问题，先给大家看某个代价函数，以及算法实现的某个过程。</p><p><img src="/../image/ml5.jpg" alt=""></p><p>想法不变，我们从某个$(\theta_0,\theta_1)$开始，不断改变他们的值，直到收敛到局部最优。而这个改变的过程我们称为梯度下降，为了方便理解，我直接给出参数改变的公式，也就是$\theta_i$不断更新的依据，假设仅有两个参数的时候。</p><script type="math/tex; mode=display">\theta_j:=\theta_j-\alpha \frac{\partial}{\partial \theta_j}J(\theta_0,\theta_1) \quad (j=0,1)</script><p>这便是梯度下降最关键的地方，其中有了偏导数符号，这个如果看不懂的话，还是要先学微积分的。仔细想想的话，这样确实能通过下降的方式，使得代价函数收敛到局部最优解。其中$\alpha$代表学习率，你可以理解为每次更新的步长，这个也很关键，但是之后我们也会提到。</p><p>还有需要强调的是，我们的$\theta_i$是同步更新(Simultaneous update)的，这个如果你学过计算方法这门课中求解微分方程的两种方法或许你应该深有体会。</p><p>下面这个例子是同步更新</p><script type="math/tex; mode=display">\begin{align}\\Correct&:Simultaneous \quad update\\temp0&:=\theta_0-\alpha \frac{\partial}{\partial \theta_0}J(\theta_0,\theta_1)\\temp1&:=\theta_1-\alpha \frac{\partial}{\partial \theta_1}J(\theta_0,\theta_1)\\\theta_0&:=temp0\\\theta_1&:=temp1\end{align}</script><p>然后这是不同步更新的例子</p><script type="math/tex; mode=display">\begin{align}Inco&rrect:\\temp0&:=\theta_0-\alpha \frac{\partial}{\partial \theta_0}J(\theta_0,\theta_1)\\\theta_0&:=temp0\\temp1&:=\theta_1-\alpha \frac{\partial}{\partial \theta_1}J(\theta_0,\theta_1)\\\theta_1&:=temp1\end{align}</script><p>在不同步更新的例子中我们发现，$\theta_0$更新后带入了$\theta_1$的更新公式中，这不是我们想要的。</p><p>理解清楚了这个后，我们就明白了梯度下降法的公式了，你可能会说选择不同的开始的起始值会导致不同的收敛点，确实是这样，比如下面这个图。</p><p><img src="/../image/ml6.jpg" alt=""></p><p>很显然因为选择了不同的$\theta_i$会导致两种不同的路线，通过梯度下降算法我们只能找到局部收敛点，而不是全局最优点。不过这也没关系，我们处理问题的时候都尽量会选择弓形函数，也就是<strong>凸函数(convex function)</strong>.这种函数我们保证它仅有一个收敛点，即全局最优解。</p><h3 id="多元线性回归-Linear-Regression-with-Multiple-Variables"><a href="#多元线性回归-Linear-Regression-with-Multiple-Variables" class="headerlink" title="多元线性回归  Linear Regression with Multiple Variables"></a>多元线性回归  Linear Regression with Multiple Variables</h3><h4 id="1-模型描述-多特征"><a href="#1-模型描述-多特征" class="headerlink" title="1. 模型描述 多特征"></a>1. 模型描述 多特征</h4><p>我们根据上面那个房价的例子，很显然在实际的生活中，房价Price绝不可能只与其Size有关系的，你的北京六环和二环的房子能比得起来吗？哦，我知道你没有。这里还是根据那个房价的例子，不过我们提出了更多的影响因素。</p><p><img src="/../image/ml7.jpg" alt=""></p><p>我们还是首先来规定下符号：</p><ul><li><strong>m：数据集的数量</strong></li><li><strong>n：特征的个数</strong>  例如此例n=4</li><li><strong>$x^{(i)}$：序号为i的数据集的特征向量</strong></li><li><strong>$x_j^{(i)}$：序号为i的数据集的第j个特征</strong>  比如40年我们如何表示？ $x_4^{(2)}$=40</li></ul><p>假设函数那当然也是多变量的了，我默认大家都学完了矩阵的东西，所以我就直接用矩阵的表示形式来列了。</p><script type="math/tex; mode=display">\begin{align}h(x)&=\theta_0+\theta_1x_1+\theta_2x_2+...+\theta_nx_n\\define \quad x_0&=1\\x=\begin{bmatrix} x_0\\x_1\\x_2\\\vdots\\x_n \end{bmatrix} \quad& \theta=\begin{bmatrix} \theta_0\\\theta_1\\\theta_2\\\vdots\\\theta_n \end{bmatrix}\\h(x)&=\theta^Tx\end{align}</script><p>我们采用矩阵的表达方式，已经写出了假设函数的矩阵形式，很简单，那下面就来说说如何在这个假设函数中进行梯度下降。</p><h4 id="2-多变量梯度下降"><a href="#2-多变量梯度下降" class="headerlink" title="2. 多变量梯度下降"></a>2. 多变量梯度下降</h4><p>其实梯度下降的公式都是一样的，只不过原来一元的时候只需要更新两个$\theta$值，现在需要更新n个，仅此而已。</p><script type="math/tex; mode=display">\theta_j:=\theta_j-\alpha \frac{\partial}{\partial \theta_j}J(\theta) \quad (j=0,1,...,n)</script><p>但是我们需要注意的，可不是这些。</p><h5 id="1-特征缩放"><a href="#1-特征缩放" class="headerlink" title="(1) 特征缩放"></a>(1) 特征缩放</h5><p>线性回归的目的就是在于求出我们所需要的权重，即$\theta$值，而权重和每个特征量的大小相关。试想一下，如果一个房间的Size的范围是1000左右，而房子的楼层是3以内的数，那我们直接拟合出来的权重，肯定更偏向于Size啊，而这显然不符合实际情况。这就是多元回归区别于一元回归的事情，一元回归就一个变量，咱们不需要考虑其大小范围。但是多元我们必须考虑，我们最好能够将所有变量统一缩放到某个区间，比如$-1\leq x_i\leq 1$。当然这个区间不是必须的，这里只给个参考范围。而对于所有的变量，我们都需要先进行<strong>均值标准化(Mean Normalization)</strong> 的处理。</p><script type="math/tex; mode=display">\begin{align}Mean &\quad Normalization:\\x_j&:=\frac{x_j-\mu_j}{\sigma_j}\end{align}</script><p>我相信如果你学过概率论的话，这个式子应该经常出现，不管是在八大公式还是假设检验里面。还是需要解释一下，这其中$\mu_j$表示第j组特征向量的均值，而$\sigma_j$表示第j组数据的标准差。</p><h5 id="2-特征合并"><a href="#2-特征合并" class="headerlink" title="(2) 特征合并"></a>(2) 特征合并</h5><p>这个是很好理解，也算是多元线性回归里面的一点技巧。比如题目给出的因素中，Price与房子的frontage和depth有关，那我们就要想到$Size=Frontage\times Depth$。于是我们就能把这个两个特征当成一个来处理，其实实际问题中这样的例子还是挺常见的。</p><h5 id="3-学习率与假设函数选择"><a href="#3-学习率与假设函数选择" class="headerlink" title="(3) 学习率与假设函数选择"></a>(3) 学习率与假设函数选择</h5><p>关于学习率$\alpha$与假设函数次项的选择，我在这里就不明说了，因为我自己也不是很能给出一个具体的方案。以及这样的情况遇到的较少。</p><h3 id="正规方程求解参数-Normal-Equation"><a href="#正规方程求解参数-Normal-Equation" class="headerlink" title="正规方程求解参数  Normal Equation"></a>正规方程求解参数  Normal Equation</h3><p>事实上，我们除了梯度下降法，还有另一种方法求解我们所需要的参数以及权重$\theta$的方法，就是用普通的方程求解，剩下的交给MATLAB就好，以上面那个例子来说明。</p><p><img src="/../image/ml7.jpg" alt=""></p><p>我们希望求得一组$\theta$值，能够假设函数能够很好地拟合最终的Price，其实我们不难列出我们的假设函数：</p><script type="math/tex; mode=display">h(x)=\begin{bmatrix}1 & 2104 & 5 &1 &45\\1 & 1416 & 3 &2 &40\\\vdots & \vdots & \vdots & \vdots & \vdots\end{bmatrix}\times\begin{bmatrix}\theta_0 \\\theta_1 \\\vdots \\\theta_n\end{bmatrix}=X\theta</script><p>实际上我们添加了$x_0=1$这一项，如果能够理解的话，那说明你基本明白了线性回归的知识点。然后我们要用Normal的方法解得我们需要的$\theta$：</p><script type="math/tex; mode=display">\theta = (X^TX)^{-1}X^Ty \quad ,\quad y=\begin{bmatrix} 460\\232\\315\\178\\ \vdots\end{bmatrix}</script><p>很遗憾地告诉你，我并不能告诉你这个方程是怎么推出来的，其实你也不需要理解。在数学建模竞赛或是机器学习研究中，我们大部分情况下只需要会用即可。</p><p>ok，到这里关于线性回归模型的求解，你已经学会了两种方法，梯度下降算法与正规方程解法，你可能会觉得正规方程解法会比较方便，下面我就来说说正规方程解法的局限性。</p><ul><li>正规方程解法需要计算矩阵的逆，当特征数大于样本数时，矩阵为奇异矩阵，无逆矩阵，虽然MATLAB命令<code>pinv</code>也能得到近似解，但是这往往不符合我们的预测要求。</li><li>当样本数量也特别大的时候，矩阵计算会非常缓慢，通常几千以内的矩阵，MATLAB计算还是比梯度下降快的，数量再往上我们可能就要选择梯度下降法了。</li></ul><p>当然梯度下降法也要选择学习率与迭代次数，这就需要我们理解代价函数，并根据此来判断。Emmm，说到这里，线性回归的内容基本就结束了，我可能会遗憾的告诉你，大部分数学建模竞赛或是机器学习问题，光靠线性回归模型基本不可能解决问题，因为真正的实际问题是线性关系的真的很少，但是这并不影响线性回归依旧是你最需要掌握的算法，这是所有其他问题的基础。</p><p>Good Luck！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;吴恩达老师的机器学习公开课应该算是目前我见过，最适合小白入门的公开课程了。即使内容对新人比较友好，但我想还是需要整理些许笔记的，因为涉及到机器学习的基础阶段，各个概念的掌握情况，我跳过了一些对我个人而言不重要的栏目，比如线性代数和matlab教程这些。之后也会补上上课的作业，Coursera申请助学金需要时间比较久。&lt;/p&gt;
&lt;h3 id=&quot;一元线性回归-单变量线性回归-Linear-Regression-with-one-variable&quot;&gt;&lt;a href=&quot;#一元线性回归-单变量线性回归-Linear-Regression-with-one-variable&quot; class=&quot;headerlink&quot; title=&quot;一元线性回归(单变量线性回归)  Linear Regression with one variable&quot;&gt;&lt;/a&gt;一元线性回归(单变量线性回归)  Linear Regression with one variable&lt;/h3&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="吴恩达课程笔记" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%90%B4%E6%81%A9%E8%BE%BE%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>【XDUACM暑培】二分法洛谷作业题解</title>
    <link href="http://yoursite.com/2020/06/25/%E3%80%90XDUACM%E6%9A%91%E5%9F%B9%E3%80%91%E4%BA%8C%E5%88%86%E6%B3%95%E6%B4%9B%E8%B0%B7%E4%BD%9C%E4%B8%9A%E9%A2%98%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/06/25/%E3%80%90XDUACM%E6%9A%91%E5%9F%B9%E3%80%91%E4%BA%8C%E5%88%86%E6%B3%95%E6%B4%9B%E8%B0%B7%E4%BD%9C%E4%B8%9A%E9%A2%98%E8%A7%A3/</id>
    <published>2020-06-24T18:13:49.000Z</published>
    <updated>2020-06-24T11:32:27.506Z</updated>
    
    <content type="html"><![CDATA[<p>二分法模板与思路可见我之前的<a href="[https://www.alpha-yang.cn/2020/06/25/%E3%80%90%E4%BA%8C%E5%88%86%E3%80%91%E6%80%9D%E8%B7%AF%E4%B8%8E%E6%A8%A1%E6%9D%BF/](https://www.alpha-yang.cn/2020/06/25/[二分]思路与模板/">二分博客</a>)或<a href="https://zhuanlan.zhihu.com/p/150570206" target="_blank" rel="noopener">知乎专栏</a>，这次作业的题目比较容易，相对于【图论与树】，所以我就先写题解了。</p><h4 id="P1024-一元三次方程求解"><a href="#P1024-一元三次方程求解" class="headerlink" title="P1024 一元三次方程求解"></a>P1024 一元三次方程求解</h4><p>题目地址：<a href="https://www.luogu.com.cn/problem/P1024" target="_blank" rel="noopener">P1024 一元三次方程求解</a></p><a id="more"></a><p>二分法，题目告诉你保证有三个根，且差的绝对值都大于1，那就是说明-100~100的区间，以1为间隔，每个小区间最多有一个根，那就好说了。先把这三个小区间给一个个揪出来，满足<code>f(i)*f(i+1)&lt;0</code>一定有一个实根在这个小区间里面，因为是精确到小数点后两位。为了继续能用整数二分法的模板，我们把所有数放大100倍，比如[15,16]的区间有根，那我们以1为步长遍历[1500,1600]出来除以100就行了(特别当心浮点数陷阱)。</p><p>再讲讲二分的部分，还是略微改动了下模板的。对于判断条件，我们分别左临界为<code>y</code>，右临界为<code>z</code>，中间点为<code>x</code>，如果<code>f(x)*f(y)&lt;=0</code>，那就说明我们需要让x作为新的右临界。</p><p>以此二分下去，直到剩下最小的区间，如[1559,1560]，只存在两个值了，分别是15.59和15.60。对于这两个数我们再选取计算离0近的返回作为我们的答案即可。</p><p>最后附上ac代码，对细节有注释。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> a,b,c,d;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span> <span class="comment">// 函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a*x*x*x+b*x*x+c*x+d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> p=x*<span class="number">1.00</span>/<span class="number">100</span>,q=y*<span class="number">1.00</span>/<span class="number">100</span>,r=z*<span class="number">1.00</span>/<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> (f(p)*f(q)&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left+<span class="number">1</span>&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        mid=(left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        (check(mid,left,right) ? left : right) =mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(f(left*<span class="number">1.00</span>/<span class="number">100</span>))&lt;=<span class="built_in">abs</span>(f(right*<span class="number">1.00</span>/<span class="number">100</span>))) <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">    <span class="keyword">int</span> i,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">-100</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (f(i*<span class="number">1.00</span>)*f((i+<span class="number">1</span>)*<span class="number">1.00</span>)&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            x=binary_search(i*<span class="number">100</span>,(i+<span class="number">1</span>)*<span class="number">100</span>)*<span class="number">1.00</span>/<span class="number">100</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%.2lf "</span>,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (f(i*<span class="number">1.00</span>)==<span class="number">0</span>) <span class="comment">// 如果区间上i正好等于0，单独判断，防止重判</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%.2lf "</span>,i*<span class="number">1.00</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ans==<span class="number">3</span>) <span class="keyword">break</span>; <span class="comment">// 题目保证有且仅有三个解，所以三个解的时候退出，可以节省一点时间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P2678-跳石头"><a href="#P2678-跳石头" class="headerlink" title="P2678 跳石头"></a>P2678 跳石头</h4><p>题目地址：<a href="https://www.luogu.com.cn/problem/P2678" target="_blank" rel="noopener">P2678 跳石头</a></p><p>很经典的OI题目，也是道很经典的二分题，看到最值这些问题，先考虑二分的flag。用二分法做题首先我们得明确二分的对象，很显然不可能是石头序号，所以应该是二分距离。简单点，题目问你啥你二分啥，下面来说说具体的思路。</p><p>不能被移走的石头束缚住，这是个前提。移走的石头数不是重点，<strong>需不需要移走才是重点</strong>。好吧，这么讲还是有点不形象，这题要我们求最短跳跃距离的最大值。思考一下，我们的二分是往上分的，如果<code>mid</code>满足条件，那就让<code>left=mid</code>，继续向上二分查找，看看有没有更大的可能结果。</p><p>下面就是判断条件，即什么样的<code>mid</code>满足条件，也是本题的核心思路所在。之前说了不能被移走的石头数量给束缚住，让我们反过来思考，为了达到这个最短跳跃距离，需要移走多少块石头。我们将距离设为<code>d[i]</code>，即第i个石头到起点的距离，以下为核心代码，<code>check</code>函数部分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s=<span class="number">0</span>,i=<span class="number">0</span>,flag=<span class="number">0</span>; <span class="comment">// s代表当前移走的石头数，i代表当前走到的石头序号，flag代表离i最近没被移走的石头序号</span></span><br><span class="line">    <span class="keyword">while</span> (i&lt;n+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span> (d[i]-d[flag]&lt;x) s++;</span><br><span class="line">        <span class="keyword">else</span> flag=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s&lt;=m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置三个变量s，i，flag。如果我们发现<code>d[i]-d[flag]&lt;x</code>，那就说明这两块石头中间的石头必须挪走(中间肯定有石头，因为二分的初始值就是距离的一半)，反之则flag也前移。如果需要移走的石头数大于我们题目组委会移走的石头数，对不起，不符合条件。这时我们再向下二分查找，以此类推。</p><p>最后附上ac代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">5e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> d[maxn];</span><br><span class="line"><span class="keyword">int</span> l,m,n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s=<span class="number">0</span>,i=<span class="number">0</span>,flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;n+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span> (d[i]-d[flag]&lt;x) s++;</span><br><span class="line">        <span class="keyword">else</span> flag=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s&lt;=m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left+<span class="number">1</span>&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        mid=(left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        (check(mid) ? left : right) =mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> check(right) ? right : left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;l&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;d[i];</span><br><span class="line">    d[n+<span class="number">1</span>]=l;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;binary_search(<span class="number">1</span>,l)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P3853-TJOI2007-路标设置"><a href="#P3853-TJOI2007-路标设置" class="headerlink" title="P3853 [TJOI2007]路标设置"></a>P3853 [TJOI2007]路标设置</h4><p>题目地址：<a href="https://www.luogu.com.cn/problem/P3853" target="_blank" rel="noopener">P3853 [TJOI2007]路标设置</a></p><p>这个题目啊，几乎和P2678跳石头一模一样，甚至还要更简单一点。“空旷指数”就是距离，那此题我们就对距离进行二分。跳石头是移走石头，本题是加路标，思路几乎一模一样。</p><p>要我们求最小空旷指数，这就不一样了，这是向下二分，如果<code>mid</code>满足条件，那我们就得让<code>mid=right</code>，进行更小的可能值的查找了。</p><p>上面那点明确后，我们再来确定判断条件，也就是核心思想的部分。一样的本题加路牌，为了验证<code>mid</code>是否符合条件，我们算出两两路牌之间的距离，<code>a[i]</code>表示第i个路牌的距离，如果<code>a[i+1]-a[i]&gt;mid</code>，那就i和i+1中间得加路牌，那加几个呢？用距离除以mid即可，但一定小心一个整除的问题，例如<code>mid=5,a[i+1]-a[i]=10</code>时，虽然除的结果是2，但实际上距离为10的中间只需要差一块路牌即可。这是我们就需要对于整除的情况减一了，整数情况可以这样判断<code>(a[i+1]-a[i])/x*x==a[i+1]-a[i] ? 1 : 0</code>。附上核心代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>,i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;n+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span> (a[i+<span class="number">1</span>]-a[i]&gt;x) </span><br><span class="line">            ans+=(a[i+<span class="number">1</span>]-a[i])/x-((a[i+<span class="number">1</span>]-a[i])/x*x==a[i+<span class="number">1</span>]-a[i] ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans&lt;=k; <span class="comment">// 如果需要加的路牌小于等于规定加的路牌，则判断为真</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是<code>check</code>函数表示的永远是符合条件的判断，也就是说符合就是true，反之则是false。至于最大值最小值，那就是二分法里关于左右区间的判断了。</p><p>最后是完整ac代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> l,n,k;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>,i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;n+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span> (a[i+<span class="number">1</span>]-a[i]&gt;x) </span><br><span class="line">            ans+=(a[i+<span class="number">1</span>]-a[i])/x-((a[i+<span class="number">1</span>]-a[i])/x*x==a[i+<span class="number">1</span>]-a[i] ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans&lt;=k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left+<span class="number">1</span>&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        mid=(left+right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        (check(mid) ? right : left)=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> check(left) ? left : right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;l&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    a[n+<span class="number">1</span>]=l;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;binary_search(<span class="number">0</span>,l)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二分法模板与思路可见我之前的&lt;a href=&quot;[https://www.alpha-yang.cn/2020/06/25/%E3%80%90%E4%BA%8C%E5%88%86%E3%80%91%E6%80%9D%E8%B7%AF%E4%B8%8E%E6%A8%A1%E6%9D%BF/](https://www.alpha-yang.cn/2020/06/25/[二分]思路与模板/&quot;&gt;二分博客&lt;/a&gt;)或&lt;a href=&quot;https://zhuanlan.zhihu.com/p/150570206&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;知乎专栏&lt;/a&gt;，这次作业的题目比较容易，相对于【图论与树】，所以我就先写题解了。&lt;/p&gt;
&lt;h4 id=&quot;P1024-一元三次方程求解&quot;&gt;&lt;a href=&quot;#P1024-一元三次方程求解&quot; class=&quot;headerlink&quot; title=&quot;P1024 一元三次方程求解&quot;&gt;&lt;/a&gt;P1024 一元三次方程求解&lt;/h4&gt;&lt;p&gt;题目地址：&lt;a href=&quot;https://www.luogu.com.cn/problem/P1024&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;P1024 一元三次方程求解&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="ACM算法" scheme="http://yoursite.com/categories/ACM%E7%AE%97%E6%B3%95/"/>
    
      <category term="洛谷试炼场" scheme="http://yoursite.com/categories/ACM%E7%AE%97%E6%B3%95/%E6%B4%9B%E8%B0%B7%E8%AF%95%E7%82%BC%E5%9C%BA/"/>
    
    
      <category term="二分" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>【二分】思路与模板</title>
    <link href="http://yoursite.com/2020/06/25/%E3%80%90%E4%BA%8C%E5%88%86%E3%80%91%E6%80%9D%E8%B7%AF%E4%B8%8E%E6%A8%A1%E6%9D%BF/"/>
    <id>http://yoursite.com/2020/06/25/%E3%80%90%E4%BA%8C%E5%88%86%E3%80%91%E6%80%9D%E8%B7%AF%E4%B8%8E%E6%A8%A1%E6%9D%BF/</id>
    <published>2020-06-24T16:10:30.000Z</published>
    <updated>2020-06-24T11:33:57.164Z</updated>
    
    <content type="html"><![CDATA[<p>西电ACM暑假培训二分法课程，感谢柴东辰大佬的讲课！</p><p>二分算法，就是为了在<strong>单调</strong>的序列中寻找某个值，而每次选取中间位置，合理减少问题的规模，从而快速得到答案。</p><p>二分法，我想大家肯定都知道，这里我也不再赘述了，不过二分法的模板网上到处都是，但是有问题的也很多，比如这题是mid+1，那题是mid-1，也就是边界条件难以处理，很讨厌对吧？所以我这里介绍一种通用模板并分析思路。</p><a id="more"></a><p>哦对了，想给个标准的情景，1~n，查找x。就这么简单，暴力的话复杂度会达到O(n)，如果用二分法就是O(logn)了。废话不多说，直接上万用板(感谢柴大佬的模板)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> k)</span> <span class="comment">// 判断真假情况的，根据题目意思自己写不同的check函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> k&lt;=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left+<span class="number">1</span>&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        mid=(left+right)&gt;&gt;<span class="number">1</span>; <span class="comment">// 位运算加快速度</span></span><br><span class="line">        (check(mid) ? left : right) =mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> check(right) ? right : left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是个二分法模板，查找1~n的区间，可以查找的是任何东西。如果满足<code>left+1&lt;right</code>的条件，那就继续二分，反言之，如果<code>left+1&gt;=right</code>就不继续二分了。</p><p>二分求出左右区间的mid值，判断mid的条件，会根据题目改变而改变。此题的条件是，如果价格偏高返回false，此时让<code>right=mid</code>，如果价格偏低或者相等，返回true，此时让<code>left=mid</code>。知道区间仅剩下<code>left,right</code>两个数时，即条件<code>left+1&gt;=right</code>，此时我们需要查找的数一定在<code>left</code>和<code>right</code>之间了，这样很好理解了吧。</p><p>以上模板是稳定不易出错的写法，下面我们来尝试二分法的题目。</p><p>请移步我洛谷<a href="[https://www.alpha-yang.cn/2020/06/25/%E3%80%90XDUACM%E6%9A%91%E5%9F%B9%E3%80%91%E4%BA%8C%E5%88%86%E6%B3%95%E6%B4%9B%E8%B0%B7%E4%BD%9C%E4%B8%9A%E9%A2%98%E8%A7%A3/](https://www.alpha-yang.cn/2020/06/25/[XDUACM暑培]二分法洛谷作业题解/">二分博客</a>)或<a href="https://zhuanlan.zhihu.com/p/150570433" target="_blank" rel="noopener">知乎专栏</a>的题解。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;西电ACM暑假培训二分法课程，感谢柴东辰大佬的讲课！&lt;/p&gt;
&lt;p&gt;二分算法，就是为了在&lt;strong&gt;单调&lt;/strong&gt;的序列中寻找某个值，而每次选取中间位置，合理减少问题的规模，从而快速得到答案。&lt;/p&gt;
&lt;p&gt;二分法，我想大家肯定都知道，这里我也不再赘述了，不过二分法的模板网上到处都是，但是有问题的也很多，比如这题是mid+1，那题是mid-1，也就是边界条件难以处理，很讨厌对吧？所以我这里介绍一种通用模板并分析思路。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ACM算法" scheme="http://yoursite.com/categories/ACM%E7%AE%97%E6%B3%95/"/>
    
      <category term="西电培训笔记" scheme="http://yoursite.com/categories/ACM%E7%AE%97%E6%B3%95/%E8%A5%BF%E7%94%B5%E5%9F%B9%E8%AE%AD%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="二分" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>【图论与树】最短路径Dijkstra与Floyd算法</title>
    <link href="http://yoursite.com/2020/06/23/%E3%80%90%E5%9B%BE%E8%AE%BA%E4%B8%8E%E6%A0%91%E3%80%91%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84Dijkstra%E4%B8%8EFloyd%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/06/23/%E3%80%90%E5%9B%BE%E8%AE%BA%E4%B8%8E%E6%A0%91%E3%80%91%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84Dijkstra%E4%B8%8EFloyd%E7%AE%97%E6%B3%95/</id>
    <published>2020-06-23T10:05:20.000Z</published>
    <updated>2020-06-24T11:08:43.850Z</updated>
    
    <content type="html"><![CDATA[<p>在图论中有一个非常常见的问题，就是最短路径的问题。常见的最短路径算法有三种：dijkstra，floyd和SPFA。本文将带你了解前两种最短路算法，他们分别适用于不同场景下的问题。</p><p>以下笔记乃是参考西电ACM暑假培训张帆大佬的讲课以及<a href="https://www.cnblogs.com/xzxl/p/7266404.html" target="_blank" rel="noopener">优先队列博客</a></p><a id="more"></a><h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><p>首先我们必须了解这个算法的两个局限之处，才能做题</p><ul><li>不能适用于负权图</li><li>只适用于单源最短路问题</li></ul><p>如果权重是负数，那就直接pass这个算法，在这里原因不表。</p><p><strong>单源最短路径</strong>就是指只有一个出发点，到其他点的最短路径问题，以下问题也在这个前提下展开。</p><p>下面我们就来说说算法流程：</p><ul><li>S1. 设置dis数组，<code>dis[i]</code>表示起点start到i的距离。</li><li>S2. 从点集V中弹出一个dis值最小且未以该点为起点进行松弛操作的点。</li><li>S3. 从该点松弛与其领接的各个点更新dis数组，返回S2，循环进行。</li><li>通过优先队列的操作可以优化S2，之后详细说明。</li></ul><p><img src="https://i.loli.net/2020/06/23/T7m3JYt2evIwKLP.png" alt=""></p><p>如果这样说，有点抽象。那就举个例子。这个例子也是洛谷的单源最短路径的模板题，请求出1到各点的最短路？</p><p>很显然你用肉眼看，1到本身是0,1到2、3、4的最短路分别为2,4,3。那dijkstra的操作流程是什么呢？</p><p>首先我们先开一个dis数组，让数组的值足够大，<code>dis[i]=0x7fffffff</code>,从1开始出发，令<code>dis[1]=0</code>，发现与1相连的有三个点234，那我们一个个进行松弛操作，比较<code>if (dis[1]+w[i]&lt;dis[i])</code>,w表示各边的权重，如果小于，那就让其覆盖本身的dis值，即<code>dis[i]=dis[1]+w[i]</code>，这一波更新完后，234的值分别为2,5,4。</p><p>然后，我们需要让234全部入队，并选取dis值最小的数即2继续进行松弛操作，发现连接的是3和4，继续更新，这波结束，234的值分别为2,4,3。</p><p>接着，是上一轮dis值次小的点4，进行操作，但是4没有出的边，所以不进行操作。</p><p>最后就是剩下的一个3了，3和4还有一条权边，但是4最小的dis值依旧是3。</p><p>下面我们发现算法到这就截止了，为什么呢，因为S2的一句话，未进行松弛的点，早在第一轮234就已经全部进入过队列并且已经弹出过了，所以之后他们也不会再进入队列，我们可以设置一个bool类型的<code>vis[i]</code>数组代表第i个点是否被访问过了，如果访问过了就结束此循环，或者直接不push进入队列。</p><p>这就是整个dijkstra的算法，其实很好理解，证明我们就先略过了。</p><h4 id="优先队列priority-queue"><a href="#优先队列priority-queue" class="headerlink" title="优先队列priority_queue"></a>优先队列priority_queue</h4><p>上面那个算法有个问题，就是怎样才能保证每次弹出的都是dis最小的数呢？如果用普通队列，不能解决这个问题，如果每次都遍历一遍来找，那复杂度直接O(VE)，百分百会被T掉。</p><p>所以我们这里采用优先队列priority_queue对S2进行堆优化，就变成O((V+E)logV)了，所以做题的时候堆优化+dijkstra都是一起出现的，模板也是一起写的。</p><p><strong>优先队列</strong>：按照一定次序的队列结构，升序或降序，从小到大排列，push和pop都遵循其规律。</p><p>优先队列的详细用法请参照这篇<a href="https://www.cnblogs.com/xzxl/p/7266404.html" target="_blank" rel="noopener">博客</a>，本文仅描述dijkstra模板下的用法。</p><p>首先对于图论中的<strong>每条点</strong>，我们都需建立一个<code>node</code>结构体，包含两个内容<code>num</code>和<code>dis</code>。分别表示该点的序号以及dis值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num,dis;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue &lt;node&gt; q;</span><br></pre></td></tr></table></figure><p>然而这样建立优先队列是会报错的，因为优先队列无法对结构体进行优先级比较。所以我们就想办法告诉程序，我们的队列是对结构体的哪儿个值进行排序，其实做法有很多，我习惯的方式是采取重载的形式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num,dis;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;x)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.dis &lt; dis; <span class="comment">// dis小的结构体在队列中的优先级高</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue &lt;node&gt; q;</span><br></pre></td></tr></table></figure><p>请重载&lt;号，别重载&gt;会报错的。这里如果不理解的就死记硬背把，讲重载的话又要涉及很多知识。</p><h4 id="【模板】Dijkstra算法实现"><a href="#【模板】Dijkstra算法实现" class="headerlink" title="【模板】Dijkstra算法实现"></a>【模板】Dijkstra算法实现</h4><p>以洛谷模板题为例，<a href="https://www.luogu.com.cn/problem/P4779" target="_blank" rel="noopener">P4779 【模板】单源最短路径（标准版）</a></p><p>这道题目的样例就是我上面所举的例子。上面我们解决了算法思路，以及用优先队列的方式对步骤2弹出dis最小的点进行了堆优化，下面我们还需要解决程序细节的问题。</p><p>先是存边的问题，这道题不存在重边等为难我们的限制，所以直接构造结构体<code>edge</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,cost; <span class="comment">// to代表下一个点，cost代表该边的权重</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span> &lt;edge&gt; e[maxn];</span><br></pre></td></tr></table></figure><p>之后就是存边，然后进行Dijkstra算法，我直接上代码了，我的代码还是新手向的，不会设计复杂的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,cost;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num,dis;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;x)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.dis &lt; dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; e[maxm];</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn]; <span class="comment">// 布尔型vis数组</span></span><br><span class="line"><span class="keyword">int</span> n,m,s,cnt=<span class="number">0</span>;</span><br><span class="line">priority_queue &lt;node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> <span class="comment">// 存边</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[u].push_back((edge)&#123;v,w&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    q.push((node)&#123;s,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        node tmp=q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">int</span> x=tmp.num;</span><br><span class="line">        <span class="keyword">if</span> (vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[x]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (edge k:e[x]) <span class="comment">// 遍历边信息，请注意洛谷请选用c++11，否则编译错误</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[x] + k.cost &lt; dis[k.to])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[k.to]=dis[x]+k.cost;</span><br><span class="line">                <span class="keyword">if</span> (!vis[k.to]) q.push((node)&#123;k.to,dis[k.to]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) dis[i]=<span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        add_edge(u,v,w);</span><br><span class="line">    &#125;</span><br><span class="line">    dijkstra();</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cout</span>&lt;&lt;dis[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1608-路径统计"><a href="#P1608-路径统计" class="headerlink" title="P1608 路径统计"></a>P1608 路径统计</h4><p>题目地址：<a href="https://www.luogu.com.cn/problem/P1608" target="_blank" rel="noopener">P1608 路径统计</a></p><p>这题基本也是个Dijkstra的模板题，大方向都没有任何变化。我们首先先考虑一个比较简单的问题，就是题目中的重边该怎么去除，重边我们当然选择最短的那条边，其实也不复杂。我采取的方法是邻接矩阵的办法，再把邻接矩阵转为边信息，考虑到N最大值为2000，二维矩阵肯定不会炸。（忽略奇怪的缩进</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> p,q,c,tmp;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;p&gt;&gt;q&gt;&gt;c;</span><br><span class="line">        <span class="keyword">if</span> (cmp[i][j]==<span class="number">0</span> || c&lt;cmp[i][j]) cmp[i][j]=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span> (cmp[i][j]) e[i].push_back((edge)&#123;j,cmp[i][j]&#125;);</span><br></pre></td></tr></table></figure><p>这样就把重边给处理了，菜鸡的我也没想到其他方法了。。。</p><p>然后就是来处理本题的问题，最短路径非常简单，但是统计个数，还是需要思索一下的。我的办法是准备一个<code>ans</code>数组，<code>ans[i]</code>表示第i个点的最短路径的条数，好家伙！这样层层递推，就能推到第N个点了。</p><p>这样其实没啥问题，但是有可能统计第k个点，我统计了两条最短路径，突然来了一条更短的，这是我们的<code>ans[k]</code>从2又变回了1，好说！让k点的值等于最短路径上一个点的ans值就可以了。</p><p>所以核心代码如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dis[k.to]==dis[x]+k.w) ans[k.to]+=ans[x];</span><br><span class="line"><span class="keyword">if</span> (dis[k.to]&gt;dis[x]+k.w)</span><br><span class="line">&#123;</span><br><span class="line">    dis[k.to]=dis[x]+k.w;</span><br><span class="line">    ans[k.to]=ans[x];</span><br><span class="line">    q.push((node)&#123;dis[k.to],k.to&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是这样如果有相等的路径就相加，有小于的路径就让其ans值回去。如果最后的<code>dis[n]=0x7fffffff</code>，那说明根本没路径能到达它，无解。</p><p>最后附上ac代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=maxn*(maxn<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> dis,num;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;x)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.dis&lt;dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt;edge&gt; e[maxm];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">int</span> ans[maxn];</span><br><span class="line"><span class="keyword">int</span> cmp[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line">priority_queue &lt;node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    ans[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    q.push((node)&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        node tmp=q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">int</span> x=tmp.num;</span><br><span class="line">        <span class="keyword">if</span> (vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[x]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (edge k : e[x])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[k.to]==dis[x]+k.w) ans[k.to]+=ans[x];</span><br><span class="line">            <span class="keyword">if</span> (dis[k.to]&gt;dis[x]+k.w)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[k.to]=dis[x]+k.w;</span><br><span class="line">                ans[k.to]=ans[x];</span><br><span class="line">                q.push((node)&#123;dis[k.to],k.to&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) dis[i]=<span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> p,q,c,tmp;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;p&gt;&gt;q&gt;&gt;c;</span><br><span class="line">        <span class="keyword">if</span> (cmp[i][j]==<span class="number">0</span> || c&lt;cmp[i][j]) cmp[i][j]=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span> (cmp[i][j]) e[i].push_back((edge)&#123;j,cmp[i][j]&#125;);</span><br><span class="line">    dijkstra();</span><br><span class="line">    <span class="keyword">if</span> (dis[n]!=<span class="number">0x7fffffff</span>) <span class="built_in">cout</span>&lt;&lt;dis[n]&lt;&lt;<span class="string">" "</span>&lt;&lt;ans[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"No answer"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h3><p>著名的Floyd算法，算法的核心代码非常短，时间复杂度$O(V^3)$。采用邻接矩阵<code>arr[i][j]</code>的方式存图，三层循环不可调换。具体原理可以用dp来解释，在此不表。直接上核心代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=N;k++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=N;j++)</span><br><span class="line">            arr[i][j]=<span class="built_in">min</span>(arr[i][j],arr[i][k]+arr[k][j]);</span><br></pre></td></tr></table></figure><p>Floyd算法还需要看看练习题：<a href="https://www.luogu.com.cn/problem/P1119" target="_blank" rel="noopener">P1119 灾后重建</a></p><p>也可以看看我关与此题的题解，见<a href="[https://www.alpha-yang.cn/2020/06/23/%E3%80%90%E5%9B%BE%E8%AE%BA%E4%B8%8E%E6%A0%91%E3%80%91XDUACM%E6%9A%91%E5%9F%B9%E6%B4%9B%E8%B0%B7%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/](https://www.alpha-yang.cn/2020/06/23/[图论与树]XDUACM暑培洛谷算法题解/">个人博客</a>)或<a href="https://zhuanlan.zhihu.com/p/150134695" target="_blank" rel="noopener">知乎专栏</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在图论中有一个非常常见的问题，就是最短路径的问题。常见的最短路径算法有三种：dijkstra，floyd和SPFA。本文将带你了解前两种最短路算法，他们分别适用于不同场景下的问题。&lt;/p&gt;
&lt;p&gt;以下笔记乃是参考西电ACM暑假培训张帆大佬的讲课以及&lt;a href=&quot;https://www.cnblogs.com/xzxl/p/7266404.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;优先队列博客&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="ACM算法" scheme="http://yoursite.com/categories/ACM%E7%AE%97%E6%B3%95/"/>
    
      <category term="西电培训笔记" scheme="http://yoursite.com/categories/ACM%E7%AE%97%E6%B3%95/%E8%A5%BF%E7%94%B5%E5%9F%B9%E8%AE%AD%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>【图论与树】XDUACM暑培洛谷算法题解</title>
    <link href="http://yoursite.com/2020/06/23/%E3%80%90%E5%9B%BE%E8%AE%BA%E4%B8%8E%E6%A0%91%E3%80%91XDUACM%E6%9A%91%E5%9F%B9%E6%B4%9B%E8%B0%B7%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/06/23/%E3%80%90%E5%9B%BE%E8%AE%BA%E4%B8%8E%E6%A0%91%E3%80%91XDUACM%E6%9A%91%E5%9F%B9%E6%B4%9B%E8%B0%B7%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/</id>
    <published>2020-06-23T00:14:11.000Z</published>
    <updated>2020-06-24T11:23:08.098Z</updated>
    
    <content type="html"><![CDATA[<p>该博客所有题目均是西电ACM暑假培训洛谷团队的题目，目前共16题，之前一直在写题，本博客持续更新。</p><p>感谢校队张帆大佬的讲课(ID：孤月)。</p><p>由于本人太菜，本文将持续更新</p><a id="more"></a><h4 id="P3367-【模板】并查集"><a href="#P3367-【模板】并查集" class="headerlink" title="P3367 【模板】并查集"></a>P3367 【模板】并查集</h4><p>题目地址：<a href="https://www.luogu.com.cn/problem/P3367" target="_blank" rel="noopener">P3367 【模板】并查集</a></p><p>这道题目就是一道练习并查集模板的题目，关于并查集的概念不懂的，可以看我之前的<a href="[https://www.alpha-yang.cn/2020/06/23/%E3%80%90%E5%9B%BE%E8%AE%BA%E3%80%91%E5%B9%B6%E6%9F%A5%E9%9B%86/](https://www.alpha-yang.cn/2020/06/23/[图论]并查集/">博客</a>)或者<a href="https://zhuanlan.zhihu.com/p/150133028" target="_blank" rel="noopener">知乎专栏文章</a>。这题目判断是否在同一个集合的核心代码就是<code>if (find(x)==find(y))</code>，所以就直接上代码吧。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10005</span></span><br><span class="line"><span class="keyword">int</span> n,m,z,x,y;</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[k]==k) <span class="keyword">return</span> k;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> f[k]=<span class="built_in">find</span>(f[k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i]=i;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;z&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="keyword">if</span> (z==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            f[<span class="built_in">find</span>(x)]=<span class="built_in">find</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(x)==<span class="built_in">find</span>(y))</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">'Y'</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">'N'</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于初始化的问题，我们首先假设所有的老大都是自己，即<code>f[i]=i</code>。之后再进行集合的合并等操作，就是道练习模板的题目。</p><h4 id="P1525-关押罪犯"><a href="#P1525-关押罪犯" class="headerlink" title="P1525 关押罪犯"></a>P1525 关押罪犯</h4><p>题目地址：<a href="https://www.luogu.com.cn/problem/P1525" target="_blank" rel="noopener">P1525 关押罪犯</a></p><p>这道题目是一道淳朴的并查集的题目，相比于并查集模板不同的是，加入对思维的考验，也就是说，我怎样分配才能使冲突事件的等级最小。</p><p>并查集不知道是啥的，可以看我之前的<a href="[https://www.alpha-yang.cn/2020/06/23/%E3%80%90%E5%9B%BE%E8%AE%BA%E3%80%91%E5%B9%B6%E6%9F%A5%E9%9B%86/](https://www.alpha-yang.cn/2020/06/23/[图论]并查集/">博客</a>)或者<a href="https://zhuanlan.zhihu.com/p/150133028" target="_blank" rel="noopener">知乎专栏文章</a>。</p><p><strong>思考</strong>：我们绝不能让冲突矛盾最大的两个人在一个监狱，好那就先把他们拿出来，放到两个不同的监狱去。然后矛盾次大的两人也不能在一个监狱，放到两个不同监狱去。这就出现了一个问题，假设现在有四名罪犯_abcd_，其中ab的冲突最大，cd的冲突次大，很显然ab和cd不能在同一个监狱，那我们的组合是ac和bd还是ad和bc呢？</p><p>这时需要我们引入一个另外的概念，就是敌人的敌人就是朋友，其实也不一定是朋友，但是冲突会更小一点。讲具体点就是，我们现在用数组<code>re</code>来存放所有人冲突最大的敌人，比如<code>re[i]</code>表示第i个罪犯冲突最大的敌人，按照上面abcd的例子，即<code>re[a]=b,re[b]=a,re[c]=d,re[d]=c</code>，说到这里如果你还没理解我的做法，那我就引入更多的罪犯，假设他们与abcd都有或大或小的冲突，接下来来了个e，他与a有冲突，且冲突值仅次于cd的冲突值，这时e肯定不能和a一个监狱了，所以我们让b和e一个监狱，这就是上面所说的，<strong>敌人的敌人就是“朋友”</strong>。按照冲突值由大到小的顺序，那直到什么时候为止呢？</p><p><code>if (find(x)==find(y))</code>,直到发现冲突值为某个数的两名罪犯x和y他们已经在一个集合中了，他们的冲突已经不能避免了，后面的罪犯已经不用再考虑了，因为后面的罪犯不管怎么排，冲突值都不会大过x和y的冲突值了，题目只要求最大值。</p><p>总结一下这其实是个贪心的思想，但是比贪心容易得多，我们把冲突值从大到小排序，让冲突值最大的两名罪犯分开，并互相标记为敌人，以此类推，后面如果有罪犯e发现它的敌人a已经有敌人b了，那就让e和b在一个监狱，不管b和e有没有冲突，直到发现有冲突的两名罪犯已经在一个监狱的时候，直接输出他们的冲突值即可。</p><p>如果找到最后两名罪犯都发现他们不在一个监狱，那就说明可以完全避免冲突，输出<code>0</code>。</p><p>以下是代码，个人认为我的代码还是非常易于理解，且对新手友善的（大家轻喷</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> f[maxn],re[maxn],n,m; <span class="comment">// 数组f存放并查集，数组re表示敌人</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">&#125;v[maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span> <span class="comment">// 定义结构体的sort排序，根据c进行降序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.c&gt;y.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> k)</span> <span class="comment">// 并查集，找老大的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[k]==k) <span class="keyword">return</span> k;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> f[k]=<span class="built_in">find</span>(f[k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> <span class="comment">// 对两数进行合并操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[<span class="built_in">find</span>(x)]=<span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> <span class="comment">// 判断两数是否在同一个集合中</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(x)==<span class="built_in">find</span>(y); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">cin</span>&gt;&gt;v[i].a&gt;&gt;v[i].b&gt;&gt;v[i].c;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) f[i]=i;</span><br><span class="line">    sort(v+<span class="number">1</span>,v+m,cmp); <span class="comment">// 按照c即冲突值从大到小排序</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (check(v[i].a,v[i].b)) <span class="comment">// 如果发现a和b已经在一个监狱了，说明冲突无法避免，直接输出c</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;v[i].c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            getchar();getchar();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 后面的罪犯不用考虑，只求最大的冲突</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (re[v[i].a]) merge(re[v[i].a],v[i].b);<span class="comment">//发现a已经有敌人了，所以我们合并敌人的敌人</span></span><br><span class="line">            <span class="keyword">else</span> re[v[i].a]=v[i].b; <span class="comment">// 标记a和敌人是b</span></span><br><span class="line">            <span class="keyword">if</span> (re[v[i].b]) merge(re[v[i].b],v[i].a);</span><br><span class="line">            <span class="keyword">else</span> re[v[i].b]=v[i].a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P4779-【模板】单源最短路径（标准版）"><a href="#P4779-【模板】单源最短路径（标准版）" class="headerlink" title="P4779 【模板】单源最短路径（标准版）"></a>P4779 【模板】单源最短路径（标准版）</h4><p>题目地址：<a href="https://www.luogu.com.cn/problem/P4779" target="_blank" rel="noopener">P4779 【模板】单源最短路径（标准版）</a></p><p>Dijkstra模板题，可以详见我之前的<a href="http://link.zhihu.com/?target=https%3A//www.alpha-yang.cn/2020/06/23/%E3%80%90%E5%9B%BE%E8%AE%BA%E3%80%91%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84Dijkstra%E4%B8%8EFloyd%E7%AE%97%E6%B3%95/%23more">博客</a>或<a href="https://zhuanlan.zhihu.com/p/150434472" target="_blank" rel="noopener">知乎专栏</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,cost;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num,dis;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;x)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.dis &lt; dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;edge&gt; e[maxm];</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn]; <span class="comment">// 布尔型vis数组</span></span><br><span class="line"><span class="keyword">int</span> n,m,s,cnt=<span class="number">0</span>;</span><br><span class="line">priority_queue &lt;node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v,<span class="keyword">int</span> w)</span> <span class="comment">// 存边</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[u].push_back((edge)&#123;v,w&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    q.push((node)&#123;s,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        node tmp=q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">int</span> x=tmp.num;</span><br><span class="line">        <span class="keyword">if</span> (vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[x]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (edge k:e[x]) <span class="comment">// 遍历边信息，请注意洛谷请选用c++11，否则编译错误</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[x] + k.cost &lt; dis[k.to])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[k.to]=dis[x]+k.cost;</span><br><span class="line">                <span class="keyword">if</span> (!vis[k.to]) q.push((node)&#123;k.to,dis[k.to]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) dis[i]=<span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        add_edge(u,v,w);</span><br><span class="line">    &#125;</span><br><span class="line">    dijkstra();</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">cout</span>&lt;&lt;dis[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1608-路径统计"><a href="#P1608-路径统计" class="headerlink" title="P1608 路径统计"></a>P1608 路径统计</h4><p>题目地址：<a href="https://www.luogu.com.cn/problem/P1608" target="_blank" rel="noopener">P1608 路径统计</a></p><p>这题基本也是个Dijkstra的模板题，大方向都没有任何变化。我们首先先考虑一个比较简单的问题，就是题目中的重边该怎么去除，重边我们当然选择最短的那条边，其实也不复杂。我采取的方法是邻接矩阵的办法，再把邻接矩阵转为边信息，考虑到N最大值为2000，二维矩阵肯定不会炸。（忽略奇怪的缩进</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> p,q,c,tmp;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;p&gt;&gt;q&gt;&gt;c;</span><br><span class="line">        <span class="keyword">if</span> (cmp[i][j]==<span class="number">0</span> || c&lt;cmp[i][j]) cmp[i][j]=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span> (cmp[i][j]) e[i].push_back((edge)&#123;j,cmp[i][j]&#125;);</span><br></pre></td></tr></table></figure><p>这样就把重边给处理了，菜鸡的我也没想到其他方法了。。。</p><p>然后就是来处理本题的问题，最短路径非常简单，但是统计个数，还是需要思索一下的。我的办法是准备一个<code>ans</code>数组，<code>ans[i]</code>表示第i个点的最短路径的条数，好家伙！这样层层递推，就能推到第N个点了。</p><p>这样其实没啥问题，但是有可能统计第k个点，我统计了两条最短路径，突然来了一条更短的，这是我们的<code>ans[k]</code>从2又变回了1，好说！让k点的值等于最短路径上一个点的ans值就可以了。</p><p>所以核心代码如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dis[k.to]==dis[x]+k.w) ans[k.to]+=ans[x];</span><br><span class="line"><span class="keyword">if</span> (dis[k.to]&gt;dis[x]+k.w)</span><br><span class="line">&#123;</span><br><span class="line">    dis[k.to]=dis[x]+k.w;</span><br><span class="line">    ans[k.to]=ans[x];</span><br><span class="line">    q.push((node)&#123;dis[k.to],k.to&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是这样如果有相等的路径就相加，有小于的路径就让其ans值回去。如果最后的<code>dis[n]=0x7fffffff</code>，那说明根本没路径能到达它，无解。</p><p>最后附上ac代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=maxn*(maxn<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> dis,num;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;x)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.dis&lt;dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt;edge&gt; e[maxm];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> dis[maxn];</span><br><span class="line"><span class="keyword">int</span> ans[maxn];</span><br><span class="line"><span class="keyword">int</span> cmp[maxn][maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line">priority_queue &lt;node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    ans[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    q.push((node)&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        node tmp=q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">int</span> x=tmp.num;</span><br><span class="line">        <span class="keyword">if</span> (vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[x]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (edge k : e[x])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[k.to]==dis[x]+k.w) ans[k.to]+=ans[x];</span><br><span class="line">            <span class="keyword">if</span> (dis[k.to]&gt;dis[x]+k.w)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[k.to]=dis[x]+k.w;</span><br><span class="line">                ans[k.to]=ans[x];</span><br><span class="line">                q.push((node)&#123;dis[k.to],k.to&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) dis[i]=<span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> p,q,c,tmp;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;p&gt;&gt;q&gt;&gt;c;</span><br><span class="line">        <span class="keyword">if</span> (cmp[i][j]==<span class="number">0</span> || c&lt;cmp[i][j]) cmp[i][j]=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span> (cmp[i][j]) e[i].push_back((edge)&#123;j,cmp[i][j]&#125;);</span><br><span class="line">    dijkstra();</span><br><span class="line">    <span class="keyword">if</span> (dis[n]!=<span class="number">0x7fffffff</span>) <span class="built_in">cout</span>&lt;&lt;dis[n]&lt;&lt;<span class="string">" "</span>&lt;&lt;ans[n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">"No answer"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1119-灾后重建"><a href="#P1119-灾后重建" class="headerlink" title="P1119 灾后重建"></a>P1119 灾后重建</h4><p>题目地址：<a href="https://www.luogu.com.cn/problem/P1119" target="_blank" rel="noopener">P1119 灾后重建</a></p><p>很好的一道Floyd算法的练习题，首先Floyd算法的核心是不变的。其余思路真的很简单，非常淳朴的图，我们使用邻接矩阵来存图。邻接矩阵剩下的地方我们标记为一个很大的数，例如<code>1e9</code>这种，保证两个数相加不会爆int上限即可。由于是无向图，记得反存，另外这个题目村庄是从0开始的，我一般喜欢设为1开始，但是这个题目别忘了要改回来。</p><p>关于查询的部分，由于题目明确保证查询时间依次增大，所以我们随着天数更新Floyd图就行，看看在询问的天数内能更新多少村庄修复，以此类推，直到最后输出结果。</p><p>最后附上ac代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 1e9</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">205</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,q,x,y,qt;</span><br><span class="line"><span class="keyword">int</span> t[maxn],arr[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            arr[i][j]=arr[j][i]=<span class="built_in">min</span>(arr[i][j],arr[i][k]+arr[k][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">int</span> i,j,w,k;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">cin</span>&gt;&gt;t[i];</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            <span class="keyword">if</span> (i!=j) arr[i][j]=inf;</span><br><span class="line">    <span class="keyword">for</span> (k=<span class="number">0</span>;k&lt;m;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;i&gt;&gt;j&gt;&gt;w;</span><br><span class="line">        arr[i][j]=arr[j][i]=w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;q;<span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;qt;</span><br><span class="line">        <span class="keyword">while</span> (t[flag]&lt;=qt &amp;&amp; flag&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            floyd(flag);</span><br><span class="line">            flag++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t[x]&gt;qt || t[y]&gt;qt) <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[x][y]==inf) <span class="built_in">cout</span>&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;arr[x][y]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;该博客所有题目均是西电ACM暑假培训洛谷团队的题目，目前共16题，之前一直在写题，本博客持续更新。&lt;/p&gt;
&lt;p&gt;感谢校队张帆大佬的讲课(ID：孤月)。&lt;/p&gt;
&lt;p&gt;由于本人太菜，本文将持续更新&lt;/p&gt;
    
    </summary>
    
    
      <category term="ACM算法" scheme="http://yoursite.com/categories/ACM%E7%AE%97%E6%B3%95/"/>
    
      <category term="洛谷试炼场" scheme="http://yoursite.com/categories/ACM%E7%AE%97%E6%B3%95/%E6%B4%9B%E8%B0%B7%E8%AF%95%E7%82%BC%E5%9C%BA/"/>
    
    
      <category term="图论与树" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA%E4%B8%8E%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【图论与树】并查集</title>
    <link href="http://yoursite.com/2020/06/23/%E3%80%90%E5%9B%BE%E8%AE%BA%E4%B8%8E%E6%A0%91%E3%80%91%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://yoursite.com/2020/06/23/%E3%80%90%E5%9B%BE%E8%AE%BA%E4%B8%8E%E6%A0%91%E3%80%91%E5%B9%B6%E6%9F%A5%E9%9B%86/</id>
    <published>2020-06-22T23:06:12.000Z</published>
    <updated>2020-06-24T08:14:46.988Z</updated>
    
    <content type="html"><![CDATA[<p>最近一段时间一直忙着刷题，没时间来写博客了。今天，我来写一个基础的问题，就是图论中常见的并查集的问题。首先明确并查集是什么？<a id="more"></a></p><p>_并查集，在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。这一类问题近几年来反复出现在信息学的国际国内赛题中，其特点是看似并不复杂，但数据量极大，若用正常的数据结构来描述的话，往往在空间上过大，计算机无法承受;即使在空间上勉强通过，运行的时间复杂度也极高，根本就不可能在比赛规定的运行时间(1~3秒)内计算出试题需要的结果，只能用并查集来描述。_(摘自百度)</p><p>并查集和路径压缩应该怎么形象地理解呢，这里我们可以做一下这样的假设。</p><p>我们现在假定一个数组f，其中<code>f[i]</code>表示第i个人的老大是谁（当然网上还有其他解释，爸爸什么的，反正先这样理解）</p><p>现在我们假设有5个人，给他们分别编号1~5，好了现在我们要进行一些操作，也就是集合合并。</p><p>假设现在让2做1的老大，于是我们令<code>f[1]=2</code>，就是这个意思。</p><p>然后再让1做3的老大，于是有<code>f[3]=1</code>，好了现在按照道理而言123三个人应该在一个集合中，但是其实3不知道2是1的老大，也就是3不知道2是他老大的老大。但是我们有办法让他知道。</p><p>定义一个<code>find</code>函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[k]==k) <span class="keyword">return</span> k;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> f[k]=<span class="built_in">find</span>(f[k]);</span><br><span class="line">    <span class="comment">// return f[k]=find(f[k]); 是简写，等价于f[k]=find[f[k]];return f[k];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们尝试运行下<code>f[3]=find(1)</code>，不难想象，此时，我们遍历了所有3的老大们(包括老大的老大)，顺便在遍历的过程中，让他们有了相同的老大，这时他们就到一个集合中去了，简直太巧妙了。</p><p>于是，我们要判断x和y在一个集合，他们只需要满足<code>find(x)==find(y)</code>的条件即可。</p><p>下面我们以两道洛谷的题目为例。</p><h4 id="P3367-【模板】并查集"><a href="#P3367-【模板】并查集" class="headerlink" title="P3367 【模板】并查集"></a>P3367 【模板】并查集</h4><p>第一道模板题：<a href="https://www.luogu.com.cn/problem/P3367" target="_blank" rel="noopener">P3367 【模板】并查集</a></p><p>这道题目就是一道练习并查集模板的题目，关于并查集的概念上面也描述了，这题目判断是否在同一个集合的核心代码就是<code>if (find(x)==find(y))</code>，所以就直接上代码吧。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10005</span></span><br><span class="line"><span class="keyword">int</span> n,m,z,x,y;</span><br><span class="line"><span class="keyword">int</span> f[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[k]==k) <span class="keyword">return</span> k;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> f[k]=<span class="built_in">find</span>(f[k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i]=i;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;z&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="keyword">if</span> (z==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            f[<span class="built_in">find</span>(x)]=<span class="built_in">find</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(x)==<span class="built_in">find</span>(y))</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">'Y'</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">'N'</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于初始化的问题，我们首先假设所有的老大都是自己，即<code>f[i]=i</code>。之后再进行集合的合并等操作，就是道练习模板的题目。</p><h4 id="P1525-关押罪犯"><a href="#P1525-关押罪犯" class="headerlink" title="P1525 关押罪犯"></a>P1525 关押罪犯</h4><p>第二道并查集题目：<a href="https://www.luogu.com.cn/problem/P1525" target="_blank" rel="noopener">P1525 关押罪犯</a></p><p>这道题目也是一道淳朴的并查集的题目，不同的是，加入对思维的考验，也就是说，我怎样分配才能使冲突事件的等级最小。</p><p><strong>思考</strong>：我们绝不能让冲突矛盾最大的两个人在一个监狱，好那就先把他们拿出来，放到两个不同的监狱去。然后矛盾次大的两人也不能在一个监狱，放到两个不同监狱去。这就出现了一个问题，假设现在有四名罪犯_abcd_，其中ab的冲突最大，cd的冲突次大，很显然ab和cd不能在同一个监狱，那我们的组合是ac和bd还是ad和bc呢？</p><p>这时需要我们引入一个另外的概念，就是敌人的敌人就是朋友，其实也不一定是朋友，但是冲突会更小一点。讲具体点就是，我们现在用数组<code>re</code>来存放所有人冲突最大的敌人，比如<code>re[i]</code>表示第i个罪犯冲突最大的敌人，按照上面abcd的例子，即<code>re[a]=b,re[b]=a,re[c]=d,re[d]=c</code>，说到这里如果你还没理解我的做法，那我就引入更多的罪犯，假设他们与abcd都有或大或小的冲突，接下来来了个e，他与a有冲突，且冲突值仅次于cd的冲突值，这时e肯定不能和a一个监狱了，所以我们让b和e一个监狱，这就是上面所说的，<strong>敌人的敌人就是“朋友”</strong>。按照冲突值由大到小的顺序，那直到什么时候为止呢？</p><p><code>if (find(x)==find(y))</code>,直到发现冲突值为某个数的两名罪犯x和y他们已经在一个集合中了，他们的冲突已经不能避免了，后面的罪犯已经不用再考虑了，因为后面的罪犯不管怎么排，冲突值都不会大过x和y的冲突值了，题目只要求最大值。</p><p>总结一下这其实是个贪心的思想，但是比贪心容易得多，我们把冲突值从大到小排序，让冲突值最大的两名罪犯分开，并互相标记为敌人，以此类推，后面如果有罪犯e发现它的敌人a已经有敌人b了，那就让e和b在一个监狱，不管b和e有没有冲突，直到发现有冲突的两名罪犯已经在一个监狱的时候，直接输出他们的冲突值即可。</p><p>如果找到最后两名罪犯都发现他们不在一个监狱，那就说明可以完全避免冲突，输出<code>0</code>。</p><p>以下是代码，个人认为我的代码还是非常易于理解，且对新手友善的（大家轻喷</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">2e4</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxm=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> f[maxn],re[maxn],n,m; <span class="comment">// 数组f存放并查集，数组re表示敌人</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">&#125;v[maxm];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node x,node y)</span> <span class="comment">// 定义结构体的sort排序，根据c进行降序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.c&gt;y.c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> k)</span> <span class="comment">// 并查集，找老大的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f[k]==k) <span class="keyword">return</span> k;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> f[k]=<span class="built_in">find</span>(f[k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> <span class="comment">// 对两数进行合并操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[<span class="built_in">find</span>(x)]=<span class="built_in">find</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> <span class="comment">// 判断两数是否在同一个集合中</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(x)==<span class="built_in">find</span>(y); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">cin</span>&gt;&gt;v[i].a&gt;&gt;v[i].b&gt;&gt;v[i].c;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++) f[i]=i;</span><br><span class="line">    sort(v+<span class="number">1</span>,v+m,cmp); <span class="comment">// 按照c即冲突值从大到小排序</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (check(v[i].a,v[i].b)) <span class="comment">// 如果发现a和b已经在一个监狱了，说明冲突无法避免，直接输出c</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;v[i].c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            getchar();getchar();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 后面的罪犯不用考虑，只求最大的冲突</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (re[v[i].a]) merge(re[v[i].a],v[i].b);<span class="comment">//发现a已经有敌人了，所以我们合并敌人的敌人</span></span><br><span class="line">            <span class="keyword">else</span> re[v[i].a]=v[i].b; <span class="comment">// 标记a和敌人是b</span></span><br><span class="line">            <span class="keyword">if</span> (re[v[i].b]) merge(re[v[i].b],v[i].a);</span><br><span class="line">            <span class="keyword">else</span> re[v[i].b]=v[i].a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一段时间一直忙着刷题，没时间来写博客了。今天，我来写一个基础的问题，就是图论中常见的并查集的问题。首先明确并查集是什么？
    
    </summary>
    
    
      <category term="ACM算法" scheme="http://yoursite.com/categories/ACM%E7%AE%97%E6%B3%95/"/>
    
      <category term="西电培训笔记" scheme="http://yoursite.com/categories/ACM%E7%AE%97%E6%B3%95/%E8%A5%BF%E7%94%B5%E5%9F%B9%E8%AE%AD%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>第0次训练洛谷试炼场题解</title>
    <link href="http://yoursite.com/2020/06/16/%E7%AC%AC0%E6%AC%A1%E8%AE%AD%E7%BB%83%E6%B4%9B%E8%B0%B7%E8%AF%95%E7%82%BC%E5%9C%BA%E9%A2%98%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/06/16/%E7%AC%AC0%E6%AC%A1%E8%AE%AD%E7%BB%83%E6%B4%9B%E8%B0%B7%E8%AF%95%E7%82%BC%E5%9C%BA%E9%A2%98%E8%A7%A3/</id>
    <published>2020-06-16T15:58:06.000Z</published>
    <updated>2020-06-16T08:23:13.391Z</updated>
    
    <content type="html"><![CDATA[<p>第0次训练作业为自由训练，题目都比较简单，大概30min能搞定。布置了四道题目，这里总结归纳，写了一下题解。</p><blockquote><p>P1449 后缀表达式 </p><p>P3613【深基15.例2】寄包柜 </p><p>P1177【模板】快速排序 </p><p>P3370 【模板】字符串哈希 </p></blockquote><a id="more"></a><h4 id="P1449-后缀表达式"><a href="#P1449-后缀表达式" class="headerlink" title="P1449 后缀表达式"></a>P1449 后缀表达式</h4><p>题目地址：<a href="https://www.luogu.com.cn/problem/P1449" target="_blank" rel="noopener">P1449 后缀表达式</a></p><p>这个题目刚开始纠结于负数和减法的关系，不过后来经过提醒和验证，发现根本不用考虑这个影响。那这个题目就非常简单了，比严奶奶书上的例题更加容易。</p><p>申请一个栈，判断下每次进来的什么东西，然后依次弄出来计算即可。</p><p>直接上代码，没什么好说的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> num;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;num;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num[i]!=<span class="string">'@'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (num[i]!=<span class="string">'+'</span> &amp;&amp; num[i]!=<span class="string">'-'</span> &amp;&amp; num[i]!=<span class="string">'*'</span> &amp;&amp; num[i]!=<span class="string">'/'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (num[i]!=<span class="string">'.'</span>) a=a*<span class="number">10</span>+num[i]-<span class="string">'0'</span>,i++;</span><br><span class="line">            stk.push(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> b;</span><br><span class="line">            b=stk.top();</span><br><span class="line">            stk.pop();</span><br><span class="line">            <span class="keyword">switch</span> (num[i])</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                b=stk.top()+b;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                b=stk.top()-b;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                b=stk.top()*b;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                b=stk.top()/b;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.pop();</span><br><span class="line">            stk.push(b);</span><br><span class="line">        &#125;      </span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;stk.top()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P3613【深基15-例2】寄包柜"><a href="#P3613【深基15-例2】寄包柜" class="headerlink" title="P3613【深基15.例2】寄包柜"></a>P3613【深基15.例2】寄包柜</h4><p>题目地址：<a href="https://www.luogu.com.cn/problem/P3613" target="_blank" rel="noopener">P3613【深基15.例2】寄包柜</a></p><p>这个题目就是考查vector不定长数组的使用方法，因为直接开二维数组内存会炸，然而也没必要开那么多。不定长数组会简单的多。也没什么思路可言，就是直接上代码就行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">guizi</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> s=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; num,w;</span><br><span class="line">&#125;g[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,q;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x,i,j,k,l;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span> (x==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;i&gt;&gt;j&gt;&gt;k;</span><br><span class="line">            g[i].s++;</span><br><span class="line">            g[i].num.push_back(j);</span><br><span class="line">            g[i].w.push_back(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;i&gt;&gt;j; </span><br><span class="line">            <span class="keyword">for</span> (l=g[i].s<span class="number">-1</span>;l&gt;=<span class="number">0</span>;l--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (g[i].num[l]==j)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;g[i].w[l]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P1177【模板】快速排序"><a href="#P1177【模板】快速排序" class="headerlink" title="P1177【模板】快速排序"></a>P1177【模板】快速排序</h4><p>题目地址：<a href="https://www.luogu.com.cn/problem/P1177" target="_blank" rel="noopener">P1177【模板】快速排序 </a></p><p>这个题目校队是想让我们简单熟悉一下sort的使用，虽然题目不让我们用，但我们用了也是一遍过。当然在以后的机试中，肯定直接sort(手动狗头)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100005</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,a[maxn],i;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    sort(a,a+n);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++) <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="P3370-【模板】字符串哈希"><a href="#P3370-【模板】字符串哈希" class="headerlink" title="P3370 【模板】字符串哈希"></a>P3370 【模板】字符串哈希</h4><p>题目地址：<a href="https://www.luogu.com.cn/problem/P3370" target="_blank" rel="noopener">P3370 【模板】字符串哈希</a></p><p>这个题目依旧标明不希望我们用map函数，但是校队只是希望我们用map直接水过去，好吧，那先用map来做一遍。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">bool</span>&gt;ha;</span><br><span class="line">    <span class="keyword">int</span> n,i,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        ha[s]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">bool</span>&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span> (iter=ha.<span class="built_in">begin</span>();iter!=ha.<span class="built_in">end</span>();iter++) ans++;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到哈希我比较感兴趣(应该是和密码学相关的？)，所以我又用了字符串哈希做了一遍。如果你明白哈希的话，其实很简单。我这里是用单哈希做的，题解里面有更好的哈希方法，但貌似没人证明。</p><p>此题单哈希来做可以直接过，主要思想设置base和mod，然而我没有设置mod也过了。</p><script type="math/tex; mode=display">ans = (ans *base +value) \% mod;</script><p>主要就是这样的思想，value是每位上的数，这里我base取的是233。这样每个字符串都有自己对应的哈希值了。</p><p>然后上代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> base 233</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 10005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,i,j,ans=<span class="number">1</span>;</span><br><span class="line">    ll ha[maxn];</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">        <span class="keyword">int</span> l=s.<span class="built_in">size</span>();</span><br><span class="line">        ll sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;l;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum=sum*base+s[j];</span><br><span class="line">        &#125;</span><br><span class="line">        ha[i]=sum;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(ha,ha+n);</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">        <span class="keyword">if</span> (ha[i]!=ha[i+<span class="number">1</span>]) ans++;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第0次训练作业为自由训练，题目都比较简单，大概30min能搞定。布置了四道题目，这里总结归纳，写了一下题解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;P1449 后缀表达式 &lt;/p&gt;
&lt;p&gt;P3613【深基15.例2】寄包柜 &lt;/p&gt;
&lt;p&gt;P1177【模板】快速排序 &lt;/p&gt;
&lt;p&gt;P3370 【模板】字符串哈希 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="ACM算法" scheme="http://yoursite.com/categories/ACM%E7%AE%97%E6%B3%95/"/>
    
      <category term="洛谷试炼场" scheme="http://yoursite.com/categories/ACM%E7%AE%97%E6%B3%95/%E6%B4%9B%E8%B0%B7%E8%AF%95%E7%82%BC%E5%9C%BA/"/>
    
    
      <category term="洛谷" scheme="http://yoursite.com/tags/%E6%B4%9B%E8%B0%B7/"/>
    
  </entry>
  
  <entry>
    <title>常用STL库总结</title>
    <link href="http://yoursite.com/2020/06/16/%E5%B8%B8%E7%94%A8STL%E5%BA%93%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/06/16/%E5%B8%B8%E7%94%A8STL%E5%BA%93%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-16T14:41:03.000Z</published>
    <updated>2020-06-16T07:52:50.437Z</updated>
    
    <content type="html"><![CDATA[<p>该博客内容是针对西安电子科技大学2020年ACM暑假培训，6月15日校队周益全大佬讲课内容的总结与整理。</p><h3 id="一、STL库的概念"><a href="#一、STL库的概念" class="headerlink" title="一、STL库的概念"></a>一、STL库的概念</h3><p>STL（Standard Template Library），即标准模板库，是一个具有工业强度的，高效的C++程序库。它被容纳于C++标准程序库（C++ Standard Library）中，是ANSI/ISO C++标准中最新的也是极具革命性的一部分。该库包含了诸多在计算机科学领域里所常用的基本数据结构和基本算法。为广大C++程序员们提供了一个可扩展的应用框架，高度体现了软件的可复用性。<a id="more"></a></p><h3 id="二、vector向量-不定长数组"><a href="#二、vector向量-不定长数组" class="headerlink" title="二、vector向量(不定长数组)"></a>二、vector向量(不定长数组)</h3><h4 id="1-头文件"><a href="#1-头文件" class="headerlink" title="1. 头文件"></a>1. 头文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt; // 头文件</span></span></span><br></pre></td></tr></table></figure><h4 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vec; <span class="comment">// 申请一个vector容器，这里int也可以是其他数据类型</span></span><br><span class="line">vec.push_back(num); <span class="comment">// 向容器最后插入一个数num</span></span><br><span class="line">vec.<span class="built_in">size</span>(); <span class="comment">// 查询目前容器的大小，常用于遍历</span></span><br></pre></td></tr></table></figure><h4 id="3-二维数组"><a href="#3-二维数组" class="headerlink" title="3. 二维数组"></a>3. 二维数组</h4><p>我们还可以一次性申请多个vector，这样就可以起到二维数组的作用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vec[<span class="number">100</span>]; <span class="comment">// 申请100个不定长容器</span></span><br></pre></td></tr></table></figure><h3 id="三、map关联式容器"><a href="#三、map关联式容器" class="headerlink" title="三、map关联式容器"></a>三、map关联式容器</h3><p>以前内容还有部分整理自其他博客 <a href="https://www.cnblogs.com/fnlingnzb-learner/p/5833051.html" target="_blank" rel="noopener">C++中的STL中map用法详解</a></p><h4 id="1-头文件-1"><a href="#1-头文件-1" class="headerlink" title="1. 头文件"></a>1. 头文件</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt; // 头文件</span></span></span><br></pre></td></tr></table></figure><h4 id="2-常用命令-1"><a href="#2-常用命令-1" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h4><p>这里举一个作业题目的例子，洛谷Hash模板题 <a href="https://www.luogu.com.cn/problem/P3370" target="_blank" rel="noopener">P3370 【模板】字符串哈希</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">bool</span>&gt;mp; <span class="comment">// 申请一个map，这个意思是申请一个名叫mp的map它可以将一个string类型的映射成bool类型。当然名字和类型都是可以换的</span></span><br><span class="line">mp[<span class="string">"abc"</span>] = <span class="number">1</span>; <span class="comment">// 之后输出mp["abc"]就会是1要是没有上一步输出就会是0</span></span><br><span class="line">mp.<span class="built_in">size</span>(); <span class="comment">// 容器的大小</span></span><br></pre></td></tr></table></figure><p>根据周大佬上课所说的，map的库轮子是用红黑树写的，所以效率会很高。</p><h4 id="3-容器遍历"><a href="#3-容器遍历" class="headerlink" title="3. 容器遍历"></a>3. 容器遍历</h4><p>这里上课没有提到，在这里补充一下关于map容器遍历问题，博客上有两种遍历方式，我这里说的是应用前向迭代器的方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;::iterator iter;</span><br><span class="line"><span class="keyword">for</span>(iter = mp.<span class="built_in">begin</span>();iter != mp.<span class="built_in">end</span>();iter++)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;iter-&gt;first&lt;&lt;<span class="string">' '</span>&lt;&lt;iter-&gt;second&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h4 id="4-pair的用法"><a href="#4-pair的用法" class="headerlink" title="4. pair的用法"></a>4. pair的用法</h4><p>将两个数放在一起，类似数据结构。比如直角坐标系(x,y)对应一个数value。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt;mapxy; <span class="comment">// 申请容器</span></span><br><span class="line">mapxy[make_pair(x,y)] = value; <span class="comment">// 赋值</span></span><br></pre></td></tr></table></figure><h3 id="四、set集合"><a href="#四、set集合" class="headerlink" title="四、set集合"></a>四、set集合</h3><p>这个比较容易，就简单写写了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt; // 头文件</span></span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;st; <span class="comment">// 申请一个集合st</span></span><br><span class="line">st.<span class="built_in">begin</span>(); <span class="comment">// 返回set容器的第一个元素</span></span><br><span class="line">st.<span class="built_in">end</span>(); <span class="comment">// 返回set容器的最后一个元素</span></span><br><span class="line">st.<span class="built_in">clear</span>(); <span class="comment">// 删除set容器中的所有的元素</span></span><br><span class="line">st.empty(); <span class="comment">// 判断set容器是否为空</span></span><br><span class="line">st.max_size(); <span class="comment">// 返回set容器可能包含的元素最大个数</span></span><br><span class="line">st.<span class="built_in">size</span>(); <span class="comment">// 返回当前set容器中的元素个数</span></span><br><span class="line">st.insert(); <span class="comment">// 在集合中插入元素</span></span><br><span class="line">st.erase(); <span class="comment">// 删除集合中的某个元素</span></span><br></pre></td></tr></table></figure><h3 id="五、algorithm算法库"><a href="#五、algorithm算法库" class="headerlink" title="五、algorithm算法库"></a>五、algorithm算法库</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; // 头文件</span></span></span><br></pre></td></tr></table></figure><h4 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1. 二分查找"></a>1. 二分查找</h4><ul><li>lower_bound(起始地址，结束地址，要查找的数值)</li></ul><p>返回大于或等于val的第一个元素位置。如果所有元素都小于val，则返回last的位置。</p><p>注意：如果所有元素都小于val，则返回last的位置，且last的位置是越界的。</p><ul><li>upper_bound(起始地址，结束地址，要查找的数值)</li></ul><p>功能：函数upper_bound()返回的在前闭后开区间查找的关键字的上界，返回大于val的第一个元素位置。</p><p><strong>记得最后减去地址</strong></p><h4 id="2-sort排序"><a href="#2-sort排序" class="headerlink" title="2. sort排序"></a>2. sort排序</h4><p>太常用了。对有n个元素的数组a进行排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(a,a+n); <span class="comment">// 升序排序，起始地址和结束地址</span></span><br></pre></td></tr></table></figure><p>如果想要降序排序，简单写一个比较函数就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i &gt; j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(a,a+n,cmp); <span class="comment">// 降序排序</span></span><br></pre></td></tr></table></figure><p>如果想对结构体的某个value进行排序也是一样的，把cmp函数改掉就行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key,value;</span><br><span class="line">&#125;a[<span class="number">100</span>];</span><br><span class="line"><span class="comment">// 想对a直接进行升序排序是不可以的，因为对象不清楚</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node i,node j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i.value &lt; j.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(a,a+n,cmp); <span class="comment">// 这样就行了</span></span><br></pre></td></tr></table></figure><p>还有另一种写法，就是对大于号重载一下，重新定义其意义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> key,value;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node&amp;x)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> value &lt; x.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;a[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">sort(a,a+n); <span class="comment">// 这样也行</span></span><br></pre></td></tr></table></figure><h3 id="六、数据结构"><a href="#六、数据结构" class="headerlink" title="六、数据结构"></a>六、数据结构</h3><h4 id="1-队列"><a href="#1-队列" class="headerlink" title="1. 队列"></a>1. 队列</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt; // 头文件</span></span></span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; q; <span class="comment">// 申请队列</span></span><br><span class="line">q.push(value); <span class="comment">// 入队</span></span><br><span class="line">q.pop(); <span class="comment">// 出队</span></span><br><span class="line">q.top(); <span class="comment">// 返回队首元素</span></span><br><span class="line">q.empty(); <span class="comment">// 判断是否为空</span></span><br><span class="line">q.<span class="built_in">size</span>(); <span class="comment">// 返回队列个数</span></span><br></pre></td></tr></table></figure><h4 id="2-栈"><a href="#2-栈" class="headerlink" title="2. 栈"></a>2. 栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt; // 头文件</span></span></span><br><span class="line"><span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; stk; <span class="comment">// 申请栈</span></span><br><span class="line">stk.push(value); <span class="comment">// 入栈</span></span><br><span class="line">stk.pop(); <span class="comment">// 出栈</span></span><br><span class="line">stk.top(); <span class="comment">// 返回栈顶元素</span></span><br><span class="line">stk.empty(); <span class="comment">// 判断是否为空栈</span></span><br></pre></td></tr></table></figure><p>其余数据结构之后还会细讲。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;该博客内容是针对西安电子科技大学2020年ACM暑假培训，6月15日校队周益全大佬讲课内容的总结与整理。&lt;/p&gt;
&lt;h3 id=&quot;一、STL库的概念&quot;&gt;&lt;a href=&quot;#一、STL库的概念&quot; class=&quot;headerlink&quot; title=&quot;一、STL库的概念&quot;&gt;&lt;/a&gt;一、STL库的概念&lt;/h3&gt;&lt;p&gt;STL（Standard Template Library），即标准模板库，是一个具有工业强度的，高效的C++程序库。它被容纳于C++标准程序库（C++ Standard Library）中，是ANSI/ISO C++标准中最新的也是极具革命性的一部分。该库包含了诸多在计算机科学领域里所常用的基本数据结构和基本算法。为广大C++程序员们提供了一个可扩展的应用框架，高度体现了软件的可复用性。
    
    </summary>
    
    
      <category term="ACM算法" scheme="http://yoursite.com/categories/ACM%E7%AE%97%E6%B3%95/"/>
    
      <category term="西电培训笔记" scheme="http://yoursite.com/categories/ACM%E7%AE%97%E6%B3%95/%E8%A5%BF%E7%94%B5%E5%9F%B9%E8%AE%AD%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ACM" scheme="http://yoursite.com/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>数模竞赛备赛常用模型与算法</title>
    <link href="http://yoursite.com/2020/06/13/%E6%95%B0%E6%A8%A1%E7%AB%9E%E8%B5%9B%E5%A4%87%E8%B5%9B%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/06/13/%E6%95%B0%E6%A8%A1%E7%AB%9E%E8%B5%9B%E5%A4%87%E8%B5%9B%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%AE%97%E6%B3%95/</id>
    <published>2020-06-12T16:46:23.000Z</published>
    <updated>2020-06-16T07:52:40.673Z</updated>
    
    <content type="html"><![CDATA[<p>所有的模型与算法是不可能学完的，大家根据自己的实际情况来学习，不必过于焦虑。<a id="more"></a></p><h4 id="1-数学模型的分类"><a href="#1-数学模型的分类" class="headerlink" title="1. 数学模型的分类"></a>1. 数学模型的分类</h4><ul><li><p><strong>按数学方法分类：</strong> 几何模型、图论模型、微分方程模型、概率模型、最优控制模型、规划论模型、马氏链模型等。</p></li><li><p><strong>按特征分类：</strong> 静态模型和动态模型，确定性模型和随机模型，<strong>离散模型和连续性模型</strong>，线性模型和非线性模型等。</p></li><li><p><strong>按应用领域分类：</strong> 人口模型、交通模型、经济模型、生态模型、资源模型、环境模型等。</p></li><li><p><strong>按建模目的分类：</strong> 预测模型、优化模型、决策模型、控制模型等。</p></li><li><p><strong>按比赛命题方向分类：</strong> 国赛一般是离散模型和连续模型各一个，2019增加了一个人文社科背景题目，</p><p>美赛六个题目（离散、连续、大数据、运筹学/复杂网络、环境科学、政策）。</p></li></ul><h4 id="2-备赛：常用的模型与算法"><a href="#2-备赛：常用的模型与算法" class="headerlink" title="2. 备赛：常用的模型与算法"></a>2. 备赛：常用的模型与算法</h4><ul><li><strong>评价模型：</strong> 层次分析、Topsis(优劣解距离法)、数据包络分析(DEA)、模糊综合评价、秩和比综合评价、主成分分析、灰色关联分析法</li><li><strong>预测分析模型：</strong> 微分方程模型、差分方程模型、回归分析、时间序列、马尔可夫、神经网络、插值拟合、混沌序列预测、小波分析预测、灰色预测模型</li><li><strong>优化模型：</strong> 数学规划模型（多目标、单目标、0-1整数规划等）、复杂网络优化、排队论与计算机仿真、图论、博弈论</li><li><strong>数理统计模型：</strong> 多元分析（主成分分析、聚类分析、因子分析、判别分析、典型相关性分析等）、相关回归分析、假设检验、方差检验、贝叶斯统计</li><li><strong>分类与判别算法：</strong> 距离聚类(系统聚类)、关联性聚类，层次聚类、贝叶斯分类与判别、SVM支持向量机、决策树、极限学习机</li><li><strong>重要的算法：</strong> 蒙特卡罗算法、数据处理算法(数据拟合、参数估计、插值等)、规划算法(线性规划、整数规划、多元规划、二次规划等)、图论算法、计算机经典算法(动态规划、回溯搜索、分治算法、分支定界等)、最优化理论的三大非经典算法(模拟退火法、神经网络、遗传算法)、网格算法和穷举法、元胞自动机</li></ul><h4 id="3-备赛：针对性训练"><a href="#3-备赛：针对性训练" class="headerlink" title="3. 备赛：针对性训练"></a>3. 备赛：针对性训练</h4><ul><li>无论是国赛还是美赛，比赛前要确定大概的选题范围。比如这次美赛，我们赛前训练了2道D题，1道A题，1道C题，当然我们学校最擅长的也是D题。所以这次美赛前我们便确定了选题。</li><li>选定题目后，阅读往年优秀论文，可以是这个题目的也可以不是。请尽可能多地阅读，并且总结分析以及比较，人家能得大奖一定有他的原因，每阅读一篇优秀论文就把人家优秀的地方学过来，不断总结积累。</li><li>经过多次真题训练，比赛前整理一套属于自己队伍的Latex或者Word模板，比赛时候方便使用。</li><li>熟练使用各种查找文献，下载文献的办法，知网、谷歌学术等等。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;所有的模型与算法是不可能学完的，大家根据自己的实际情况来学习，不必过于焦虑。
    
    </summary>
    
    
      <category term="数学建模" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="入门指导" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%85%A5%E9%97%A8%E6%8C%87%E5%AF%BC/"/>
    
    
      <category term="模型算法" scheme="http://yoursite.com/tags/%E6%A8%A1%E5%9E%8B%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>西电数模竞赛面试培训参赛经验汇总</title>
    <link href="http://yoursite.com/2020/06/11/%E8%A5%BF%E7%94%B5%E6%95%B0%E6%A8%A1%E7%AB%9E%E8%B5%9B%E9%9D%A2%E8%AF%95%E5%9F%B9%E8%AE%AD%E5%8F%82%E8%B5%9B%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/"/>
    <id>http://yoursite.com/2020/06/11/%E8%A5%BF%E7%94%B5%E6%95%B0%E6%A8%A1%E7%AB%9E%E8%B5%9B%E9%9D%A2%E8%AF%95%E5%9F%B9%E8%AE%AD%E5%8F%82%E8%B5%9B%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/</id>
    <published>2020-06-10T21:09:10.000Z</published>
    <updated>2020-06-10T14:38:01.736Z</updated>
    
    <content type="html"><![CDATA[<p>今天西电数学建模竞赛总教练刚在群里通知，数学建模国赛报名及选拔工作即将开始。</p><p>我想趁这个机会来分享下数模竞赛的从面试到培训，再到选导师，以及最后参赛的整个流程的经验。</p><p>在这个过程中，如果有哪儿些地方没说清楚或者你有自己的见解，也欢迎各位西电er私信我来对这个文章予以补充，用来给更多的学弟学妹或者第一次参与整个数模竞赛的流程的同学一些可供参考的建议。</p><p>学弟学妹们关于培训有什么问题或者担忧的地方，也欢迎私信我~</p><a id="more"></a><h4 id="一、国赛校队选拔"><a href="#一、国赛校队选拔" class="headerlink" title="一、国赛校队选拔"></a>一、国赛校队选拔</h4><p>首先，大家在五一期间刚刚参加完了校赛，校赛的主要参加队员是大一和大二的同学，大三同学很少参加的原因是，国赛在9月份的中秋节举办，成绩要到11月份才能出来，而那时候的大三也就是大四的学长学姐们早就要么完成了保研要么就是考研的最后冲刺阶段，所以校赛的主力基本是大一和大二的同学们，这些同学参与9月国赛的时候就是大二和大三了。而7月到8月的国赛培训一般是按照校赛的成绩来选拔的，选拔的标准一般而言是校一等奖加上排名靠前的校二等奖(对于大一的要求会相对宽松一点)，这些同学会被选拔出来作为校赛的培训队员。</p><p>当然不是说，没有过面试的同学就没有参加国赛的机会了，每年暑假的国赛培训都可以让同学们旁听的。不得不说，总教练心还是很软的，一般国赛培训好好参加，作业认真完成，韩老师都会同意进入校队参加比赛的。去年的校队后来旁听队伍加了十几支的队伍，再加上学校越来越重视数模竞赛(这次美赛就可以看出)，数模校队名额会越来越多，鼓励同学们不要放弃，跟着校队培训来，还是有很大的参赛的可能的。</p><h4 id="二、面试建议"><a href="#二、面试建议" class="headerlink" title="二、面试建议"></a>二、面试建议</h4><p>其次就是关于面试的事情，大家不必有太多的心理负担，一般而言大一和大二是分开面试的，主要就是问问校赛的论文以及对着简历问一些简单的问题，简历上面写一些自己擅长的技能，获得的奖项，以及自己专业课的均分及排名(数学类课程尤为重要)。大家简历的模板可以用word自带的模板，这里我给大家一个百度网盘的链接，是我们去年用的简历模板，整体界面还不错，可以直接编辑。</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1tDR3feJzKCKWl8mDiecUjw" target="_blank" rel="noopener">https://pan.baidu.com/s/1tDR3feJzKCKWl8mDiecUjw</a><br>提取码：7sa1</p></blockquote><p>面试的一般都是学校的数模教练，老师一定不会为难大家，所以调整好心态认真回答即可。</p><h4 id="三、国赛系统课程培训-暑假一轮培训"><a href="#三、国赛系统课程培训-暑假一轮培训" class="headerlink" title="三、国赛系统课程培训(暑假一轮培训)"></a>三、国赛系统课程培训(暑假一轮培训)</h4><p>下面我来说说国赛培训的事情吧，以下是去年国赛一轮培训的课程时间安排计划表。</p><p><img src="https://i.loli.net/2020/06/10/EmlYkzjo2Ar7SU9.jpg" alt=""></p><p>每年的主讲老师和内容都会有一些小小的变化，主讲老师也不全是学校数模的教练。不过国赛培训大家好好听课就行了，不用考虑太多的事情，培训主要针对的是对大家水平进行更系统地提升训练。可能大家会听得一头雾水(当年大一的我反正不是很能跟上)，不过不用担心，大家下了课好好去消化尽力弄懂，即使弄不清内在原理，但是也要会灵活熟练使用的。大部分课程讲完后或者讲的过程中，都会布置作业，请参加培训的各位千万把作业记清楚，因为作业是要求之后统一上交的，会根据培训作业完成情况对校队成员进行调整，另外请不要无故缺勤培训，三个人必须到场，否则后果自己承担喽~</p><h4 id="四、国赛真题训练培训-二轮培训"><a href="#四、国赛真题训练培训-二轮培训" class="headerlink" title="四、国赛真题训练培训(二轮培训)"></a>四、国赛真题训练培训(二轮培训)</h4><p>往年上完国赛的培训课程就会放暑假了(今年例外，太特殊了)，然后会要求同学们暑假提前返校(西电数模er不存在假期，我唯一完整的假期是大一寒假)，进行真题训练，一轮培训以授课为主，二轮培训主要是队伍的真题训练，一般而言都是中秋国赛开始前，会进行四次真题模拟训练，以及不少于两次的答辩。四次真题的第一道题一般是全校队统一的，由总教练韩老师来出题，大家根据这次题目的完成情况以及暑假一轮培训作业的情况去面试导师，这个之后再详细说，二轮培训之后就是做真题了，从校赛跃迁到国赛的跨度还是很大很大的，国赛的题目会非常非常的难，不过请不要去惧怕这些东西，好好弄还是能弄出结果的，之后再进行答辩以及总结分析，再多看看优秀论文，二轮培训后的水平会有非常大幅度的提升，前提当然是你们队伍认真参加完成。</p><h4 id="五、面试导师"><a href="#五、面试导师" class="headerlink" title="五、面试导师"></a>五、面试导师</h4><p>这应该是大家最关心的一个环节了吧，去年的我天天追着学长问他们什么时候选择老师的，正如上面所说，数模校队的队伍是要求暑假提前返校的，返校后第一件事就是完成全校队统一的数模练习题，时间大概是4天，之后数模群会发今年国赛指导老师的名单以及联系的邮箱，大家把自己队伍的简历，一轮培训的作业以及二轮培训第一次完成的答卷发到老师邮箱等待回复即可，去年的二轮国赛指导老师有13个，一般而言投一个就差不多够了，一般老师们的回复都比较快，如果老师明确拒绝了你们，那你们再换个老师投简历，不必广撒网。</p><p>这里我分别简单介绍下我的国赛以及美赛培训的指导老师，也欢迎各位西电数模er私信我来补充其他老师的。</p><ul><li>穆学文老师：我们国赛培训的老师，是我们当时校队面试的老师，所以投了他的简历，当时找他的有7支队伍，我们是唯一一只大一的队伍(压力山大)，老师要求我们在某一天晚上和他见个面了解下情况(不是每个老师都有这个面试的，我队友找的老师就没有)，同意让我们跟着他参加二轮培训指导。老师答辩指导认真负责，培训的时候帮忙改论文也非常非常细致，总之非常值得大家的选择。</li><li>张胜利老师：学校数模竞赛的大牛老师，指导2015国赛本科组MATLAB创新奖(全国每题一个，那篇文章至今作为数模国赛经典范文)以及2020美赛INFORMS冠名O奖(全球每题一个，也就是我们队伍，手动狗头)。数模指导水平不用多说，反正美赛培训那几天我们队伍水平突飞猛进，修改论文也非常细致，找张老师修改论文才知道什么是大佬啊，我们队伍诸多写作毛病都是张老师指出来的。但是这个老师的竞争可能比较激烈，主力还是大三的同学居多，当时国赛我们也没跟上张老师。</li></ul><p>等选择老师的最终结果确定之后，就开始以各个老师组进行二轮培训的真题训练以及答辩了。一般会再布置2~4道真题，至于具体的题目是根据各个老师来决定的(还有舍友的老师是自主命题的，非常生猛，大部分还是国赛真题)，大家在规定的四天完成后发给自己的指导老师，然后由老师来组织统一的答辩，答辩就是把指导的所有队伍聚在一起，轮流上台展示本题的答卷结果(最好能做ppt)，然后指导老师对你们这次作业进行评价，最后指导老师会指出各个队伍的优缺点，别的队伍的优点大家都可以学习学习。答辩还有个重要的目的就是选拔正式队伍(之后解释)，请大家务必重视。完成真题训练后，基本就是要参赛了。</p><h4 id="六、校赛名单终确定"><a href="#六、校赛名单终确定" class="headerlink" title="六、校赛名单终确定"></a>六、校赛名单终确定</h4><p>在暑假前的面试所完成的，是一轮国赛培训的名单，并非最终校队名单。等经过两轮国赛培训，去掉一些培训缺勤以及一轮二轮培训作业不完成的队伍，加上态度良好认真完成一轮二轮培训作业的旁听队伍，最终组成校队名单。这些队伍就是能够参加中秋国赛的所有队伍。</p><p>现在我来解释下正式队伍和挂名队伍，每个指导老师会让7支队伍左右参加自己的国赛二轮培训，但经过答辩以及二轮作业完成情况，会选择4支正式队伍，以及3支挂名队伍，挂名队伍由再分配新的指导老师，其实差别也不太大，大家真的不必纠结是不是正式队伍。</p><h4 id="七、留一点小结尾"><a href="#七、留一点小结尾" class="headerlink" title="七、留一点小结尾"></a>七、留一点小结尾</h4><p>以上便是我写的全部参赛培训的经验了，下学期还会更新美赛的培训经验，总之今年是特殊的一年，大家国赛加油~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天西电数学建模竞赛总教练刚在群里通知，数学建模国赛报名及选拔工作即将开始。&lt;/p&gt;
&lt;p&gt;我想趁这个机会来分享下数模竞赛的从面试到培训，再到选导师，以及最后参赛的整个流程的经验。&lt;/p&gt;
&lt;p&gt;在这个过程中，如果有哪儿些地方没说清楚或者你有自己的见解，也欢迎各位西电er私信我来对这个文章予以补充，用来给更多的学弟学妹或者第一次参与整个数模竞赛的流程的同学一些可供参考的建议。&lt;/p&gt;
&lt;p&gt;学弟学妹们关于培训有什么问题或者担忧的地方，也欢迎私信我~&lt;/p&gt;
    
    </summary>
    
    
      <category term="数学建模" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="入门指导" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%85%A5%E9%97%A8%E6%8C%87%E5%AF%BC/"/>
    
    
      <category term="西电" scheme="http://yoursite.com/tags/%E8%A5%BF%E7%94%B5/"/>
    
  </entry>
  
  <entry>
    <title>科研论文常用LaTex代码</title>
    <link href="http://yoursite.com/2020/06/07/%E7%A7%91%E7%A0%94%E8%AE%BA%E6%96%87%E5%B8%B8%E7%94%A8LaTex%E4%BB%A3%E7%A0%81/"/>
    <id>http://yoursite.com/2020/06/07/%E7%A7%91%E7%A0%94%E8%AE%BA%E6%96%87%E5%B8%B8%E7%94%A8LaTex%E4%BB%A3%E7%A0%81/</id>
    <published>2020-06-06T21:56:50.000Z</published>
    <updated>2020-06-10T14:38:17.705Z</updated>
    
    <content type="html"><![CDATA[<p>【转载队友的论文博客】</p><p>正是由于数学建模美赛，我们队伍的同学才开始去学习<strong>Latex</strong>这样一个论文工具的</p><p>用完之后，真香！Word从此是路人</p><a id="more"></a><p>也许大部分本科生还不太了解<strong>Latex</strong>究竟是什么？简而言之就是，论文写作排版的工具</p><p>据我观察，大部分的本科学长还是用Word来完成毕业设计的。</p><p>于是我们有个西电的保研群里面就开始天天问“字体用什么”“标题间距”“怎么调画图”等等之类的问题</p><p>而如果你学会了<strong>Latex</strong>这样一个工具，你就只管写就可以了，只要有毕设的固定模板，你只需要写你的文字就可以了，排版之类的全部自动生成，完全不用你担心。</p><p><strong>Latex</strong>的好处我就不在此一一列举了，反正等大家上了研究生，发paper还是需要会用到的（大部分出版社和学校毕设都会直接给模板，直接使用即可，不需要学会如何自己编写模板宏包）这学期的大作业和实验报告我全是用的<strong>Latex</strong>完成的（当然模板是论文队友自己编写的宏包）</p><p>不说多了，这里是论文队友的博客，整理了一些科研论文常用LaTeX代码，对数模美赛国赛的写作都有很好的帮助，非常适合初学者（指不知道常用命令的同学）等大家学会了，善用百度Bing等就可以任意写作了。</p><p><a href="[https://levitate-qian.github.io/2020/03/08/%E6%95%B0%E6%A8%A1%E8%AE%BA%E6%96%87%E5%B8%B8%E7%94%A8LaTeX%E4%BB%A3%E7%A0%81/](https://levitate-qian.github.io/2020/03/08/数模论文常用LaTeX代码/">【持续更新】论文常用LaTeX代码</a>)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【转载队友的论文博客】&lt;/p&gt;
&lt;p&gt;正是由于数学建模美赛，我们队伍的同学才开始去学习&lt;strong&gt;Latex&lt;/strong&gt;这样一个论文工具的&lt;/p&gt;
&lt;p&gt;用完之后，真香！Word从此是路人&lt;/p&gt;
    
    </summary>
    
    
      <category term="LaTex" scheme="http://yoursite.com/categories/LaTex/"/>
    
    
      <category term="LaTex" scheme="http://yoursite.com/tags/LaTex/"/>
    
  </entry>
  
  <entry>
    <title>如何写出一篇高质量的数模竞赛答卷</title>
    <link href="http://yoursite.com/2020/06/02/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%B8%80%E7%AF%87%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E6%95%B0%E6%A8%A1%E7%AB%9E%E8%B5%9B%E7%AD%94%E5%8D%B7/"/>
    <id>http://yoursite.com/2020/06/02/%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%B8%80%E7%AF%87%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E6%95%B0%E6%A8%A1%E7%AB%9E%E8%B5%9B%E7%AD%94%E5%8D%B7/</id>
    <published>2020-06-02T15:29:33.000Z</published>
    <updated>2020-06-02T15:03:03.244Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、写在前面"><a href="#一、写在前面" class="headerlink" title="一、写在前面"></a>一、写在前面</h3><p>我相信很多人都和我一样，刚开始入门的时候，接触到的是眼花缭乱的数学知识，不管是学校数模培训也好还是网上教程也好，时间序列，博弈论，排队论这些等等。<a id="more"></a> 都让我们不止一次地想过放弃，特别是没学过线代和概率论的时候硬啃数模的书籍，那简直就是天书啊。但是后来我才知道，那些都只是让你对数学模型有个初步的概念，直到现在，你要是翻开姜启源书上的任意一页，让我给你手推某个模型的推导，我想我还是万万做不到的。</p><p>但这个影响你做出一份高质量的数模答卷吗？我想是不太影响的，虽说你模型算法都没全部了解是不行的，但是也不必被其深深地困扰，毕竟比赛的时候，多半还是要靠搜索引擎，不可能能让你直接用哪儿个模型来做的。真正对于写作能力能有巨大的提升的永远只有两件事，<strong>做题和看优秀论文</strong>。做题可以是参加比赛或参与学校培训，然而其实培训参赛就是你去看优秀论文的时候，优秀论文之所以被称为优秀论文一定有它的原因，而我们需要做的就是不断地阅读，总结以及比较。</p><h3 id="二、阅读优秀论文的重要性"><a href="#二、阅读优秀论文的重要性" class="headerlink" title="二、阅读优秀论文的重要性"></a>二、阅读优秀论文的重要性</h3><p>当大家把基础的模型算法(高级的需要靠自己不断积累，但是比赛现学完全来得及)都掌握的差不多的时候，真正能让大家脱颖而出的是，写作的成熟度。我们在看论文的时候，大多可以把论文分为两类。</p><h4 id="1-优秀论文的分类"><a href="#1-优秀论文的分类" class="headerlink" title="1. 优秀论文的分类"></a>1. 优秀论文的分类</h4><ul><li><strong>A类</strong></li></ul><p>模型算法十分高级且运用正确，求解精确，分析到位，大奖。很遗憾的是，这类我们很难借鉴与总结。</p><ul><li><strong>B类</strong></li></ul><p>模型算法较为普通，但也能正确求解并自圆其说，写作功底好，分析到位，这类文章其实也能获得大奖。而就是这种文章是我们需要学习的，需要去重点总结和挖掘的。</p><h4 id="2-我们队伍的感悟"><a href="#2-我们队伍的感悟" class="headerlink" title="2. 我们队伍的感悟"></a>2. 我们队伍的感悟</h4><p>我们队伍在美赛和国赛培训的时候都会做的一件事情就是，大量阅读优秀论文，并将论文分类，将B类论文整理出来，把它们横向对比总结一遍，再和我们的对比总结一遍。虽然这次我们团队的大奖有运气成分，但我一定敢说，阅读了大量美赛优秀论文，我们做了许多总结和整理，是我们这次能得奖的重要前提。那下面我就来说说，我们团队对于数模比赛论文写作的目前可以提供给大家分享的经验。</p><h3 id="三、论文架构"><a href="#三、论文架构" class="headerlink" title="三、论文架构"></a>三、论文架构</h3><p>所有数模论文都有它的套路和最基本的格式，问题分析，模型建立，结果分析，灵敏性分析等等文章必须按照这个来。以及各个部分应该<strong>写什么，不能写什么</strong>，论文长度的限制。</p><p>当然可能你看个几篇文章就会发现一个问题，大家的结构怎么都不一样？确实有这个问题。产生这个问题的原因一般有两个方面：1. 大家整体思路框架是差不多的，只不过有些队伍进行了微调。 2. 受题目限制，例如2018年国赛B题，注定了传统论文框架无法去写(这是个很烦的问题，清晰的论文逻辑思路是论文写作最关键的一点，遇到这种情况只能自己定合理的框架)。</p><p>有时候我和学弟交流时也会发现，有些学弟的写作故意不按照套路来，想显得与众不同。关于这个想法，我想说是有极大的风险的。当然，在阅读优秀论文的过程中，确实也出现过这种情况，有些文章的结构其实我自己看都乱的快看不下去了，但是请大家注意一般这类文章能成为优秀论文可不是因为他的结构出彩，而是多半由于它的模型算法，也就是上文所提到的A类文章。对于大多数同学而言，还是老老实实按照思维的连贯性来吧，现在的比赛包括美赛在内，基本都是以四五个问题或四五个task的形式出现的，一个问题一个task对应一种模型算法，有时候可以连在一起解决，这里我给大家最常用的论文套路框架。</p><blockquote><ol><li>摘要</li><li>问题重述</li><li>问题分析(简单分析问题)</li><li>基本假设</li><li>符号说明</li><li>模型的建立、求解、分析</li><li>模型的分析、评价、推广(比如灵敏性分析，优缺点等)</li><li>参考文献</li><li>附录代码</li></ol></blockquote><p>架构可以根据题目灵活调整，主要是调整模型的建立、求解、分析这块部分。这部分通常有两种情况：(1) 一问一问分析，模型建立，算法求解，结果分析，如果嫌长也可以另起大标题。(2) 先建立好几问模型，再算法，最后一起分析。</p><p>再次强调，建议初次参加数模竞赛的同学们不要随便更改架构，容易翻车，你的内容不突出的情况下，架构给老师看<br>的还十分乱，是件糟糕的事情。</p><h3 id="四、针对模型算法"><a href="#四、针对模型算法" class="headerlink" title="四、针对模型算法"></a>四、针对模型算法</h3><h4 id="1-篇幅"><a href="#1-篇幅" class="headerlink" title="1. 篇幅"></a>1. 篇幅</h4><p>我这里先说说整篇文章的篇幅，论文页面控制在20 页左右，不超过25 页，不少于19 页为好。（从摘要到参考文献）附录和代码不算在总页数中。20-23 页极佳。模型和算法的篇幅一定是大部分的，不要主次颠倒。其实第一次我们参加校赛都没人告诉我们，我们正文部分写了50多页，没拿到校一等奖还十分不甘心，现在想想还是有些有趣的。</p><h4 id="2-模型方面"><a href="#2-模型方面" class="headerlink" title="2. 模型方面"></a>2. 模型方面</h4><p>比赛的时候一定可以查阅文献，注意不管是什么比赛，真的很少用书上的基础模型，如果你用了说明你的模型不够具有创新性。大家可以用搜索引擎根据问题去找更实用的模型，或者队伍水平高，可以自制创新想法的模型，比如我们这次美赛的模型。</p><h4 id="3-算法方面"><a href="#3-算法方面" class="headerlink" title="3. 算法方面"></a>3. 算法方面</h4><p>算法方面，尽量不要使用遗传退火这些神棍算法，用不好也不一定好用，算法的话可以自己查找其他的算法，也可以平时看看非常经典以及常用的算法。算法方面以模型求解的精确度为主，毕竟是数模建模竞赛，算法是用来解决模型求解的，当然有的时候算法也能直接充当模型构建的重要组成部分。还是那句话，数学这种东西，多学永远没坏处。</p><h4 id="4-最重要的"><a href="#4-最重要的" class="headerlink" title="4. 最重要的"></a>4. 最重要的</h4><p>这点我认为是数模比赛中最重要的一点，也是所有队伍包括大二大三都做不好的一点。就是模型和算法的表述，如果是别人的模型算法，千万不要直接搬到自己的论文里面来。我们校赛干过这破事，我们先用几页的篇幅介绍了下什么是遗传算法，估计阅卷老师看到都无语了。所以我们要做的就是，模型和算法一定要结合我们的实际问题来叙述，要求较高，但是一定要注意。</p><p>给大家举个例子，比如我们培训时国赛2018年A题练习训练，用来求解微分方程的一个算法_Crank-Nicholson_，我大概花了一个中午的时间，看懂了这个算法的意思(好像就是有限差分的变形)，然后我们写了文章。</p><p><img src="https://i.loli.net/2020/06/02/DLqbTrtaeOZW3IR.png" alt=""></p><p>如你们所见，对于微分方程模型的数值求解算法，我们就一句话，一句话。。。真的就一句话就带过去了，这现在让我看来，可以直接说这个论文表述非常非常初级。这种情况下，一定要结合你本来的题目内容把这个算法怎么求解的过程给写清楚！</p><h3 id="五、针对插图以及结果图"><a href="#五、针对插图以及结果图" class="headerlink" title="五、针对插图以及结果图"></a>五、针对插图以及结果图</h3><p>这点就不用多说了吧，参加过数模竞赛的都知道，老师没有大家想的那么细致的去审阅你的文章，我们教练说看论文一共就3min 时间(可能还是多的，要是你对队伍写的让我不忍卒读，可能都没这个时间，直接打入冷宫)，在这个情况下你如果全是打断文字叙述而没有图的话你试试？不光要有图，还要尽量做的丰富以及质量高。</p><p>结果图，可以用matlab、python 和excel 等来制作，请展开想象力，让结果图丰富以及好看起来。图表，折线图，柱状图，连续图谱都可以画一画。文字不够，图表来凑。插图，插图包括很多，热传导示意图，受力分析图，复杂算法流程图等。如果只有图片没有文字，那当然也是不行的，所以如何在25 页内控制好比例，在有限的图表个数内让图表丰富以来，这些真的需要大家多看论文积累经验了。</p><p>还是推荐下我论文队友的博客内容，关于画图的，真的强推。</p><p><a href="[https://levitate-qian.github.io/2020/05/04/10%E7%B1%BB%E6%A1%88%E4%BE%8B%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3%E8%AE%BA%E6%96%87%E6%8F%92%E5%9B%BE%E5%88%B6%E4%BD%9C/?tdsourcetag=s_pctim_aiomsg](https://levitate-qian.github.io/2020/05/04/10类案例带你了解论文插图制作/?tdsourcetag=s_pctim_aiomsg">10类案例带你了解论文插图制作</a>)</p><h3 id="六、针对结果分析"><a href="#六、针对结果分析" class="headerlink" title="六、针对结果分析"></a>六、针对结果分析</h3><p>结果分析一定一定要到位，还记得我上面说的优秀论文的分类吗？所有优秀论文都逃不出一个共性，就是分析到位。这听上去像是一句废话，不过能将这点做好的人并不多，包括在我后来参与的科研中。所以请大家记住论文的一个关键点，每当老师看到一张结果图的时候，他是看不明白的。这时候你一定要把你的分析写在结果图的上下，而且越多越详细越好。千万不要只有一张图和一行分析就了事了，此是论文大忌。给大家举一个反例，例如2018A 结果分析，当时实在太年轻，一行字解决。</p><p><img src="https://i.loli.net/2020/06/02/nB2JMkZEpaYoTgK.png" alt=""></p><p>对你们没看错，我画了一张图，然后一行字解决了分析，真就一行字。什么都没有，现在看来确实让我觉得很匪夷所思哈哈哈。</p><h3 id="七、针对其他方面"><a href="#七、针对其他方面" class="headerlink" title="七、针对其他方面"></a>七、针对其他方面</h3><h4 id="1-灵敏性分析"><a href="#1-灵敏性分析" class="headerlink" title="1. 灵敏性分析"></a>1. 灵敏性分析</h4><p>灵敏性分析一般在论文结尾，也就是模型的分析那块，最好有，这绝对是加分项，需要有图有分析。图在美赛中可以稍微做的好看一点。</p><h4 id="2-摘要"><a href="#2-摘要" class="headerlink" title="2. 摘要"></a>2. 摘要</h4><p>放在最后讲，摘要当真是重中之重。你么说老师看论文3min 能看啥？看摘要，看图，看结果分析。其他什么问题重述，背景，优缺点，推广，参考文献是不可能有人看的。摘要一定是重中之中，建议对照往年优秀论文来写摘要。优秀论文的模型算法学不来，摘要还是一定要学的。每次写摘要都是建模队友主笔，我们团队三个人一起修改一起写，并最终修订了几十遍的版本。</p><h3 id="八、写在最后"><a href="#八、写在最后" class="headerlink" title="八、写在最后"></a>八、写在最后</h3><p>以上便是我关于如何做出一篇高质量的数模答卷的一些经验了，但是你看懂了这些，也只是摸清了一些写作的方向，但也会让你少走很多很多弯路，我相信你看到这儿是有一点收获的(或者完全没有，那不好意思是我太菜了，逃)。其实有很多东西，我是无法教你们的，我给大家的建议还是多看优秀论文多做总结，前段时间我们学校校赛，我也帮过一些学弟学妹看论文，这时候我再回头看那些文章就明白了很多问题，包括我原来自己写的那些(原来培训的论文真的现在看来特别好笑)。这种论文的整体感觉以及如何科学的安排论文分布，我无法只言片语地写给你，但是当你们的优秀论文看到一定数量并做了大量总结，我相信你们会形成一定的属于你们的风格。</p><p>让我们未来一起共勉吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、写在前面&quot;&gt;&lt;a href=&quot;#一、写在前面&quot; class=&quot;headerlink&quot; title=&quot;一、写在前面&quot;&gt;&lt;/a&gt;一、写在前面&lt;/h3&gt;&lt;p&gt;我相信很多人都和我一样，刚开始入门的时候，接触到的是眼花缭乱的数学知识，不管是学校数模培训也好还是网上教程也好，时间序列，博弈论，排队论这些等等。
    
    </summary>
    
    
      <category term="数学建模" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
      <category term="入门指导" scheme="http://yoursite.com/categories/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/%E5%85%A5%E9%97%A8%E6%8C%87%E5%AF%BC/"/>
    
    
      <category term="数学建模" scheme="http://yoursite.com/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
  </entry>
  
  <entry>
    <title>图像基本操作</title>
    <link href="http://yoursite.com/2020/03/24/%E5%9B%BE%E5%83%8F%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2020/03/24/%E5%9B%BE%E5%83%8F%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</id>
    <published>2020-03-24T15:16:32.000Z</published>
    <updated>2020-05-08T15:33:40.262Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、笔记整理"><a href="#一、笔记整理" class="headerlink" title="一、笔记整理"></a>一、笔记整理</h3><p>通过b站以及github的学习完成了本教程，讲解了图像处理的底层知识，本教程所有python代码将会放在我的github仓库上面，通过首页即可访问。欢迎大家通过github来学习，当然想提高学习效率，提前了解git，ssh以及其基本命令是必须的，之后我也会推荐关于计算机视觉以及深度学习的项目。</p><a id="more"></a><h3 id="二、图像的本质"><a href="#二、图像的本质" class="headerlink" title="二、图像的本质"></a>二、图像的本质</h3><p>在学习之前我们需要思考一个问题，在计算机的眼中，图像到底是什么东西。</p><p><img src="https://i.loli.net/2020/03/24/hCJsYW86rzHkeN7.png" alt=""></p><p>我们用所有cv教程中最经典的名画来举例，计算机将图像分割了成了无数小方格，这些小方格分别有自己对应的数字矩阵，而这些数字矩阵便是计算机解读和提取图像的信息。这些数字其实便是我们常说的RGB像素，这个概念并不难理解，其实在我们眼中图片是可视化的，而在计算机眼中，所有一切可视化的图片以及视屏都是矩阵。</p><p>这也是为何传统领域的图像处理属于信号与信息处理领域，本质上任何预处理的都是数字。</p><p>明白了这个概念，下面我们可以用简单的几个命令，来将图像的数字信息给提取出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img=cv2.imread(<span class="string">'image\lena.jpg'</span>)  <span class="comment"># 读取图片的RGB参数</span></span><br><span class="line">size=img.shape <span class="comment"># 获取矩阵的维度</span></span><br></pre></td></tr></table></figure><p>通过这样的命令，我们便可以得到一个$266\times 266 \times 3$的矩阵了，说明计算机将lena的图像分成了266*266的像素小方格，每个方格有三个参数，这三个参数分别代表B，G，R(这里注意不是RGB)。</p><p><img src="https://i.loli.net/2020/03/24/zlZnW9v5yqg4VXj.png" alt=""></p><p>下面还有一个问题，如果只告诉计算机一张图片的像素参数，计算机能否将它画出来。这当然也是很轻松的。</p><p>比如我们提取了lena图片中的img参数，用一个万不变的函数便能解决。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cv_show</span><span class="params">(name,img)</span>:</span></span><br><span class="line">    cv2.imshow(name,img)  <span class="comment"># 显示图片，可以多个窗口</span></span><br><span class="line">    cv2.waitKey(<span class="number">0</span>) <span class="comment"># 窗口停止时间，毫秒级，0表示任意键结束</span></span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line">cv_show(<span class="string">'image'</span>,img)</span><br></pre></td></tr></table></figure><p>上述代码非常简单，我就不仔细说明了。下面我们来思考下，如果一张彩色的图片，我们能否提取他灰度的参数，即灰度处理，将其变成灰度图像。只需要记下下面cv2的命令即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">img=cv2.imread(<span class="string">'image\lena.jpg'</span>,cv2.IMREAD_GRAYSCALE) <span class="comment"># 灰度处理：读取灰度参数</span></span><br><span class="line">cv_show(<span class="string">'lena_gray'</span>,img)</span><br><span class="line">cv2.imwrite(<span class="string">'image\lena_gray.png'</span>,img) <span class="comment"># 保存图片</span></span><br></pre></td></tr></table></figure><p>并保存图片，我们得到了新的lena图片。</p><p><img src="https://i.loli.net/2020/03/24/JcZB8r4HSlyDdiT.png" alt=""></p><h3 id="三、处理视屏"><a href="#三、处理视屏" class="headerlink" title="三、处理视屏"></a>三、处理视屏</h3><h4 id="1-图像与视屏的关系"><a href="#1-图像与视屏的关系" class="headerlink" title="1. 图像与视屏的关系"></a>1. 图像与视屏的关系</h4><p>下面我们来研究如何处理视屏的图像，其实两者完全一样，视屏有帧数的概念，我们把一帧看做一个图像，那这样理解就轻松很多了，我们只需要一帧一帧地分离视屏，并用图像的处理知识就可以啦。</p><h4 id="2-几个基础的图像或视屏处理命令"><a href="#2-几个基础的图像或视屏处理命令" class="headerlink" title="2.几个基础的图像或视屏处理命令"></a>2.几个基础的图像或视屏处理命令</h4><div class="table-container"><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center">cv2.VideoCapture(‘video.mp4’,(0))</td><td style="text-align:center">捕捉摄像头，后面的0代表默认，可有可无</td></tr><tr><td style="text-align:center">read()</td><td style="text-align:center">检查是否能打开视屏以及读取的图像内容</td></tr><tr><td style="text-align:center">cv2.cvtColor()</td><td style="text-align:center">转换颜色</td></tr><tr><td style="text-align:center">cv2.imshow()</td><td style="text-align:center">展示图像或视屏</td></tr><tr><td style="text-align:center">cv2.waitkeys()</td><td style="text-align:center">等待的时间或视屏图像展示时间</td></tr></tbody></table></div><h4 id="3-视屏基本操作"><a href="#3-视屏基本操作" class="headerlink" title="3.视屏基本操作"></a>3.视屏基本操作</h4><p>下面我们对视屏进行一些基本操作，包括提取视屏，检查是否能打开，将彩色视屏转换为灰色视屏，快进视屏。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 处理视屏</span></span><br><span class="line">video=cv2.VideoCapture(<span class="string">'image/test.mp4'</span>) <span class="comment"># 捕捉摄像头，用数字来控制不同的设备，例如外接通常为400</span></span><br><span class="line"><span class="comment"># 检查是否正确打开</span></span><br><span class="line"><span class="keyword">if</span> video.isOpened():</span><br><span class="line">    open, frame = video.read()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    open=<span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> open:</span><br><span class="line">    ret, frame=video.read()</span><br><span class="line">    <span class="keyword">if</span> frame <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> ret==<span class="literal">True</span>:</span><br><span class="line">        gray=cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)   <span class="comment"># 转换视屏颜色</span></span><br><span class="line">        cv2.imshow(<span class="string">'result'</span>,gray)</span><br><span class="line">        <span class="keyword">if</span> cv2.waitKey(<span class="number">10</span>) &amp; <span class="number">0xFF</span>==<span class="number">27</span>:  <span class="comment"># waitkey代表视屏播放时间，0xFF==27相当于键盘上的Esc键退出</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">video.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h4 id="四、图像基本操作"><a href="#四、图像基本操作" class="headerlink" title="四、图像基本操作"></a>四、图像基本操作</h4><h4 id="1-截取部分图像"><a href="#1-截取部分图像" class="headerlink" title="1.截取部分图像"></a>1.截取部分图像</h4><p>手机上处理照片有一个我们非常常用的功能，叫”裁剪”。同样，计算机上也有。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 截取部分图像数据</span></span><br><span class="line">img=cv2.imread(<span class="string">'image\lena.jpg'</span>)</span><br><span class="line">lena_new=img[<span class="number">0</span>:<span class="number">200</span>,<span class="number">0</span>:<span class="number">200</span>]</span><br><span class="line">cv_show(<span class="string">'lena_new'</span>,lena_new)</span><br><span class="line">cv2.imwrite(<span class="string">'image\lena_new.png'</span>,lena_new) <span class="comment"># 保存图片</span></span><br></pre></td></tr></table></figure><p>通过简单地规定矩阵的范围，我们可以得到裁剪后的图像。</p><p><img src="https://i.loli.net/2020/03/24/mgq8xSG6CedLTUZ.png" alt=""></p><h4 id="2-颜色通道提取"><a href="#2-颜色通道提取" class="headerlink" title="2.颜色通道提取"></a>2.颜色通道提取</h4><p>对于图像的颜色而言，我们之前说了如何将彩色图像转换为灰色图像，其实其他颜色也可以相互转化，我们通过对图像颜色的提取，修改b，g，r这三个在0~255之间的参数，便可以随意更改图像的颜色了。比如这里面，我只保留lena图像中的r参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 颜色通道提取</span></span><br><span class="line">b,g,r=cv2.split(img)</span><br><span class="line"><span class="comment"># 只保留R</span></span><br><span class="line">cur_img=img.copy()</span><br><span class="line">cur_img[:,:,<span class="number">0</span>]=<span class="number">0</span></span><br><span class="line">cur_img[:,:,<span class="number">1</span>]=<span class="number">0</span></span><br><span class="line">cv_show(<span class="string">'R'</span>,cur_img)</span><br><span class="line">cv2.imwrite(<span class="string">'image\lena_R.png'</span>,cur_img) <span class="comment"># 保存图片</span></span><br></pre></td></tr></table></figure><p>我们成功地得到了一张红色的lena照片。对色域感兴趣的小伙伴，可以直接google所有的RGB值。</p><p><img src="https://i.loli.net/2020/03/24/NuSbmdzq9pYBCw5.png" alt=""></p><h4 id="3-边界填充"><a href="#3-边界填充" class="headerlink" title="3.边界填充"></a>3.边界填充</h4><p>除了裁剪图像，有的时候我们还需要拓宽图像的边界，而边界的地方有许多种填充方式，在这里我为大家介绍其中的常用的6种。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 边界填充</span></span><br><span class="line">top_size,bottom_size,left_size,right_size = (<span class="number">50</span>,<span class="number">50</span>,<span class="number">50</span>,<span class="number">50</span>) <span class="comment"># 表示拓充上下左右的宽度</span></span><br><span class="line">replicate = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size, borderType=cv2.BORDER_REPLICATE)</span><br><span class="line">reflect = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size,cv2.BORDER_REFLECT)</span><br><span class="line">reflect101 = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size, cv2.BORDER_REFLECT_101)</span><br><span class="line">wrap = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size, cv2.BORDER_WRAP)</span><br><span class="line">constant = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size,cv2.BORDER_CONSTANT, value=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">231</span>), plt.imshow(img, <span class="string">'gray'</span>), plt.title(<span class="string">'ORIGINAL'</span>)</span><br><span class="line">plt.subplot(<span class="number">232</span>), plt.imshow(replicate, <span class="string">'gray'</span>), plt.title(<span class="string">'REPLICATE'</span>)</span><br><span class="line">plt.subplot(<span class="number">233</span>), plt.imshow(reflect, <span class="string">'gray'</span>), plt.title(<span class="string">'REFLECT'</span>)</span><br><span class="line">plt.subplot(<span class="number">234</span>), plt.imshow(reflect101, <span class="string">'gray'</span>), plt.title(<span class="string">'REFLECT_101'</span>)</span><br><span class="line">plt.subplot(<span class="number">235</span>), plt.imshow(wrap, <span class="string">'gray'</span>), plt.title(<span class="string">'WRAP'</span>)</span><br><span class="line">plt.subplot(<span class="number">236</span>), plt.imshow(constant, <span class="string">'gray'</span>), plt.title(<span class="string">'CONSTANT'</span>)</span><br><span class="line">plt.savefig(<span class="string">'image/image_filling.png'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>这些复杂的代码我觉得并不需要非常深刻地理解，当然如果感兴趣你也可以去看看python底层的库程序到底是怎么实现的。一共六张图片，效果如下图所示。</p><p><img src="https://i.loli.net/2020/03/24/DSwIb4hQto6H5N3.png" alt=""></p><h4 id="4-数值计算"><a href="#4-数值计算" class="headerlink" title="4.数值计算"></a>4.数值计算</h4><p>我们之前说了为了表示色域，所有图像提取的参数都是0~255，那如果我们给所有参数原有基础上加上10呢，又或者我们的参数超过了255怎么办？图像的计算一样非常简单，如果超过了，计算机会自动模256，让其回到原来的区间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数值计算</span></span><br><span class="line">img_cat=cv2.imread(<span class="string">'image/cat.jpg'</span>)</span><br><span class="line">img_car=cv2.imread(<span class="string">'image/car.png'</span>)</span><br><span class="line">img_cat2=img_cat+<span class="number">10</span></span><br><span class="line">img_sum=img_cat+img_cat2 <span class="comment"># 相当于%256</span></span><br><span class="line">img_sum2=cv2.add(img_cat,img_cat2)</span><br></pre></td></tr></table></figure><h4 id="5-图像融合"><a href="#5-图像融合" class="headerlink" title="5.图像融合"></a>5.图像融合</h4><p>相信对基于深度学习的cv感兴趣的伙伴，一定看过一个开源项目基于tensorflow的neural-style。对于简单的图像融合，我们有非常简单的命令。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 图像融合</span></span><br><span class="line"><span class="comment"># print(img_cat.shape,img_car.shape)</span></span><br><span class="line">img_car=cv2.resize(img_car,(<span class="number">500</span>,<span class="number">414</span>))</span><br><span class="line"><span class="comment"># img_car=cv2.resize(img_car,(0,0),fx=1,fy=3)</span></span><br><span class="line">res=cv2.addWeighted(img_cat,<span class="number">0.6</span>,img_car,<span class="number">0.4</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment"># cv_show('fusion',res)</span></span><br><span class="line">plt.imshow(res)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>但是需要注意的是，如果两张照片的尺寸不同，那显然他们像素矩阵是不能直接按权重相加的，这时候我们就需要resize的命令了，大可以动手操作一下以上程序，毕竟实践出真知。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、笔记整理&quot;&gt;&lt;a href=&quot;#一、笔记整理&quot; class=&quot;headerlink&quot; title=&quot;一、笔记整理&quot;&gt;&lt;/a&gt;一、笔记整理&lt;/h3&gt;&lt;p&gt;通过b站以及github的学习完成了本教程，讲解了图像处理的底层知识，本教程所有python代码将会放在我的github仓库上面，通过首页即可访问。欢迎大家通过github来学习，当然想提高学习效率，提前了解git，ssh以及其基本命令是必须的，之后我也会推荐关于计算机视觉以及深度学习的项目。&lt;/p&gt;
    
    </summary>
    
    
      <category term="图像处理与计算机视觉" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"/>
    
      <category term="入门笔记整理" scheme="http://yoursite.com/categories/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86/"/>
    
    
      <category term="图像处理" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
</feed>
